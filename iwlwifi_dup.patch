--- a/drivers/net/wireless/iwlwifi/iwl-csr.h
+++ b/drivers/net/wireless/iwlwifi/iwl-csr.h
@@ -74,7 +74,7 @@
  *
  * Use iwl_write32() and iwl_read32() family to access these registers;
  * these provide simple PCI bus access, without waking up the MAC.
- * Do not use iwl_write_direct32() family for these registers;
+ * Do not use iwl_write_direct32_dup() family for these registers;
  * no need to "grab nic access" via CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ.
  * The MAC (uCode processor, etc.) does not need to be powered up for accessing
  * the CSR registers.
@@ -459,7 +459,7 @@ enum {
  * to indirectly access device's internal memory or registers that
  * may be powered-down.
  *
- * Use iwl_write_direct32()/iwl_read_direct32() family for these registers;
+ * Use iwl_write_direct32_dup()/iwl_read_direct32_dup() family for these registers;
  * host must "grab nic access" via CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ
  * to make sure the MAC (uCode processor, etc.) is powered up for accessing
  * internal resources.
--- a/drivers/net/wireless/iwlwifi/iwl-debug.c
+++ b/drivers/net/wireless/iwlwifi/iwl-debug.c
@@ -69,7 +69,7 @@
 #include "iwl-devtrace.h"
 
 #define __iwl_fn(fn)						\
-void __iwl_ ##fn(struct device *dev, const char *fmt, ...)	\
+void __iwl_ ##fn ##_dup(struct device *dev, const char *fmt, ...)	\
 {								\
 	struct va_format vaf = {				\
 		.fmt = fmt,					\
@@ -84,13 +84,13 @@ void __iwl_ ##fn(struct device *dev, const char *fmt, ...)	\
 }
 
 __iwl_fn(warn)
-IWL_EXPORT_SYMBOL(__iwl_warn);
+IWL_EXPORT_SYMBOL(__iwl_warn_dup);
 __iwl_fn(info)
-IWL_EXPORT_SYMBOL(__iwl_info);
+IWL_EXPORT_SYMBOL(__iwl_info_dup);
 __iwl_fn(crit)
-IWL_EXPORT_SYMBOL(__iwl_crit);
+IWL_EXPORT_SYMBOL(__iwl_crit_dup);
 
-void __iwl_err(struct device *dev, bool rfkill_prefix, bool trace_only,
+void __iwl_err_dup(struct device *dev, bool rfkill_prefix, bool trace_only,
 		const char *fmt, ...)
 {
 	struct va_format vaf = {
@@ -109,10 +109,10 @@ void __iwl_err(struct device *dev, bool rfkill_prefix, bool trace_only,
 	trace_iwlwifi_err(&vaf);
 	va_end(args);
 }
-IWL_EXPORT_SYMBOL(__iwl_err);
+IWL_EXPORT_SYMBOL(__iwl_err_dup);
 
 #if defined(CONFIG_IWLWIFI_DEBUG) || defined(CONFIG_IWLWIFI_DEVICE_TRACING)
-void __iwl_dbg(struct device *dev,
+void __iwl_dbg_dup(struct device *dev,
 	       u32 level, bool limit, const char *function,
 	       const char *fmt, ...)
 {
@@ -132,5 +132,5 @@ void __iwl_dbg(struct device *dev,
 	trace_iwlwifi_dbg(level, in_interrupt(), function, &vaf);
 	va_end(args);
 }
-IWL_EXPORT_SYMBOL(__iwl_dbg);
+IWL_EXPORT_SYMBOL(__iwl_dbg_dup);
 #endif
--- a/drivers/net/wireless/iwlwifi/iwl-debug.h
+++ b/drivers/net/wireless/iwlwifi/iwl-debug.h
@@ -35,17 +35,17 @@
 static inline bool iwl_have_debug_level(u32 level)
 {
 #ifdef CONFIG_IWLWIFI_DEBUG
-	return iwlwifi_mod_params.debug_level & level;
+	return iwlwifi_mod_params_dup.debug_level & level;
 #else
 	return false;
 #endif
 }
 
-void __iwl_err(struct device *dev, bool rfkill_prefix, bool only_trace,
+void __iwl_err_dup(struct device *dev, bool rfkill_prefix, bool only_trace,
 		const char *fmt, ...) __printf(4, 5);
-void __iwl_warn(struct device *dev, const char *fmt, ...) __printf(2, 3);
-void __iwl_info(struct device *dev, const char *fmt, ...) __printf(2, 3);
-void __iwl_crit(struct device *dev, const char *fmt, ...) __printf(2, 3);
+void __iwl_warn_dup(struct device *dev, const char *fmt, ...) __printf(2, 3);
+void __iwl_info_dup(struct device *dev, const char *fmt, ...) __printf(2, 3);
+void __iwl_crit_dup(struct device *dev, const char *fmt, ...) __printf(2, 3);
 
 #if 0 /* Error with RHEL6 compiler */
 /* not all compilers can evaluate strlen() at compile time, so use sizeof() */
@@ -58,33 +58,33 @@ void __iwl_crit(struct device *dev, const char *fmt, ...) __printf(2, 3);
 #define IWL_ERR_DEV(d, f, a...)						\
 	do {								\
 		CHECK_FOR_NEWLINE(f);					\
-		__iwl_err((d), false, false, f, ## a);			\
+		__iwl_err_dup((d), false, false, f, ## a);			\
 	} while (0)
 #define IWL_ERR(m, f, a...)						\
 	IWL_ERR_DEV((m)->dev, f, ## a)
 #define IWL_WARN(m, f, a...)						\
 	do {								\
 		CHECK_FOR_NEWLINE(f);					\
-		__iwl_warn((m)->dev, f, ## a);				\
+		__iwl_warn_dup((m)->dev, f, ## a);				\
 	} while (0)
 #define IWL_INFO(m, f, a...)						\
 	do {								\
 		CHECK_FOR_NEWLINE(f);					\
-		__iwl_info((m)->dev, f, ## a);				\
+		__iwl_info_dup((m)->dev, f, ## a);				\
 	} while (0)
 #define IWL_CRIT(m, f, a...)						\
 	do {								\
 		CHECK_FOR_NEWLINE(f);					\
-		__iwl_crit((m)->dev, f, ## a);				\
+		__iwl_crit_dup((m)->dev, f, ## a);				\
 	} while (0)
 
 #if defined(CONFIG_IWLWIFI_DEBUG) || defined(CONFIG_IWLWIFI_DEVICE_TRACING)
-void __iwl_dbg(struct device *dev,
+void __iwl_dbg_dup(struct device *dev,
 	       u32 level, bool limit, const char *function,
 	       const char *fmt, ...) __printf(5, 6);
 #else
 __printf(5, 6) static inline void
-__iwl_dbg(struct device *dev,
+__iwl_dbg_dup(struct device *dev,
 	  u32 level, bool limit, const char *function,
 	  const char *fmt, ...)
 {}
@@ -99,7 +99,7 @@ do {									\
 #define __IWL_DEBUG_DEV(dev, level, limit, fmt, args...)		\
 	do {								\
 		CHECK_FOR_NEWLINE(fmt);					\
-		__iwl_dbg(dev, level, limit, __func__, fmt, ##args);	\
+		__iwl_dbg_dup(dev, level, limit, __func__, fmt, ##args);	\
 	} while (0)
 #define IWL_DEBUG(m, level, fmt, args...)				\
 	__IWL_DEBUG_DEV((m)->dev, level, false, fmt, ##args)
--- a/drivers/net/wireless/iwlwifi/iwl-devtrace.h
+++ b/drivers/net/wireless/iwlwifi/iwl-devtrace.h
@@ -55,7 +55,7 @@ static inline size_t iwl_rx_trace_len(const struct iwl_trans *trans,
 		return len;
 	/* maybe try to identify EAPOL frames? */
 	return sizeof(__le32) + sizeof(*cmd) + trans->rx_mpdu_cmd_hdr_size +
-		ieee80211_hdrlen(hdr->frame_control);
+		ieee80211_hdrlen_dup(hdr->frame_control);
 }
 #endif
 
--- a/drivers/net/wireless/iwlwifi/iwl-drv.c
+++ b/drivers/net/wireless/iwlwifi/iwl-drv.c
@@ -1335,7 +1335,7 @@ static void iwl_req_fw_callback(const st
 	 * or hangs loading.
 	 */
 	if (load_module) {
-		err = request_module("%s", op->name);
+		err = request_module("%s_dup", op->name);
 #ifdef CONFIG_IWLWIFI_OPMODE_MODULAR
 		if (err)
 			IWL_ERR(drv,
@@ -1450,7 +1450,7 @@ void iwl_drv_stop(struct iwl_drv *drv)
 
 
 /* shared module parameters */
-struct iwl_mod_params iwlwifi_mod_params = {
+struct iwl_mod_params iwlwifi_mod_params_dup = {
 	.restart_fw = true,
 	.bt_coex_active = true,
 	.power_level = IWL_POWER_INDEX_1,
@@ -1460,9 +1460,9 @@ struct iwl_mod_params iwlwifi_mod_params = {
 #endif /* CONFIG_IWLWIFI_UAPSD */
 	/* the rest are 0 by default */
 };
-IWL_EXPORT_SYMBOL(iwlwifi_mod_params);
+IWL_EXPORT_SYMBOL(iwlwifi_mod_params_dup);
 
-int iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops)
+int iwl_opmode_register_dup(const char *name, const struct iwl_op_mode_ops *ops)
 {
 	int i;
 	struct iwl_drv *drv;
@@ -1484,9 +1484,9 @@ int iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops)
 	mutex_unlock(&iwlwifi_opmode_table_mtx);
 	return -EIO;
 }
-IWL_EXPORT_SYMBOL(iwl_opmode_register);
+IWL_EXPORT_SYMBOL(iwl_opmode_register_dup);
 
-void iwl_opmode_deregister(const char *name)
+void iwl_opmode_deregister_dup(const char *name)
 {
 	int i;
 	struct iwl_drv *drv;
@@ -1506,7 +1506,7 @@ void iwl_opmode_deregister(const char *name)
 	}
 	mutex_unlock(&iwlwifi_opmode_table_mtx);
 }
-IWL_EXPORT_SYMBOL(iwl_opmode_deregister);
+IWL_EXPORT_SYMBOL(iwl_opmode_deregister_dup);
 
 static int __init iwl_drv_init(void)
 {
@@ -1543,39 +1543,39 @@ static void __exit iwl_drv_exit(void)
 module_exit(iwl_drv_exit);
 
 #ifdef CONFIG_IWLWIFI_DEBUG
-module_param_named(debug, iwlwifi_mod_params.debug_level, uint,
+module_param_named(debug, iwlwifi_mod_params_dup.debug_level, uint,
 		   S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "debug output mask");
 #endif
 
-module_param_named(swcrypto, iwlwifi_mod_params.sw_crypto, int, S_IRUGO);
+module_param_named(swcrypto, iwlwifi_mod_params_dup.sw_crypto, int, S_IRUGO);
 MODULE_PARM_DESC(swcrypto, "using crypto in software (default 0 [hardware])");
-module_param_named(11n_disable, iwlwifi_mod_params.disable_11n, uint, S_IRUGO);
+module_param_named(11n_disable, iwlwifi_mod_params_dup.disable_11n, uint, S_IRUGO);
 MODULE_PARM_DESC(11n_disable,
 	"disable 11n functionality, bitmap: 1: full, 2: disable agg TX, 4: disable agg RX, 8 enable agg TX");
-module_param_named(amsdu_size_8K, iwlwifi_mod_params.amsdu_size_8K,
+module_param_named(amsdu_size_8K, iwlwifi_mod_params_dup.amsdu_size_8K,
 		   int, S_IRUGO);
 MODULE_PARM_DESC(amsdu_size_8K, "enable 8K amsdu size (default 0)");
-module_param_named(fw_restart, iwlwifi_mod_params.restart_fw, bool, S_IRUGO);
+module_param_named(fw_restart, iwlwifi_mod_params_dup.restart_fw, bool, S_IRUGO);
 MODULE_PARM_DESC(fw_restart, "restart firmware in case of error (default true)");
 
-module_param_named(antenna_coupling, iwlwifi_mod_params.ant_coupling,
+module_param_named(antenna_coupling, iwlwifi_mod_params_dup.ant_coupling,
 		   int, S_IRUGO);
 MODULE_PARM_DESC(antenna_coupling,
 		 "specify antenna coupling in dB (default: 0 dB)");
 
-module_param_named(nvm_file, iwlwifi_mod_params.nvm_file, charp, S_IRUGO);
+module_param_named(nvm_file, iwlwifi_mod_params_dup.nvm_file, charp, S_IRUGO);
 MODULE_PARM_DESC(nvm_file, "NVM file name");
 
-module_param_named(d0i3_disable, iwlwifi_mod_params.d0i3_disable,
+module_param_named(d0i3_disable, iwlwifi_mod_params_dup.d0i3_disable,
 		   bool, S_IRUGO);
 MODULE_PARM_DESC(d0i3_disable, "disable d0i3 functionality (default: Y)");
 
-module_param_named(lar_disable, iwlwifi_mod_params.lar_disable,
+module_param_named(lar_disable, iwlwifi_mod_params_dup.lar_disable,
 		   bool, S_IRUGO);
 MODULE_PARM_DESC(lar_disable, "disable LAR functionality (default: N)");
 
-module_param_named(uapsd_disable, iwlwifi_mod_params.uapsd_disable,
+module_param_named(uapsd_disable, iwlwifi_mod_params_dup.uapsd_disable,
 		   bool, S_IRUGO | S_IWUSR);
 #ifdef CONFIG_IWLWIFI_UAPSD
 MODULE_PARM_DESC(uapsd_disable, "disable U-APSD functionality (default: N)");
@@ -1599,24 +1599,24 @@ MODULE_PARM_DESC(uapsd_disable, "disable U-APSD functionality (default: Y)");
  *
  * default: bt_coex_active = true (BT_COEX_ENABLE)
  */
-module_param_named(bt_coex_active, iwlwifi_mod_params.bt_coex_active,
+module_param_named(bt_coex_active, iwlwifi_mod_params_dup.bt_coex_active,
 		bool, S_IRUGO);
 MODULE_PARM_DESC(bt_coex_active, "enable wifi/bt co-exist (default: enable)");
 
-module_param_named(led_mode, iwlwifi_mod_params.led_mode, int, S_IRUGO);
+module_param_named(led_mode, iwlwifi_mod_params_dup.led_mode, int, S_IRUGO);
 MODULE_PARM_DESC(led_mode, "0=system default, "
 		"1=On(RF On)/Off(RF Off), 2=blinking, 3=Off (default: 0)");
 
-module_param_named(power_save, iwlwifi_mod_params.power_save,
+module_param_named(power_save, iwlwifi_mod_params_dup.power_save,
 		bool, S_IRUGO);
 MODULE_PARM_DESC(power_save,
 		 "enable WiFi power management (default: disable)");
 
-module_param_named(power_level, iwlwifi_mod_params.power_level,
+module_param_named(power_level, iwlwifi_mod_params_dup.power_level,
 		int, S_IRUGO);
 MODULE_PARM_DESC(power_level,
 		 "default power save level (range from 1 - 5, default: 1)");
 
-module_param_named(fw_monitor, iwlwifi_mod_params.fw_monitor, bool, S_IRUGO);
+module_param_named(fw_monitor, iwlwifi_mod_params_dup.fw_monitor, bool, S_IRUGO);
 MODULE_PARM_DESC(fw_monitor,
 		 "firmware monitor - to debug FW (default: false - needs lots of memory)");
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c
@@ -609,7 +609,7 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
 			channel->band = (band == 1) ? IEEE80211_BAND_2GHZ
 						    : IEEE80211_BAND_5GHZ;
 			channel->center_freq =
-				ieee80211_channel_to_frequency(
+				ieee80211_channel_to_frequency_dup(
 					channel->hw_value, channel->band);
 
 			/* set no-HT40, will enable as appropriate later */
@@ -766,7 +766,7 @@ void iwl_init_ht_hw_capab(const struct iwl_cfg *cfg,
 	if (cfg->ht_params->ldpc)
 		ht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;
 
-	if (iwlwifi_mod_params.amsdu_size_8K)
+	if (iwlwifi_mod_params_dup.amsdu_size_8K)
 		ht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;
 
 	ht_info->ampdu_factor = cfg->max_ht_ampdu_exponent;
@@ -839,7 +839,7 @@ static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
 /* EEPROM data functions */
 
 struct iwl_nvm_data *
-iwl_parse_eeprom_data(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_eeprom_data_dup(struct device *dev, const struct iwl_cfg *cfg,
 		      const u8 *eeprom, size_t eeprom_size)
 {
 	struct iwl_nvm_data *data;
@@ -900,7 +900,7 @@ iwl_parse_eeprom_data(struct device *dev, const struct iwl_cfg *cfg,
 	data->sku_cap_band_24GHz_enable = sku & EEPROM_SKU_CAP_BAND_24GHZ;
 	data->sku_cap_band_52GHz_enable = sku & EEPROM_SKU_CAP_BAND_52GHZ;
 	data->sku_cap_ipan_enable = sku & EEPROM_SKU_CAP_IPAN_ENABLE;
-	if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)
+	if (iwlwifi_mod_params_dup.disable_11n & IWL_DISABLE_HT_ALL)
 		data->sku_cap_11n_enable = false;
 
 	data->nvm_version = iwl_eeprom_query16(eeprom, eeprom_size,
@@ -925,10 +925,10 @@ iwl_parse_eeprom_data(struct device *dev, const struct iwl_cfg *cfg,
 	kfree(data);
 	return NULL;
 }
-IWL_EXPORT_SYMBOL(iwl_parse_eeprom_data);
+IWL_EXPORT_SYMBOL(iwl_parse_eeprom_data_dup);
 
 /* helper functions */
-int iwl_nvm_check_version(struct iwl_nvm_data *data,
+int iwl_nvm_check_version_dup(struct iwl_nvm_data *data,
 			     struct iwl_trans *trans)
 {
 	if (data->nvm_version >= trans->cfg->nvm_ver ||
@@ -944,4 +944,4 @@ int iwl_nvm_check_version(struct iwl_nvm_data *data,
 		data->calib_version,  trans->cfg->nvm_calib_ver);
 	return -EINVAL;
 }
-IWL_EXPORT_SYMBOL(iwl_nvm_check_version);
+IWL_EXPORT_SYMBOL(iwl_nvm_check_version_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h
@@ -103,7 +103,7 @@ struct iwl_nvm_data {
 };
 
 /**
- * iwl_parse_eeprom_data - parse EEPROM data and return values
+ * iwl_parse_eeprom_data_dup - parse EEPROM data and return values
  *
  * @dev: device pointer we're parsing for, for debug only
  * @cfg: device configuration for parsing and overrides
@@ -116,7 +116,7 @@ struct iwl_nvm_data {
  * later with iwl_free_nvm_data().
  */
 struct iwl_nvm_data *
-iwl_parse_eeprom_data(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_eeprom_data_dup(struct device *dev, const struct iwl_cfg *cfg,
 		      const u8 *eeprom, size_t eeprom_size);
 
 /**
@@ -128,7 +128,7 @@ static inline void iwl_free_nvm_data(struct iwl_nvm_data *data)
 	kfree(data);
 }
 
-int iwl_nvm_check_version(struct iwl_nvm_data *data,
+int iwl_nvm_check_version_dup(struct iwl_nvm_data *data,
 			  struct iwl_trans *trans);
 
 int iwl_init_sband_channels(struct iwl_nvm_data *data,
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c
@@ -105,7 +105,7 @@ static int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)
 			    CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);
 
 		/* See if we got it */
-		ret = iwl_poll_bit(trans, CSR_HW_IF_CONFIG_REG,
+		ret = iwl_poll_bit_dup(trans, CSR_HW_IF_CONFIG_REG,
 				CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,
 				CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,
 				EEPROM_SEM_TIMEOUT);
@@ -202,17 +202,17 @@ static int iwl_init_otp_access(struct iwl_trans *trans)
 		    CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
 
 	/* wait for clock to be ready */
-	ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+	ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   25000);
 	if (ret < 0) {
 		IWL_ERR(trans, "Time out access OTP\n");
 	} else {
-		iwl_set_bits_prph(trans, APMG_PS_CTRL_REG,
+		iwl_set_bits_prph_dup(trans, APMG_PS_CTRL_REG,
 				  APMG_PS_CTRL_VAL_RESET_REQ);
 		udelay(5);
-		iwl_clear_bits_prph(trans, APMG_PS_CTRL_REG,
+		iwl_clear_bits_prph_dup(trans, APMG_PS_CTRL_REG,
 				    APMG_PS_CTRL_VAL_RESET_REQ);
 
 		/*
@@ -235,7 +235,7 @@ static int iwl_read_otp_word(struct iwl_trans *trans, u16 addr,
 
 	iwl_write32(trans, CSR_EEPROM_REG,
 		    CSR_EEPROM_REG_MSK_ADDR & (addr << 1));
-	ret = iwl_poll_bit(trans, CSR_EEPROM_REG,
+	ret = iwl_poll_bit_dup(trans, CSR_EEPROM_REG,
 				 CSR_EEPROM_REG_READ_VALID_MSK,
 				 CSR_EEPROM_REG_READ_VALID_MSK,
 				 IWL_EEPROM_ACCESS_TIMEOUT);
@@ -348,14 +348,14 @@ static int iwl_find_otp_image(struct iwl_trans *trans,
 }
 
 /**
- * iwl_read_eeprom - read EEPROM contents
+ * iwl_read_eeprom_dup - read EEPROM contents
  *
  * Load the EEPROM contents from adapter and return it
  * and its size.
  *
  * NOTE:  This routine uses the non-debug IO access functions.
  */
-int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)
+int iwl_read_eeprom_dup(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)
 {
 	__le16 *e;
 	u32 gp = iwl_read32(trans, CSR_EEPROM_GP);
@@ -431,7 +431,7 @@ int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)
 			iwl_write32(trans, CSR_EEPROM_REG,
 				    CSR_EEPROM_REG_MSK_ADDR & (addr << 1));
 
-			ret = iwl_poll_bit(trans, CSR_EEPROM_REG,
+			ret = iwl_poll_bit_dup(trans, CSR_EEPROM_REG,
 					   CSR_EEPROM_REG_READ_VALID_MSK,
 					   CSR_EEPROM_REG_READ_VALID_MSK,
 					   IWL_EEPROM_ACCESS_TIMEOUT);
@@ -461,4 +461,4 @@ int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)
 
 	return ret;
 }
-IWL_EXPORT_SYMBOL(iwl_read_eeprom);
+IWL_EXPORT_SYMBOL(iwl_read_eeprom_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h
@@ -65,6 +65,6 @@
 
 #include "iwl-trans.h"
 
-int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size);
+int iwl_read_eeprom_dup(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size);
 
 #endif  /* __iwl_eeprom_h__ */
--- a/drivers/net/wireless/iwlwifi/iwl-io.c
+++ b/drivers/net/wireless/iwlwifi/iwl-io.c
@@ -38,7 +38,7 @@
 
 #define IWL_POLL_INTERVAL 10	/* microseconds */
 
-int iwl_poll_bit(struct iwl_trans *trans, u32 addr,
+int iwl_poll_bit_dup(struct iwl_trans *trans, u32 addr,
 		 u32 bits, u32 mask, int timeout)
 {
 	int t = 0;
@@ -52,9 +52,9 @@ int iwl_poll_bit(struct iwl_trans *trans, u32 addr,
 
 	return -ETIMEDOUT;
 }
-IWL_EXPORT_SYMBOL(iwl_poll_bit);
+IWL_EXPORT_SYMBOL(iwl_poll_bit_dup);
 
-u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg)
+u32 iwl_read_direct32_dup(struct iwl_trans *trans, u32 reg)
 {
 	u32 value = 0x5a5a5a5a;
 	unsigned long flags;
@@ -65,9 +65,9 @@ u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg)
 
 	return value;
 }
-IWL_EXPORT_SYMBOL(iwl_read_direct32);
+IWL_EXPORT_SYMBOL(iwl_read_direct32_dup);
 
-void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value)
+void iwl_write_direct32_dup(struct iwl_trans *trans, u32 reg, u32 value)
 {
 	unsigned long flags;
 
@@ -76,15 +76,15 @@ void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value)
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_write_direct32);
+IWL_EXPORT_SYMBOL(iwl_write_direct32_dup);
 
-int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask,
+int iwl_poll_direct_bit_dup(struct iwl_trans *trans, u32 addr, u32 mask,
 			int timeout)
 {
 	int t = 0;
 
 	do {
-		if ((iwl_read_direct32(trans, addr) & mask) == mask)
+		if ((iwl_read_direct32_dup(trans, addr) & mask) == mask)
 			return t;
 		udelay(IWL_POLL_INTERVAL);
 		t += IWL_POLL_INTERVAL;
@@ -92,44 +92,44 @@ int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask,
 
 	return -ETIMEDOUT;
 }
-IWL_EXPORT_SYMBOL(iwl_poll_direct_bit);
+IWL_EXPORT_SYMBOL(iwl_poll_direct_bit_dup);
 
-u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs)
+u32 __iwl_read_prph_dup(struct iwl_trans *trans, u32 ofs)
 {
 	u32 val = iwl_trans_read_prph(trans, ofs);
 	trace_iwlwifi_dev_ioread_prph32(trans->dev, ofs, val);
 	return val;
 }
 
-void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
+void __iwl_write_prph_dup(struct iwl_trans *trans, u32 ofs, u32 val)
 {
 	trace_iwlwifi_dev_iowrite_prph32(trans->dev, ofs, val);
 	iwl_trans_write_prph(trans, ofs, val);
 }
 
-u32 iwl_read_prph(struct iwl_trans *trans, u32 ofs)
+u32 iwl_read_prph_dup(struct iwl_trans *trans, u32 ofs)
 {
 	unsigned long flags;
 	u32 val = 0x5a5a5a5a;
 
 	if (iwl_trans_grab_nic_access(trans, false, &flags)) {
-		val = __iwl_read_prph(trans, ofs);
+		val = __iwl_read_prph_dup(trans, ofs);
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 	return val;
 }
-IWL_EXPORT_SYMBOL(iwl_read_prph);
+IWL_EXPORT_SYMBOL(iwl_read_prph_dup);
 
-void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
+void iwl_write_prph_dup(struct iwl_trans *trans, u32 ofs, u32 val)
 {
 	unsigned long flags;
 
 	if (iwl_trans_grab_nic_access(trans, false, &flags)) {
-		__iwl_write_prph(trans, ofs, val);
+		__iwl_write_prph_dup(trans, ofs, val);
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_write_prph);
+IWL_EXPORT_SYMBOL(iwl_write_prph_dup);
 
 int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
 		      u32 bits, u32 mask, int timeout)
@@ -137,7 +137,7 @@ int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
 	int t = 0;
 
 	do {
-		if ((iwl_read_prph(trans, addr) & mask) == (bits & mask))
+		if ((iwl_read_prph_dup(trans, addr) & mask) == (bits & mask))
 			return t;
 		udelay(IWL_POLL_INTERVAL);
 		t += IWL_POLL_INTERVAL;
@@ -146,59 +146,59 @@ int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
 	return -ETIMEDOUT;
 }
 
-void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
+void iwl_set_bits_prph_dup(struct iwl_trans *trans, u32 ofs, u32 mask)
 {
 	unsigned long flags;
 
 	if (iwl_trans_grab_nic_access(trans, false, &flags)) {
-		__iwl_write_prph(trans, ofs,
-				 __iwl_read_prph(trans, ofs) | mask);
+		__iwl_write_prph_dup(trans, ofs,
+				 __iwl_read_prph_dup(trans, ofs) | mask);
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_set_bits_prph);
+IWL_EXPORT_SYMBOL(iwl_set_bits_prph_dup);
 
-void iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs,
+void iwl_set_bits_mask_prph_dup(struct iwl_trans *trans, u32 ofs,
 			    u32 bits, u32 mask)
 {
 	unsigned long flags;
 
 	if (iwl_trans_grab_nic_access(trans, false, &flags)) {
-		__iwl_write_prph(trans, ofs,
-				 (__iwl_read_prph(trans, ofs) & mask) | bits);
+		__iwl_write_prph_dup(trans, ofs,
+				 (__iwl_read_prph_dup(trans, ofs) & mask) | bits);
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_set_bits_mask_prph);
+IWL_EXPORT_SYMBOL(iwl_set_bits_mask_prph_dup);
 
-void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
+void iwl_clear_bits_prph_dup(struct iwl_trans *trans, u32 ofs, u32 mask)
 {
 	unsigned long flags;
 	u32 val;
 
 	if (iwl_trans_grab_nic_access(trans, false, &flags)) {
-		val = __iwl_read_prph(trans, ofs);
-		__iwl_write_prph(trans, ofs, (val & ~mask));
+		val = __iwl_read_prph_dup(trans, ofs);
+		__iwl_write_prph_dup(trans, ofs, (val & ~mask));
 		iwl_trans_release_nic_access(trans, &flags);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_clear_bits_prph);
+IWL_EXPORT_SYMBOL(iwl_clear_bits_prph_dup);
 
-void iwl_force_nmi(struct iwl_trans *trans)
+void iwl_force_nmi_dup(struct iwl_trans *trans)
 {
 	if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
-		iwl_write_prph(trans, DEVICE_SET_NMI_REG,
+		iwl_write_prph_dup(trans, DEVICE_SET_NMI_REG,
 			       DEVICE_SET_NMI_VAL_DRV);
-		iwl_write_prph(trans, DEVICE_SET_NMI_REG,
+		iwl_write_prph_dup(trans, DEVICE_SET_NMI_REG,
 			       DEVICE_SET_NMI_VAL_HW);
 	} else {
-		iwl_write_prph(trans, DEVICE_SET_NMI_8000_REG,
+		iwl_write_prph_dup(trans, DEVICE_SET_NMI_8000_REG,
 			       DEVICE_SET_NMI_8000_VAL);
-		iwl_write_prph(trans, DEVICE_SET_NMI_REG,
+		iwl_write_prph_dup(trans, DEVICE_SET_NMI_REG,
 			       DEVICE_SET_NMI_VAL_DRV);
 	}
 }
-IWL_EXPORT_SYMBOL(iwl_force_nmi);
+IWL_EXPORT_SYMBOL(iwl_force_nmi_dup);
 
 static const char *get_fh_string(int cmd)
 {
@@ -250,7 +250,7 @@ int iwl_dump_fh(struct iwl_trans *trans, char **buf)
 			pos += scnprintf(*buf + pos, bufsz - pos,
 				"  %34s: 0X%08x\n",
 				get_fh_string(fh_tbl[i]),
-				iwl_read_direct32(trans, fh_tbl[i]));
+				iwl_read_direct32_dup(trans, fh_tbl[i]));
 
 		return pos;
 	}
@@ -260,7 +260,7 @@ int iwl_dump_fh(struct iwl_trans *trans, char **buf)
 	for (i = 0; i <  ARRAY_SIZE(fh_tbl); i++)
 		IWL_ERR(trans, "  %34s: 0X%08x\n",
 			get_fh_string(fh_tbl[i]),
-			iwl_read_direct32(trans, fh_tbl[i]));
+			iwl_read_direct32_dup(trans, fh_tbl[i]));
 
 	return 0;
 }
--- a/drivers/net/wireless/iwlwifi/iwl-io.h
+++ b/drivers/net/wireless/iwlwifi/iwl-io.h
@@ -61,26 +61,26 @@ static inline void iwl_clear_bit(struct iwl_trans *trans, u32 reg, u32 mask)
 	iwl_trans_set_bits_mask(trans, reg, mask, 0);
 }
 
-int iwl_poll_bit(struct iwl_trans *trans, u32 addr,
+int iwl_poll_bit_dup(struct iwl_trans *trans, u32 addr,
 		 u32 bits, u32 mask, int timeout);
-int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask,
+int iwl_poll_direct_bit_dup(struct iwl_trans *trans, u32 addr, u32 mask,
 			int timeout);
 
-u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg);
-void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value);
+u32 iwl_read_direct32_dup(struct iwl_trans *trans, u32 reg);
+void iwl_write_direct32_dup(struct iwl_trans *trans, u32 reg, u32 value);
 
 
-u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs);
-u32 iwl_read_prph(struct iwl_trans *trans, u32 ofs);
-void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);
-void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);
+u32 __iwl_read_prph_dup(struct iwl_trans *trans, u32 ofs);
+u32 iwl_read_prph_dup(struct iwl_trans *trans, u32 ofs);
+void __iwl_write_prph_dup(struct iwl_trans *trans, u32 ofs, u32 val);
+void iwl_write_prph_dup(struct iwl_trans *trans, u32 ofs, u32 val);
 int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
 		      u32 bits, u32 mask, int timeout);
-void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);
-void iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs,
+void iwl_set_bits_prph_dup(struct iwl_trans *trans, u32 ofs, u32 mask);
+void iwl_set_bits_mask_prph_dup(struct iwl_trans *trans, u32 ofs,
 			    u32 bits, u32 mask);
-void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);
-void iwl_force_nmi(struct iwl_trans *trans);
+void iwl_clear_bits_prph_dup(struct iwl_trans *trans, u32 ofs, u32 mask);
+void iwl_force_nmi_dup(struct iwl_trans *trans);
 
 /* Error handling */
 int iwl_dump_fh(struct iwl_trans *trans, char **buf);
--- a/drivers/net/wireless/iwlwifi/iwl-modparams.h
+++ b/drivers/net/wireless/iwlwifi/iwl-modparams.h
@@ -68,7 +68,7 @@
 #include <linux/gfp.h>
 #include <net/mac80211.h>
 
-extern struct iwl_mod_params iwlwifi_mod_params;
+extern struct iwl_mod_params iwlwifi_mod_params_dup;
 
 enum iwl_power_level {
 	IWL_POWER_INDEX_1,
--- a/drivers/net/wireless/iwlwifi/iwl-notif-wait.c
+++ b/drivers/net/wireless/iwlwifi/iwl-notif-wait.c
@@ -67,15 +67,15 @@
 #include "iwl-notif-wait.h"
 
 
-void iwl_notification_wait_init(struct iwl_notif_wait_data *notif_wait)
+void iwl_notification_wait_init_dup(struct iwl_notif_wait_data *notif_wait)
 {
 	spin_lock_init(&notif_wait->notif_wait_lock);
 	INIT_LIST_HEAD(&notif_wait->notif_waits);
 	init_waitqueue_head(&notif_wait->notif_waitq);
 }
-IWL_EXPORT_SYMBOL(iwl_notification_wait_init);
+IWL_EXPORT_SYMBOL(iwl_notification_wait_init_dup);
 
-void iwl_notification_wait_notify(struct iwl_notif_wait_data *notif_wait,
+void iwl_notification_wait_notify_dup(struct iwl_notif_wait_data *notif_wait,
 				  struct iwl_rx_packet *pkt)
 {
 	bool triggered = false;
@@ -118,9 +118,9 @@ void iwl_notification_wait_notify(struct iwl_notif_wait_data *notif_wait,
 	if (triggered)
 		wake_up_all(&notif_wait->notif_waitq);
 }
-IWL_EXPORT_SYMBOL(iwl_notification_wait_notify);
+IWL_EXPORT_SYMBOL(iwl_notification_wait_notify_dup);
 
-void iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_wait)
+void iwl_abort_notification_waits_dup(struct iwl_notif_wait_data *notif_wait)
 {
 	struct iwl_notification_wait *wait_entry;
 
@@ -131,10 +131,10 @@ void iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_wait)
 
 	wake_up_all(&notif_wait->notif_waitq);
 }
-IWL_EXPORT_SYMBOL(iwl_abort_notification_waits);
+IWL_EXPORT_SYMBOL(iwl_abort_notification_waits_dup);
 
 void
-iwl_init_notification_wait(struct iwl_notif_wait_data *notif_wait,
+iwl_init_notification_wait_dup(struct iwl_notif_wait_data *notif_wait,
 			   struct iwl_notification_wait *wait_entry,
 			   const u8 *cmds, int n_cmds,
 			   bool (*fn)(struct iwl_notif_wait_data *notif_wait,
@@ -155,9 +155,9 @@ iwl_init_notification_wait(struct iwl_notif_wait_data *notif_wait,
 	list_add(&wait_entry->list, &notif_wait->notif_waits);
 	spin_unlock_bh(&notif_wait->notif_wait_lock);
 }
-IWL_EXPORT_SYMBOL(iwl_init_notification_wait);
+IWL_EXPORT_SYMBOL(iwl_init_notification_wait_dup);
 
-int iwl_wait_notification(struct iwl_notif_wait_data *notif_wait,
+int iwl_wait_notification_dup(struct iwl_notif_wait_data *notif_wait,
 			  struct iwl_notification_wait *wait_entry,
 			  unsigned long timeout)
 {
@@ -179,13 +179,13 @@ int iwl_wait_notification(struct iwl_notif_wait_data *notif_wait,
 		return -ETIMEDOUT;
 	return 0;
 }
-IWL_EXPORT_SYMBOL(iwl_wait_notification);
+IWL_EXPORT_SYMBOL(iwl_wait_notification_dup);
 
-void iwl_remove_notification(struct iwl_notif_wait_data *notif_wait,
+void iwl_remove_notification_dup(struct iwl_notif_wait_data *notif_wait,
 			     struct iwl_notification_wait *wait_entry)
 {
 	spin_lock_bh(&notif_wait->notif_wait_lock);
 	list_del(&wait_entry->list);
 	spin_unlock_bh(&notif_wait->notif_wait_lock);
 }
-IWL_EXPORT_SYMBOL(iwl_remove_notification);
+IWL_EXPORT_SYMBOL(iwl_remove_notification_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-notif-wait.h
+++ b/drivers/net/wireless/iwlwifi/iwl-notif-wait.h
@@ -112,14 +112,14 @@ struct iwl_notification_wait {
 
 
 /* caller functions */
-void iwl_notification_wait_init(struct iwl_notif_wait_data *notif_data);
-void iwl_notification_wait_notify(struct iwl_notif_wait_data *notif_data,
+void iwl_notification_wait_init_dup(struct iwl_notif_wait_data *notif_data);
+void iwl_notification_wait_notify_dup(struct iwl_notif_wait_data *notif_data,
 				  struct iwl_rx_packet *pkt);
-void iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_data);
+void iwl_abort_notification_waits_dup(struct iwl_notif_wait_data *notif_data);
 
 /* user functions */
 void __acquires(wait_entry)
-iwl_init_notification_wait(struct iwl_notif_wait_data *notif_data,
+iwl_init_notification_wait_dup(struct iwl_notif_wait_data *notif_data,
 			   struct iwl_notification_wait *wait_entry,
 			   const u8 *cmds, int n_cmds,
 			   bool (*fn)(struct iwl_notif_wait_data *notif_data,
@@ -127,12 +127,12 @@ iwl_init_notification_wait(struct iwl_notif_wait_data *notif_data,
 			   void *fn_data);
 
 int __must_check __releases(wait_entry)
-iwl_wait_notification(struct iwl_notif_wait_data *notif_data,
+iwl_wait_notification_dup(struct iwl_notif_wait_data *notif_data,
 		      struct iwl_notification_wait *wait_entry,
 		      unsigned long timeout);
 
 void __releases(wait_entry)
-iwl_remove_notification(struct iwl_notif_wait_data *notif_data,
+iwl_remove_notification_dup(struct iwl_notif_wait_data *notif_data,
 			struct iwl_notification_wait *wait_entry);
 
 #endif /* __iwl_notif_wait_h__ */
--- a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
+++ b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
@@ -306,7 +306,7 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
 		channel->band = (ch_idx < num_2ghz_channels) ?
 				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;
 		channel->center_freq =
-			ieee80211_channel_to_frequency(
+			ieee80211_channel_to_frequency_dup(
 				channel->hw_value, channel->band);
 
 		/* Initialize regulatory-based run-time data */
@@ -379,7 +379,7 @@ static void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,
 	else
 		vht_cap->cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;
 
-	if (iwlwifi_mod_params.amsdu_size_8K)
+	if (iwlwifi_mod_params_dup.amsdu_size_8K)
 		vht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;
 
 	vht_cap->vht_mcs.rx_mcs_map =
@@ -583,7 +583,7 @@ static void iwl_set_hw_address_family_8000(struct device *dev,
 }
 
 struct iwl_nvm_data *
-iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_nvm_data_dup(struct device *dev, const struct iwl_cfg *cfg,
 		   const __le16 *nvm_hw, const __le16 *nvm_sw,
 		   const __le16 *nvm_calib, const __le16 *regulatory,
 		   const __le16 *mac_override, const __le16 *phy_sku,
@@ -621,7 +621,7 @@ iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
 	data->sku_cap_band_24GHz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;
 	data->sku_cap_band_52GHz_enable = sku & NVM_SKU_CAP_BAND_52GHZ;
 	data->sku_cap_11n_enable = sku & NVM_SKU_CAP_11N_ENABLE;
-	if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)
+	if (iwlwifi_mod_params_dup.disable_11n & IWL_DISABLE_HT_ALL)
 		data->sku_cap_11n_enable = false;
 	data->sku_cap_11ac_enable = data->sku_cap_11n_enable &&
 				    (sku & NVM_SKU_CAP_11AC_ENABLE);
@@ -669,7 +669,7 @@ iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
 
 	return data;
 }
-IWL_EXPORT_SYMBOL(iwl_parse_nvm_data);
+IWL_EXPORT_SYMBOL(iwl_parse_nvm_data_dup);
 
 static u32 iwl_nvm_get_regdom_bw_flags(const u8 *nvm_chan,
 				       int ch_idx, u16 nvm_flags,
@@ -720,7 +720,7 @@ static u32 iwl_nvm_get_regdom_bw_flags(const u8 *nvm_chan,
 }
 
 struct ieee80211_regdomain *
-iwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_nvm_mcc_info_dup(struct device *dev, const struct iwl_cfg *cfg,
 		       int num_of_ch, __le32 *channels, u16 fw_mcc)
 {
 	int ch_idx;
@@ -759,7 +759,7 @@ iwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,
 		ch_flags = (u16)__le32_to_cpup(channels + ch_idx);
 		band = (ch_idx < NUM_2GHZ_CHANNELS) ?
 		       IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;
-		center_freq = ieee80211_channel_to_frequency(nvm_chan[ch_idx],
+		center_freq = ieee80211_channel_to_frequency_dup(nvm_chan[ch_idx],
 							     band);
 		new_rule = false;
 
@@ -830,4 +830,4 @@ iwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,
 
 	return regd;
 }
-IWL_EXPORT_SYMBOL(iwl_parse_nvm_mcc_info);
+IWL_EXPORT_SYMBOL(iwl_parse_nvm_mcc_info_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h
+++ b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h
@@ -66,7 +66,7 @@
 #include "iwl-eeprom-parse.h"
 
 /**
- * iwl_parse_nvm_data - parse NVM data and return values
+ * iwl_parse_nvm_data_dup - parse NVM data and return values
  *
  * This function parses all NVM values we need and then
  * returns a (newly allocated) struct containing all the
@@ -74,7 +74,7 @@
  * later with iwl_free_nvm_data().
  */
 struct iwl_nvm_data *
-iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_nvm_data_dup(struct device *dev, const struct iwl_cfg *cfg,
 		   const __le16 *nvm_hw, const __le16 *nvm_sw,
 		   const __le16 *nvm_calib, const __le16 *regulatory,
 		   const __le16 *mac_override, const __le16 *phy_sku,
@@ -91,7 +91,7 @@ iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
  * the regdomain returned here with kfree.
  */
 struct ieee80211_regdomain *
-iwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,
+iwl_parse_nvm_mcc_info_dup(struct device *dev, const struct iwl_cfg *cfg,
 		       int num_of_ch, __le32 *channels, u16 fw_mcc);
 
 #endif /* __iwl_nvm_parse_h__ */
--- a/drivers/net/wireless/iwlwifi/iwl-op-mode.h
+++ b/drivers/net/wireless/iwlwifi/iwl-op-mode.h
@@ -167,8 +167,8 @@ struct iwl_op_mode_ops {
 	int (*exit_d0i3)(struct iwl_op_mode *op_mode);
 };
 
-int iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops);
-void iwl_opmode_deregister(const char *name);
+int iwl_opmode_register_dup(const char *name, const struct iwl_op_mode_ops *ops);
+void iwl_opmode_deregister_dup(const char *name);
 
 /**
  * struct iwl_op_mode - operational mode
--- a/drivers/net/wireless/iwlwifi/iwl-phy-db.c
+++ b/drivers/net/wireless/iwlwifi/iwl-phy-db.c
@@ -133,7 +133,7 @@ struct iwl_calib_res_notif_phy_db {
 	u8 data[];
 } __packed;
 
-struct iwl_phy_db *iwl_phy_db_init(struct iwl_trans *trans)
+struct iwl_phy_db *iwl_phy_db_init_dup(struct iwl_trans *trans)
 {
 	struct iwl_phy_db *phy_db = kzalloc(sizeof(struct iwl_phy_db),
 					    GFP_KERNEL);
@@ -146,7 +146,7 @@ struct iwl_phy_db *iwl_phy_db_init(struct iwl_trans *trans)
 	/* TODO: add default values of the phy db. */
 	return phy_db;
 }
-IWL_EXPORT_SYMBOL(iwl_phy_db_init);
+IWL_EXPORT_SYMBOL(iwl_phy_db_init_dup);
 
 /*
  * get phy db section: returns a pointer to a phy db section specified by
@@ -179,7 +179,7 @@ iwl_phy_db_get_section(struct iwl_phy_db *phy_db,
 	return NULL;
 }
 
-static void iwl_phy_db_free_section(struct iwl_phy_db *phy_db,
+static void iwl_phy_db_free_dup_section(struct iwl_phy_db *phy_db,
 				    enum iwl_phy_db_section_type type,
 				    u16 chg_id)
 {
@@ -193,25 +193,25 @@ static void iwl_phy_db_free_section(struct iwl_phy_db *phy_db,
 	entry->size = 0;
 }
 
-void iwl_phy_db_free(struct iwl_phy_db *phy_db)
+void iwl_phy_db_free_dup(struct iwl_phy_db *phy_db)
 {
 	int i;
 
 	if (!phy_db)
 		return;
 
-	iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CFG, 0);
-	iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_NCH, 0);
+	iwl_phy_db_free_dup_section(phy_db, IWL_PHY_DB_CFG, 0);
+	iwl_phy_db_free_dup_section(phy_db, IWL_PHY_DB_CALIB_NCH, 0);
 	for (i = 0; i < IWL_NUM_PAPD_CH_GROUPS; i++)
-		iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_CHG_PAPD, i);
+		iwl_phy_db_free_dup_section(phy_db, IWL_PHY_DB_CALIB_CHG_PAPD, i);
 	for (i = 0; i < IWL_NUM_TXP_CH_GROUPS; i++)
-		iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_CHG_TXP, i);
+		iwl_phy_db_free_dup_section(phy_db, IWL_PHY_DB_CALIB_CHG_TXP, i);
 
 	kfree(phy_db);
 }
-IWL_EXPORT_SYMBOL(iwl_phy_db_free);
+IWL_EXPORT_SYMBOL(iwl_phy_db_free_dup);
 
-int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
+int iwl_phy_db_set_section_dup(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
 			   gfp_t alloc_ctx)
 {
 	struct iwl_calib_res_notif_phy_db *phy_db_notif =
@@ -247,7 +247,7 @@ int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
 
 	return 0;
 }
-IWL_EXPORT_SYMBOL(iwl_phy_db_set_section);
+IWL_EXPORT_SYMBOL(iwl_phy_db_set_section_dup);
 
 static int is_valid_channel(u16 ch_id)
 {
@@ -405,7 +405,7 @@ static int iwl_phy_db_send_all_channel_groups(
 	return 0;
 }
 
-int iwl_send_phy_db_data(struct iwl_phy_db *phy_db)
+int iwl_send_phy_db_data_dup(struct iwl_phy_db *phy_db)
 {
 	u8 *data = NULL;
 	u16 size = 0;
@@ -468,4 +468,4 @@ int iwl_send_phy_db_data(struct iwl_phy_db *phy_db)
 		       "Finished sending phy db non channel data\n");
 	return 0;
 }
-IWL_EXPORT_SYMBOL(iwl_send_phy_db_data);
+IWL_EXPORT_SYMBOL(iwl_send_phy_db_data_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-phy-db.h
+++ b/drivers/net/wireless/iwlwifi/iwl-phy-db.h
@@ -69,14 +69,14 @@
 #include "iwl-op-mode.h"
 #include "iwl-trans.h"
 
-struct iwl_phy_db *iwl_phy_db_init(struct iwl_trans *trans);
+struct iwl_phy_db *iwl_phy_db_init_dup(struct iwl_trans *trans);
 
-void iwl_phy_db_free(struct iwl_phy_db *phy_db);
+void iwl_phy_db_free_dup(struct iwl_phy_db *phy_db);
 
-int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
+int iwl_phy_db_set_section_dup(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
 			   gfp_t alloc_ctx);
 
 
-int iwl_send_phy_db_data(struct iwl_phy_db *phy_db);
+int iwl_send_phy_db_data_dup(struct iwl_phy_db *phy_db);
 
 #endif /* __IWL_PHYDB_H__ */
--- a/drivers/net/wireless/iwlwifi/iwl-scd.h
+++ b/drivers/net/wireless/iwlwifi/iwl-scd.h
@@ -72,40 +72,40 @@
 static inline void iwl_scd_txq_set_chain(struct iwl_trans *trans,
 					 u16 txq_id)
 {
-	iwl_set_bits_prph(trans, SCD_QUEUECHAIN_SEL, BIT(txq_id));
+	iwl_set_bits_prph_dup(trans, SCD_QUEUECHAIN_SEL, BIT(txq_id));
 }
 
 static inline void iwl_scd_txq_enable_agg(struct iwl_trans *trans,
 					  u16 txq_id)
 {
-	iwl_set_bits_prph(trans, SCD_AGGR_SEL, BIT(txq_id));
+	iwl_set_bits_prph_dup(trans, SCD_AGGR_SEL, BIT(txq_id));
 }
 
 static inline void iwl_scd_txq_disable_agg(struct iwl_trans *trans,
 					   u16 txq_id)
 {
-	iwl_clear_bits_prph(trans, SCD_AGGR_SEL, BIT(txq_id));
+	iwl_clear_bits_prph_dup(trans, SCD_AGGR_SEL, BIT(txq_id));
 }
 
 static inline void iwl_scd_disable_agg(struct iwl_trans *trans)
 {
-	iwl_set_bits_prph(trans, SCD_AGGR_SEL, 0);
+	iwl_set_bits_prph_dup(trans, SCD_AGGR_SEL, 0);
 }
 
 static inline void iwl_scd_activate_fifos(struct iwl_trans *trans)
 {
-	iwl_write_prph(trans, SCD_TXFACT, IWL_MASK(0, 7));
+	iwl_write_prph_dup(trans, SCD_TXFACT, IWL_MASK(0, 7));
 }
 
 static inline void iwl_scd_deactivate_fifos(struct iwl_trans *trans)
 {
-	iwl_write_prph(trans, SCD_TXFACT, 0);
+	iwl_write_prph_dup(trans, SCD_TXFACT, 0);
 }
 
 static inline void iwl_scd_enable_set_active(struct iwl_trans *trans,
 					     u32 value)
 {
-	iwl_write_prph(trans, SCD_EN_CTRL, value);
+	iwl_write_prph_dup(trans, SCD_EN_CTRL, value);
 }
 
 static inline unsigned int SCD_QUEUE_WRPTR(unsigned int chnl)
@@ -135,7 +135,7 @@ static inline unsigned int SCD_QUEUE_STATUS_BITS(unsigned int chnl)
 static inline void iwl_scd_txq_set_inactive(struct iwl_trans *trans,
 					    u16 txq_id)
 {
-	iwl_write_prph(trans, SCD_QUEUE_STATUS_BITS(txq_id),
+	iwl_write_prph_dup(trans, SCD_QUEUE_STATUS_BITS(txq_id),
 		       (0 << SCD_QUEUE_STTS_REG_POS_ACTIVE)|
 		       (1 << SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));
 }
--- a/drivers/net/wireless/iwlwifi/iwl-test.c
+++ b/drivers/net/wireless/iwlwifi/iwl-test.c
@@ -160,7 +160,7 @@ static inline void iwl_test_mem_stop(struct iwl_test *tst)
  * During the lifetime of the test object it is assumed that the transport is
  * started. The test object should be stopped before the transport is stopped.
  */
-void iwl_test_init(struct iwl_test *tst, struct iwl_trans *trans,
+void iwl_test_init_dup(struct iwl_test *tst, struct iwl_trans *trans,
 		   struct iwl_test_ops *ops)
 {
 	tst->trans = trans;
@@ -169,17 +169,17 @@ void iwl_test_init(struct iwl_test *tst, struct iwl_trans *trans,
 	iwl_test_trace_clear(tst);
 	iwl_test_mem_clear(tst);
 }
-EXPORT_SYMBOL_GPL(iwl_test_init);
+EXPORT_SYMBOL_GPL(iwl_test_init_dup);
 
 /*
  * Stop the test object
  */
-void iwl_test_free(struct iwl_test *tst)
+void iwl_test_free_dup(struct iwl_test *tst)
 {
 	iwl_test_mem_stop(tst);
 	iwl_test_trace_stop(tst);
 }
-EXPORT_SYMBOL_GPL(iwl_test_free);
+EXPORT_SYMBOL_GPL(iwl_test_free_dup);
 
 static inline int iwl_test_send_cmd(struct iwl_test *tst,
 				    struct iwl_host_cmd *cmd)
@@ -329,7 +329,7 @@ static int iwl_test_reg(struct iwl_test *tst, struct nlattr **tb)
 
 	switch (cmd) {
 	case IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32:
-		val32 = iwl_read_direct32(tst->trans, ofs);
+		val32 = iwl_read_direct32_dup(tst->trans, ofs);
 		IWL_DEBUG_INFO(trans, "32 value to read 0x%x\n", val32);
 
 		skb = iwl_test_alloc_reply(tst, 20);
@@ -351,7 +351,7 @@ static int iwl_test_reg(struct iwl_test *tst, struct nlattr **tb)
 		} else {
 			val32 = nla_get_u32(tb[IWL_TM_ATTR_REG_VALUE32]);
 			IWL_DEBUG_INFO(trans, "32b write val=0x%x\n", val32);
-			iwl_write_direct32(tst->trans, ofs, val32);
+			iwl_write_direct32_dup(tst->trans, ofs, val32);
 		}
 		break;
 
@@ -514,7 +514,7 @@ static int iwl_test_indirect_write(struct iwl_test *tst, u32 addr,
 			if (size % 4)
 				return -EINVAL;
 			for (i = 0; i < size; i += 4)
-				iwl_write_prph(trans, addr+i,
+				iwl_write_prph_dup(trans, addr+i,
 					       *(u32 *)(buf+i));
 		}
 	} else if (iwl_test_valid_hw_addr(tst, addr)) {
@@ -634,7 +634,7 @@ nla_put_failure:
 /*
  * Parse the netlink message and validate that the IWL_TM_ATTR_CMD exists
  */
-int iwl_test_parse(struct iwl_test *tst, struct nlattr **tb,
+int iwl_test_parse_dup(struct iwl_test *tst, struct nlattr **tb,
 		   void *data, int len)
 {
 	int result;
@@ -653,14 +653,14 @@ int iwl_test_parse(struct iwl_test *tst, struct nlattr **tb,
 	}
 	return 0;
 }
-IWL_EXPORT_SYMBOL(iwl_test_parse);
+IWL_EXPORT_SYMBOL(iwl_test_parse_dup);
 
 /*
  * Handle test commands.
  * Returns 1 for unknown commands (not handled by the test object); negative
  * value in case of error.
  */
-int iwl_test_handle_cmd(struct iwl_test *tst, struct nlattr **tb)
+int iwl_test_handle_cmd_dup(struct iwl_test *tst, struct nlattr **tb)
 {
 	int result;
 
@@ -715,7 +715,7 @@ int iwl_test_handle_cmd(struct iwl_test *tst, struct nlattr **tb)
 	}
 	return result;
 }
-IWL_EXPORT_SYMBOL(iwl_test_handle_cmd);
+IWL_EXPORT_SYMBOL(iwl_test_handle_cmd_dup);
 
 static int iwl_test_trace_dump(struct iwl_test *tst, struct sk_buff *skb,
 			       struct netlink_callback *cb)
@@ -781,7 +781,7 @@ static int iwl_test_buffer_dump(struct iwl_test *tst, struct sk_buff *skb,
  * Returns 1 for unknown commands (not handled by the test object); negative
  * value in case of error.
  */
-int iwl_test_dump(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
+int iwl_test_dump_dup(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
 		  struct netlink_callback *cb)
 {
 	int result;
@@ -803,7 +803,7 @@ int iwl_test_dump(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
 	}
 	return result;
 }
-IWL_EXPORT_SYMBOL(iwl_test_dump);
+IWL_EXPORT_SYMBOL(iwl_test_dump_dup);
 
 /*
  * Multicast a spontaneous messages from the device to the user space.
@@ -844,9 +844,9 @@ nla_put_failure:
  * Called whenever a Rx frames is recevied from the device. If notifications to
  * the user space are requested, sends the frames to the user.
  */
-void iwl_test_rx(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb)
+void iwl_test_rx_dup(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb)
 {
 	if (tst->notify)
 		iwl_test_send_rx(tst, rxb);
 }
-IWL_EXPORT_SYMBOL(iwl_test_rx);
+IWL_EXPORT_SYMBOL(iwl_test_rx_dup);
--- a/drivers/net/wireless/iwlwifi/iwl-test.h
+++ b/drivers/net/wireless/iwlwifi/iwl-test.h
@@ -137,20 +137,20 @@ struct iwl_test {
 	bool notify;
 };
 
-void iwl_test_init(struct iwl_test *tst, struct iwl_trans *trans,
+void iwl_test_init_dup(struct iwl_test *tst, struct iwl_trans *trans,
 		   struct iwl_test_ops *ops);
 
-void iwl_test_free(struct iwl_test *tst);
+void iwl_test_free_dup(struct iwl_test *tst);
 
-int iwl_test_parse(struct iwl_test *tst, struct nlattr **tb,
+int iwl_test_parse_dup(struct iwl_test *tst, struct nlattr **tb,
 		   void *data, int len);
 
-int iwl_test_handle_cmd(struct iwl_test *tst, struct nlattr **tb);
+int iwl_test_handle_cmd_dup(struct iwl_test *tst, struct nlattr **tb);
 
-int iwl_test_dump(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
+int iwl_test_dump_dup(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
 		  struct netlink_callback *cb);
 
-void iwl_test_rx(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb);
+void iwl_test_rx_dup(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb);
 
 static inline void iwl_test_enable_notifications(struct iwl_test *tst,
 						 bool enable)
--- a/drivers/net/wireless/iwlwifi/mvm/binding.c
+++ b/drivers/net/wireless/iwlwifi/mvm/binding.c
@@ -148,7 +148,7 @@ static int iwl_mvm_binding_update(struct iwl_mvm *mvm,
 
 	lockdep_assert_held(&mvm->mutex);
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_iface_iterator,
 						   &data);
--- a/drivers/net/wireless/iwlwifi/mvm/coex.c
+++ b/drivers/net/wireless/iwlwifi/mvm/coex.c
@@ -444,7 +444,7 @@ int iwl_send_bt_init_conf(struct iwl_mvm *mvm)
 		goto send_cmd;
 	}
 
-	mode = iwlwifi_mod_params.bt_coex_active ? BT_COEX_NW : BT_COEX_DISABLE;
+	mode = iwlwifi_mod_params_dup.bt_coex_active ? BT_COEX_NW : BT_COEX_DISABLE;
 	bt_cmd->mode = cpu_to_le32(mode);
 
 	if (IWL_MVM_BT_COEX_SYNC2SCO)
@@ -678,7 +678,7 @@ static void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)
 		return;
 
 	rcu_read_lock();
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_bt_notif_iterator, &data);
 
@@ -854,7 +854,7 @@ void iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	if (ret)
 		IWL_ERR(mvm, "couldn't send BT_CONFIG HCMD upon RSSI event\n");
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_bt_rssi_iterator, &data);
 }
--- a/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c
+++ b/drivers/net/wireless/iwlwifi/mvm/coex_legacy.c
@@ -647,13 +647,13 @@ int iwl_send_bt_init_conf_old(struct iwl_mvm *mvm)
 	bt_cmd->max_kill = 5;
 	bt_cmd->bt4_antenna_isolation_thr =
 		IWL_MVM_BT_COEX_ANTENNA_COUPLING_THRS;
-	bt_cmd->bt4_antenna_isolation = iwlwifi_mod_params.ant_coupling;
+	bt_cmd->bt4_antenna_isolation = iwlwifi_mod_params_dup.ant_coupling;
 	bt_cmd->bt4_tx_tx_delta_freq_thr = 15;
 	bt_cmd->bt4_tx_rx_max_freq0 = 15;
 	bt_cmd->override_primary_lut = BT_COEX_INVALID_LUT;
 	bt_cmd->override_secondary_lut = BT_COEX_INVALID_LUT;
 
-	flags = iwlwifi_mod_params.bt_coex_active ?
+	flags = iwlwifi_mod_params_dup.bt_coex_active ?
 			BT_COEX_NW_OLD : BT_COEX_DISABLE_OLD;
 	bt_cmd->flags = cpu_to_le32(flags);
 
@@ -990,7 +990,7 @@ static void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)
 		return;
 
 	rcu_read_lock();
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_bt_notif_iterator, &data);
 
@@ -1170,7 +1170,7 @@ void iwl_mvm_bt_rssi_event_old(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	if (ret)
 		IWL_ERR(mvm, "couldn't send BT_CONFIG HCMD upon RSSI event\n");
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_bt_rssi_iterator, &data);
 
--- a/drivers/net/wireless/iwlwifi/mvm/d3.c
+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c
@@ -81,7 +81,7 @@ void iwl_mvm_set_rekey_data(struct ieee80211_hw *hw,
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 
-	if (iwlwifi_mod_params.sw_crypto)
+	if (iwlwifi_mod_params_dup.sw_crypto)
 		return;
 
 	mutex_lock(&mvm->mutex);
@@ -230,11 +230,11 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 
 			rx_p1ks = data->tkip->rx_uni;
 
-			ieee80211_get_key_tx_seq(key, &seq);
+			ieee80211_get_key_tx_seq_dup(key, &seq);
 			tkip_tx_sc->iv16 = cpu_to_le16(seq.tkip.iv16);
 			tkip_tx_sc->iv32 = cpu_to_le32(seq.tkip.iv32);
 
-			ieee80211_get_tkip_p1k_iv(key, seq.tkip.iv32, p1k);
+			ieee80211_get_tkip_p1k_iv_dup(key, seq.tkip.iv32, p1k);
 			iwl_mvm_convert_p1k(p1k, data->tkip->tx.p1k);
 
 			memcpy(data->tkip->mic_keys.tx,
@@ -255,7 +255,7 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 		 * for checking the IV in the frames.
 		 */
 		for (i = 0; i < IWL_NUM_RSC; i++) {
-			ieee80211_get_key_rx_seq(key, i, &seq);
+			ieee80211_get_key_rx_seq_dup(key, i, &seq);
 			tkip_sc[i].iv16 = cpu_to_le16(seq.tkip.iv16);
 			tkip_sc[i].iv32 = cpu_to_le32(seq.tkip.iv32);
 			/* wrapping isn't allowed, AP must rekey */
@@ -263,10 +263,10 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 				cur_rx_iv32 = seq.tkip.iv32;
 		}
 
-		ieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,
+		ieee80211_get_tkip_rx_p1k_dup(key, vif->bss_conf.bssid,
 					  cur_rx_iv32, p1k);
 		iwl_mvm_convert_p1k(p1k, rx_p1ks[0].p1k);
-		ieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,
+		ieee80211_get_tkip_rx_p1k_dup(key, vif->bss_conf.bssid,
 					  cur_rx_iv32 + 1, p1k);
 		iwl_mvm_convert_p1k(p1k, rx_p1ks[1].p1k);
 
@@ -284,7 +284,7 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 			aes_sc = data->rsc_tsc->all_tsc_rsc.aes.unicast_rsc;
 			aes_tx_sc = &data->rsc_tsc->all_tsc_rsc.aes.tsc;
 
-			ieee80211_get_key_tx_seq(key, &seq);
+			ieee80211_get_key_tx_seq_dup(key, &seq);
 			aes_tx_sc->pn = cpu_to_le64((u64)pn[5] |
 						    ((u64)pn[4] << 8) |
 						    ((u64)pn[3] << 16) |
@@ -302,7 +302,7 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 		for (i = 0; i < IWL_NUM_RSC; i++) {
 			u8 *pn = seq.ccmp.pn;
 
-			ieee80211_get_key_rx_seq(key, i, &seq);
+			ieee80211_get_key_rx_seq_dup(key, i, &seq);
 			aes_sc->pn = cpu_to_le64((u64)pn[5] |
 						 ((u64)pn[4] << 8) |
 						 ((u64)pn[3] << 16) |
@@ -884,14 +884,14 @@ iwl_mvm_wowlan_config(struct iwl_mvm *mvm,
 	if (!key_data.rsc_tsc)
 		return -ENOMEM;
 
-	if (!iwlwifi_mod_params.sw_crypto) {
+	if (!iwlwifi_mod_params_dup.sw_crypto) {
 		/*
 		 * This needs to be unlocked due to lock ordering
 		 * constraints. Since we're in the suspend path
 		 * that isn't really a problem though.
 		 */
 		mutex_unlock(&mvm->mutex);
-		ieee80211_iter_keys(mvm->hw, vif,
+		ieee80211_iter_keys_dup(mvm->hw, vif,
 				    iwl_mvm_wowlan_program_keys,
 				    &key_data);
 		mutex_lock(&mvm->mutex);
@@ -1137,7 +1137,7 @@ static int __iwl_mvm_suspend(struct ieee80211_hw *hw,
  out:
 	if (ret < 0) {
 		iwl_mvm_ref(mvm, IWL_MVM_REF_UCODE_DOWN);
-		ieee80211_restart_hw(mvm->hw);
+		ieee80211_restart_hw_dup(mvm->hw);
 		iwl_mvm_free_nd(mvm);
 	}
  out_noreset:
@@ -1152,7 +1152,7 @@ static int iwl_mvm_enter_d0i3_sync(struct iwl_mvm *mvm)
 	static const u8 d3_notif[] = { D3_CONFIG_CMD };
 	int ret;
 
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_d3,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_d3,
 				   d3_notif, ARRAY_SIZE(d3_notif),
 				   NULL, NULL);
 
@@ -1160,12 +1160,12 @@ static int iwl_mvm_enter_d0i3_sync(struct iwl_mvm *mvm)
 	if (ret)
 		goto remove_notif;
 
-	ret = iwl_wait_notification(&mvm->notif_wait, &wait_d3, HZ);
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &wait_d3, HZ);
 	WARN_ON_ONCE(ret);
 	return ret;
 
 remove_notif:
-	iwl_remove_notification(&mvm->notif_wait, &wait_d3);
+	iwl_remove_notification_dup(&mvm->notif_wait, &wait_d3);
 	return ret;
 }
 
@@ -1262,7 +1262,7 @@ static void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,
 			truncated = 0;
 
 		if (ieee80211_is_data(hdr->frame_control)) {
-			int hdrlen = ieee80211_hdrlen(hdr->frame_control);
+			int hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 			int ivlen = 0, icvlen = 4; /* also FCS */
 
 			pkt = alloc_skb(pktsize, GFP_KERNEL);
@@ -1303,7 +1303,7 @@ static void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,
 
 			memcpy(skb_put(pkt, pktsize), pktdata, pktsize);
 
-			if (ieee80211_data_to_8023(pkt, vif->addr, vif->type))
+			if (ieee80211_data_to_8023_dup(pkt, vif->addr, vif->type))
 				goto report;
 			wakeup.packet = pkt->data;
 			wakeup.packet_present_len = pkt->len;
@@ -1328,7 +1328,7 @@ static void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,
 	}
 
  report:
-	ieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);
+	ieee80211_report_wowlan_wakeup_dup(vif, wakeup_report, GFP_KERNEL);
 	kfree_skb(pkt);
 }
 
@@ -1364,7 +1364,7 @@ static void iwl_mvm_set_aes_rx_seq(struct aes_sc *scs,
 		struct ieee80211_key_seq seq = {};
 
 		iwl_mvm_aes_sc_to_seq(&scs[tid], &seq);
-		ieee80211_set_key_rx_seq(key, tid, &seq);
+		ieee80211_set_key_rx_seq_dup(key, tid, &seq);
 	}
 }
 
@@ -1379,7 +1379,7 @@ static void iwl_mvm_set_tkip_rx_seq(struct tkip_sc *scs,
 		struct ieee80211_key_seq seq = {};
 
 		iwl_mvm_tkip_sc_to_seq(&scs[tid], &seq);
-		ieee80211_set_key_rx_seq(key, tid, &seq);
+		ieee80211_set_key_rx_seq_dup(key, tid, &seq);
 	}
 }
 
@@ -1457,7 +1457,7 @@ static void iwl_mvm_d3_update_gtks(struct ieee80211_hw *hw,
 			iwl_mvm_set_tkip_rx_seq(sc->tkip.unicast_rsc, key);
 			break;
 		}
-		ieee80211_set_key_tx_seq(key, &seq);
+		ieee80211_set_key_tx_seq_dup(key, &seq);
 
 		/* that's it for this key */
 		return;
@@ -1470,7 +1470,7 @@ static void iwl_mvm_d3_update_gtks(struct ieee80211_hw *hw,
 	}
 
 	if (data->status->num_of_gtk_rekeys)
-		ieee80211_remove_key(key);
+		ieee80211_remove_key_dup(key);
 	else if (data->last_gtk == key)
 		iwl_mvm_set_key_rx_seq(key, data->status);
 }
@@ -1495,7 +1495,7 @@ static bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,
 
 	/* find last GTK that we used initially, if any */
 	gtkdata.find_phase = true;
-	ieee80211_iter_keys(mvm->hw, vif,
+	ieee80211_iter_keys_dup(mvm->hw, vif,
 			    iwl_mvm_d3_update_gtks, &gtkdata);
 	/* not trying to keep connections with MFP/unhandled ciphers */
 	if (gtkdata.unhandled_cipher)
@@ -1510,7 +1510,7 @@ static bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,
 	 * the one that we used
 	 */
 	gtkdata.find_phase = false;
-	ieee80211_iter_keys(mvm->hw, vif,
+	ieee80211_iter_keys_dup(mvm->hw, vif,
 			    iwl_mvm_d3_update_gtks, &gtkdata);
 
 	if (status->num_of_gtk_rekeys) {
@@ -1539,7 +1539,7 @@ static bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,
 			break;
 		}
 
-		key = ieee80211_gtk_rekey_add(vif, &conf.conf);
+		key = ieee80211_gtk_rekey_add_dup(vif, &conf.conf);
 		if (IS_ERR(key))
 			return false;
 		iwl_mvm_set_key_rx_seq(key, status);
@@ -1548,7 +1548,7 @@ static bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,
 	if (status->num_of_gtk_rekeys) {
 		__be64 replay_ctr =
 			cpu_to_be64(le64_to_cpu(status->replay_ctr));
-		ieee80211_gtk_rekey_notify(vif, vif->bss_conf.bssid,
+		ieee80211_gtk_rekey_notify_dup(vif, vif->bss_conf.bssid,
 					   (void *)&replay_ctr, GFP_KERNEL);
 	}
 
@@ -1586,7 +1586,7 @@ iwl_mvm_get_wakeup_status(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 			struct cfg80211_wowlan_wakeup wakeup = {
 				.rfkill_release = true,
 			};
-			ieee80211_report_wowlan_wakeup(vif, &wakeup,
+			ieee80211_report_wowlan_wakeup_dup(vif, &wakeup,
 						       GFP_KERNEL);
 		}
 		return ERR_PTR(-EIO);
@@ -1823,7 +1823,7 @@ out:
 	iwl_mvm_free_nd(mvm);
 
 	mutex_unlock(&mvm->mutex);
-	ieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);
+	ieee80211_report_wowlan_wakeup_dup(vif, wakeup_report, GFP_KERNEL);
 
 	if (net_detect) {
 		for (i = 0; i < net_detect->n_matches; i++)
@@ -1860,7 +1860,7 @@ static void iwl_mvm_d3_disconnect_iter(void *data, u8 *mac,
 		return;
 
 	if (vif->type == NL80211_IFTYPE_STATION)
-		ieee80211_resume_disconnect(vif);
+		ieee80211_resume_disconnect_dup(vif);
 }
 
 static int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)
@@ -1915,7 +1915,7 @@ err:
 
 out_iterate:
 	if (!test)
-		ieee80211_iterate_active_interfaces_rtnl(mvm->hw,
+		ieee80211_iterate_active_interfaces_rtnl_dup(mvm->hw,
 			IEEE80211_IFACE_ITER_NORMAL,
 			iwl_mvm_d3_disconnect_iter, keep ? vif : NULL);
 
@@ -1986,7 +1986,7 @@ static int iwl_mvm_d3_test_open(struct inode *inode, struct file *file)
 	if (err > 0)
 		err = -EINVAL;
 	if (err) {
-		ieee80211_wake_queues(mvm->hw);
+		ieee80211_wake_queues_dup(mvm->hw);
 		return err;
 	}
 	mvm->d3_test_active = true;
@@ -2024,7 +2024,7 @@ static void iwl_mvm_d3_test_disconn_work_iter(void *_data, u8 *mac,
 		return;
 
 	if (vif->type == NL80211_IFTYPE_STATION)
-		ieee80211_connection_loss(vif);
+		ieee80211_connection_loss_dup(vif);
 }
 
 static int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)
@@ -2036,8 +2036,8 @@ static int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)
 	rtnl_lock();
 	__iwl_mvm_resume(mvm, true);
 	rtnl_unlock();
-	iwl_abort_notification_waits(&mvm->notif_wait);
-	ieee80211_restart_hw(mvm->hw);
+	iwl_abort_notification_waits_dup(&mvm->notif_wait);
+	ieee80211_restart_hw_dup(mvm->hw);
 
 	/* wait for restart and disconnect all interfaces */
 	while (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&
@@ -2049,11 +2049,11 @@ static int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)
 	if (remaining_time == 0)
 		IWL_ERR(mvm, "Timed out waiting for HW restart to finish!\n");
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_d3_test_disconn_work_iter, mvm->keep_vif);
 
-	ieee80211_wake_queues(mvm->hw);
+	ieee80211_wake_queues_dup(mvm->hw);
 
 	return 0;
 }
--- a/drivers/net/wireless/iwlwifi/mvm/debugfs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.c
@@ -871,7 +871,7 @@ static ssize_t iwl_dbgfs_fw_nmi_write(struct iwl_mvm *mvm, char *buf,
 	if (ret)
 		return ret;
 
-	iwl_force_nmi(mvm->trans);
+	iwl_force_nmi_dup(mvm->trans);
 
 	iwl_mvm_unref(mvm, IWL_MVM_REF_NMI);
 
@@ -1438,7 +1438,7 @@ iwl_dbgfs_prph_reg_read(struct file *file,
 
 	pos += scnprintf(buf + pos, bufsz - pos, "Reg 0x%x: (0x%x)\n",
 		mvm->dbgfs_prph_reg_addr,
-		iwl_read_prph(mvm->trans, mvm->dbgfs_prph_reg_addr));
+		iwl_read_prph_dup(mvm->trans, mvm->dbgfs_prph_reg_addr));
 
 	iwl_mvm_unref(mvm, IWL_MVM_REF_PRPH_READ);
 
@@ -1466,7 +1466,7 @@ iwl_dbgfs_prph_reg_write(struct iwl_mvm *mvm, char *buf,
 	if (ret)
 		return ret;
 
-	iwl_write_prph(mvm->trans, mvm->dbgfs_prph_reg_addr, value);
+	iwl_write_prph_dup(mvm->trans, mvm->dbgfs_prph_reg_addr, value);
 
 	iwl_mvm_unref(mvm, IWL_MVM_REF_PRPH_WRITE);
 out:
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h
@@ -269,8 +269,8 @@ enum {
 #define RATE_MCS_ZLF_MSK		(1 << RATE_MCS_ZLF_POS)
 
 /* Bit 24-25: (0) 20MHz (no dup), (1) 2x20MHz, (2) 4x20MHz, 3 8x20MHz */
-#define RATE_MCS_DUP_POS		24
-#define RATE_MCS_DUP_MSK		(3 << RATE_MCS_DUP_POS)
+#define RATE_MCS_POS		24
+#define RATE_MCS_MSK		(3 << RATE_MCS_POS)
 
 /* Bit 27: (1) LDPC enabled, (0) LDPC disabled */
 #define RATE_MCS_LDPC_POS		27
--- a/drivers/net/wireless/iwlwifi/mvm/fw.c
+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c
@@ -200,7 +200,7 @@ static bool iwl_wait_phy_db_entry(struct iwl_notif_wait_data *notif_wait,
 		return true;
 	}
 
-	WARN_ON(iwl_phy_db_set_section(phy_db, pkt, GFP_ATOMIC));
+	WARN_ON(iwl_phy_db_set_section_dup(phy_db, pkt, GFP_ATOMIC));
 
 	return false;
 }
@@ -226,14 +226,14 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
 	mvm->cur_ucode = ucode_type;
 	mvm->ucode_loaded = false;
 
-	iwl_init_notification_wait(&mvm->notif_wait, &alive_wait,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &alive_wait,
 				   alive_cmd, ARRAY_SIZE(alive_cmd),
 				   iwl_alive_fn, &alive_data);
 
 	ret = iwl_trans_start_fw(mvm->trans, fw, ucode_type == IWL_UCODE_INIT);
 	if (ret) {
 		mvm->cur_ucode = old_type;
-		iwl_remove_notification(&mvm->notif_wait, &alive_wait);
+		iwl_remove_notification_dup(&mvm->notif_wait, &alive_wait);
 		return ret;
 	}
 
@@ -241,7 +241,7 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
 	 * Some things may run in the background now, but we
 	 * just wait for the ALIVE notification here.
 	 */
-	ret = iwl_wait_notification(&mvm->notif_wait, &alive_wait,
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &alive_wait,
 				    MVM_UCODE_ALIVE_TIMEOUT);
 	if (ret) {
 		mvm->cur_ucode = old_type;
@@ -325,7 +325,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	if (WARN_ON_ONCE(mvm->calibrating))
 		return 0;
 
-	iwl_init_notification_wait(&mvm->notif_wait,
+	iwl_init_notification_wait_dup(&mvm->notif_wait,
 				   &calib_wait,
 				   init_complete,
 				   ARRAY_SIZE(init_complete),
@@ -357,7 +357,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	if (mvm->nvm_file_name)
 		iwl_mvm_load_nvm_to_nic(mvm);
 
-	ret = iwl_nvm_check_version(mvm->nvm_data, mvm->trans);
+	ret = iwl_nvm_check_version_dup(mvm->nvm_data, mvm->trans);
 	WARN_ON(ret);
 
 	/*
@@ -367,7 +367,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	if (iwl_mvm_is_radio_killed(mvm)) {
 		IWL_DEBUG_RF_KILL(mvm,
 				  "jump over all phy activities due to RF kill\n");
-		iwl_remove_notification(&mvm->notif_wait, &calib_wait);
+		iwl_remove_notification_dup(&mvm->notif_wait, &calib_wait);
 		ret = 1;
 		goto out;
 	}
@@ -394,7 +394,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	 * Some things may run in the background now, but we
 	 * just wait for the calibration complete notification.
 	 */
-	ret = iwl_wait_notification(&mvm->notif_wait, &calib_wait,
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &calib_wait,
 			MVM_UCODE_CALIB_TIMEOUT);
 
 	if (ret && iwl_mvm_is_radio_killed(mvm)) {
@@ -404,7 +404,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 	goto out;
 
 error:
-	iwl_remove_notification(&mvm->notif_wait, &calib_wait);
+	iwl_remove_notification_dup(&mvm->notif_wait, &calib_wait);
 out:
 	mvm->calibrating = false;
 	if (iwlmvm_mod_params.init_dbg && !mvm->nvm_data) {
@@ -553,9 +553,9 @@ int iwl_mvm_fw_dbg_collect_trig(struct iwl_mvm *mvm,
 static inline void iwl_mvm_restart_early_start(struct iwl_mvm *mvm)
 {
 	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_7000)
-		iwl_clear_bits_prph(mvm->trans, MON_BUFF_SAMPLE_CTL, 0x100);
+		iwl_clear_bits_prph_dup(mvm->trans, MON_BUFF_SAMPLE_CTL, 0x100);
 	else
-		iwl_write_prph(mvm->trans, DBGC_IN_SAMPLE, 1);
+		iwl_write_prph_dup(mvm->trans, DBGC_IN_SAMPLE, 1);
 }
 
 int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm, u8 conf_id)
@@ -698,7 +698,7 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
 		goto error;
 
 	/* Send phy db control command and then phy db calibration*/
-	ret = iwl_send_phy_db_data(mvm->phy_db);
+	ret = iwl_send_phy_db_data_dup(mvm->phy_db);
 	if (ret)
 		goto error;
 
@@ -722,7 +722,7 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
 
 	/* Add all the PHY contexts */
 	chan = &mvm->hw->wiphy->bands[IEEE80211_BAND_2GHZ]->channels[0];
-	cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);
+	cfg80211_chandef_create_dup(&chandef, chan, NL80211_CHAN_NO_HT);
 	for (i = 0; i < NUM_PHY_CTX; i++) {
 		/*
 		 * The channel used here isn't relevant as it's
@@ -792,7 +792,7 @@ int iwl_mvm_load_d3_fw(struct iwl_mvm *mvm)
 		goto error;
 
 	/* Send phy db control command and then phy db calibration*/
-	ret = iwl_send_phy_db_data(mvm->phy_db);
+	ret = iwl_send_phy_db_data_dup(mvm->phy_db);
 	if (ret)
 		goto error;
 
--- a/drivers/net/wireless/iwlwifi/mvm/led.c
+++ b/drivers/net/wireless/iwlwifi/mvm/led.c
@@ -90,7 +90,7 @@ static void iwl_led_brightness_set(struct led_classdev *led_cdev,
 
 int iwl_mvm_leds_init(struct iwl_mvm *mvm)
 {
-	int mode = iwlwifi_mod_params.led_mode;
+	int mode = iwlwifi_mod_params_dup.led_mode;
 	int ret;
 
 	switch (mode) {
@@ -128,7 +128,7 @@ int iwl_mvm_leds_init(struct iwl_mvm *mvm)
 
 void iwl_mvm_leds_exit(struct iwl_mvm *mvm)
 {
-	if (iwlwifi_mod_params.led_mode == IWL_LED_DISABLE)
+	if (iwlwifi_mod_params_dup.led_mode == IWL_LED_DISABLE)
 		return;
 
 	led_classdev_unregister(&mvm->led);
--- a/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
@@ -256,12 +256,12 @@ unsigned long iwl_mvm_get_used_hw_queues(struct iwl_mvm *mvm,
 	lockdep_assert_held(&mvm->mutex);
 
 	/* mark all VIF used hw queues */
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 		iwl_mvm_iface_hw_queues_iter, &data);
 
 	/* don't assign the same hw queues as TDLS stations */
-	ieee80211_iterate_stations_atomic(mvm->hw,
+	ieee80211_iterate_stations_atomic_dup(mvm->hw,
 					  iwl_mvm_mac_sta_hw_queues_iter,
 					  &data);
 
@@ -311,7 +311,7 @@ void iwl_mvm_mac_ctxt_recalc_tsf_id(struct iwl_mvm *mvm,
 		.preferred_tsf = NUM_TSF_IDS,
 	};
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 		iwl_mvm_mac_tsf_id_iter, &data);
 
@@ -367,7 +367,7 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
 		__clear_bit(0, data.available_mac_ids);
 	}
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 		iwl_mvm_mac_iface_iterator, &data);
 
@@ -920,7 +920,7 @@ static int iwl_mvm_mac_ctxt_cmd_p2p_device(struct iwl_mvm *mvm,
 	 * Note that this flag should not be set in other cases as it opens the
 	 * Rx filters on all MAC and increases the number of interrupts.
 	 */
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 		iwl_mvm_go_iterator, &data);
 
@@ -1031,7 +1031,7 @@ int iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,
 	WARN_ON(vif->type != NL80211_IFTYPE_AP &&
 		vif->type != NL80211_IFTYPE_ADHOC);
 
-	beacon = ieee80211_beacon_get_template(mvm->hw, vif, NULL);
+	beacon = ieee80211_beacon_get_template_dup(mvm->hw, vif, NULL);
 	if (!beacon)
 		return -ENOMEM;
 
@@ -1101,7 +1101,7 @@ static void iwl_mvm_mac_ctxt_cmd_fill_ap(struct iwl_mvm *mvm,
 		 * associated, set the AP's TBTT far enough from the station's
 		 * TBTT. Otherwise, set it to the current system time
 		 */
-		ieee80211_iterate_active_interfaces_atomic(
+		ieee80211_iterate_active_interfaces_atomic_dup(
 			mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 			iwl_mvm_mac_ap_iterator, &data);
 
@@ -1116,7 +1116,7 @@ static void iwl_mvm_mac_ctxt_cmd_fill_ap(struct iwl_mvm *mvm,
 						     100);
 		} else {
 			mvmvif->ap_beacon_time =
-				iwl_read_prph(mvm->trans,
+				iwl_read_prph_dup(mvm->trans,
 					      DEVICE_SYSTEM_TIME_REG);
 		}
 	}
@@ -1292,8 +1292,8 @@ static void iwl_mvm_csa_count_down(struct iwl_mvm *mvm,
 
 	mvmvif->csa_countdown = true;
 
-	if (!ieee80211_csa_is_complete(csa_vif)) {
-		int c = ieee80211_csa_update_counter(csa_vif);
+	if (!ieee80211_csa_is_complete_dup(csa_vif)) {
+		int c = ieee80211_csa_update_counter_dup(csa_vif);
 
 		iwl_mvm_mac_ctxt_beacon_changed(mvm, csa_vif);
 		if (csa_vif->p2p &&
@@ -1311,7 +1311,7 @@ static void iwl_mvm_csa_count_down(struct iwl_mvm *mvm,
 		}
 	} else if (!iwl_mvm_te_scheduled(&mvmvif->time_event_data)) {
 		/* we don't have CSA NoA scheduled yet, switch now */
-		ieee80211_csa_finish(csa_vif);
+		ieee80211_csa_finish_dup(csa_vif);
 		RCU_INIT_POINTER(mvm->csa_vif, NULL);
 	}
 }
@@ -1396,7 +1396,7 @@ static void iwl_mvm_beacon_loss_iterator(void *_data, u8 *mac,
 	 */
 	if (le32_to_cpu(missed_beacons->consec_missed_beacons_since_last_rx) >
 	     IWL_MVM_MISSED_BEACONS_THRESHOLD)
-		ieee80211_beacon_loss(vif);
+		ieee80211_beacon_loss_dup(vif);
 
 	if (!iwl_fw_dbg_trigger_enabled(mvm->fw,
 					FW_DBG_TRIGGER_MISSED_BEACONS))
@@ -1434,7 +1434,7 @@ int iwl_mvm_rx_missed_beacons_notif(struct iwl_mvm *mvm,
 		       le32_to_cpu(mb->num_recvd_beacons),
 		       le32_to_cpu(mb->num_expected_beacons));
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_beacon_loss_iterator,
 						   mb);
--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -167,7 +167,7 @@ static const struct iwl_fw_bcast_filter iwl_mvm_default_bcast_filters[] = {
 				/* frame type - arp, hw type - ethernet */
 				.offset_type =
 					BCAST_FILTER_OFFSET_PAYLOAD_START,
-				.offset = sizeof(rfc1042_header),
+				.offset = sizeof(rfc1042_header_dup),
 				.val = cpu_to_be32(0x08060001),
 				.mask = cpu_to_be32(0xffffffff),
 			},
@@ -175,7 +175,7 @@ static const struct iwl_fw_bcast_filter iwl_mvm_default_bcast_filters[] = {
 				/* arp dest ip */
 				.offset_type =
 					BCAST_FILTER_OFFSET_PAYLOAD_START,
-				.offset = sizeof(rfc1042_header) + 2 +
+				.offset = sizeof(rfc1042_header_dup) + 2 +
 					  sizeof(struct arphdr) +
 					  ETH_ALEN + sizeof(__be32) +
 					  ETH_ALEN,
@@ -310,7 +310,7 @@ struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
 						  bool *changed)
 {
 	struct ieee80211_regdomain *regd = NULL;
-	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw_dup(wiphy);
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 	struct iwl_mcc_update_resp *resp;
 
@@ -328,7 +328,7 @@ struct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,
 	if (changed)
 		*changed = (resp->status == MCC_RESP_NEW_CHAN_PROFILE);
 
-	regd = iwl_parse_nvm_mcc_info(mvm->trans->dev, mvm->cfg,
+	regd = iwl_parse_nvm_mcc_info_dup(mvm->trans->dev, mvm->cfg,
 				      __le32_to_cpu(resp->n_channels),
 				      resp->channels,
 				      __le16_to_cpu(resp->mcc));
@@ -444,7 +444,7 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 	 * packets, so enabling it with software crypto isn't safe)
 	 */
 	if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_MFP &&
-	    !iwlwifi_mod_params.sw_crypto)
+	    !iwlwifi_mod_params_dup.sw_crypto)
 		hw->flags |= IEEE80211_HW_MFP_CAPABLE;
 
 	hw->flags |= IEEE80211_SINGLE_HW_SCAN_ON_ALL_BANDS;
@@ -587,7 +587,7 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 				     WIPHY_WOWLAN_EAP_IDENTITY_REQ |
 				     WIPHY_WOWLAN_RFKILL_RELEASE |
 				     WIPHY_WOWLAN_NET_DETECT;
-		if (!iwlwifi_mod_params.sw_crypto)
+		if (!iwlwifi_mod_params_dup.sw_crypto)
 			mvm->wowlan.flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
 					     WIPHY_WOWLAN_GTK_REKEY_FAILURE |
 					     WIPHY_WOWLAN_4WAY_HANDSHAKE;
@@ -621,7 +621,7 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 		hw->wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
 	}
 
-	ret = ieee80211_register_hw(mvm->hw);
+	ret = ieee80211_register_hw_dup(mvm->hw);
 	if (ret)
 		iwl_mvm_leds_exit(mvm);
 
@@ -657,7 +657,7 @@ static bool iwl_mvm_defer_tx(struct iwl_mvm *mvm,
 		goto out;
 
 	__skb_queue_tail(&mvm->d0i3_tx, skb);
-	ieee80211_stop_queues(mvm->hw);
+	ieee80211_stop_queues_dup(mvm->hw);
 
 	/* trigger wakeup */
 	iwl_mvm_ref(mvm, IWL_MVM_REF_TX);
@@ -708,21 +708,21 @@ static void iwl_mvm_mac_tx(struct ieee80211_hw *hw,
 		goto drop;
 	return;
  drop:
-	ieee80211_free_txskb(hw, skb);
+	ieee80211_free_txskb_dup(hw, skb);
 }
 
 static inline bool iwl_enable_rx_ampdu(const struct iwl_cfg *cfg)
 {
-	if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_RXAGG)
+	if (iwlwifi_mod_params_dup.disable_11n & IWL_DISABLE_HT_RXAGG)
 		return false;
 	return true;
 }
 
 static inline bool iwl_enable_tx_ampdu(const struct iwl_cfg *cfg)
 {
-	if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_TXAGG)
+	if (iwlwifi_mod_params_dup.disable_11n & IWL_DISABLE_HT_TXAGG)
 		return false;
-	if (iwlwifi_mod_params.disable_11n & IWL_ENABLE_HT_TXAGG)
+	if (iwlwifi_mod_params_dup.disable_11n & IWL_ENABLE_HT_TXAGG)
 		return true;
 
 	/* enabled by default */
@@ -1235,9 +1235,9 @@ static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
 	mvm->calibrating = false;
 
 	/* just in case one was running */
-	ieee80211_remain_on_channel_expired(mvm->hw);
+	ieee80211_remain_on_channel_expired_dup(mvm->hw);
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 		iwl_mvm_cleanup_iterator, mvm);
 
@@ -1255,7 +1255,7 @@ static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
 	memset(&mvm->bt_ack_kill_msk, 0, sizeof(mvm->bt_ack_kill_msk));
 	memset(&mvm->bt_cts_kill_msk, 0, sizeof(mvm->bt_cts_kill_msk));
 
-	ieee80211_wake_queues(mvm->hw);
+	ieee80211_wake_queues_dup(mvm->hw);
 
 	/* clear any stale d0i3 state */
 	clear_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status);
@@ -1799,7 +1799,7 @@ static void iwl_mvm_recalc_multicast(struct iwl_mvm *mvm)
 	if (WARN_ON_ONCE(!mvm->mcast_filter_cmd))
 		return;
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_mc_iface_iterator, &iter_data);
 }
@@ -2013,7 +2013,7 @@ bool iwl_mvm_bcast_filter_build_cmd(struct iwl_mvm *mvm,
 		return false;
 
 	/* configure and attach these filters for each associated sta vif */
-	ieee80211_iterate_active_interfaces(
+	ieee80211_iterate_active_interfaces_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_bcast_filter_iterator, &iter_data);
 
@@ -2492,7 +2492,7 @@ static void iwl_mvm_mac_cancel_hw_scan(struct ieee80211_hw *hw,
 	/* Due to a race condition, it's possible that mac80211 asks
 	 * us to stop a hw_scan when it's already stopped.  This can
 	 * happen, for instance, if we stopped the scan ourselves,
-	 * called ieee80211_scan_completed() and the userspace called
+	 * called ieee80211_scan_completed_dup() and the userspace called
 	 * cancel scan scan before ieee80211_scan_work() could run.
 	 * To handle that, simply return if the scan is not running.
 	*/
@@ -2565,10 +2565,10 @@ static void iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw,
 	switch (cmd) {
 	case STA_NOTIFY_SLEEP:
 		if (atomic_read(&mvm->pending_frames[mvmsta->sta_id]) > 0)
-			ieee80211_sta_block_awake(hw, sta, true);
+			ieee80211_sta_block_awake_dup(hw, sta, true);
 
 		for_each_set_bit(tid, &tids, IWL_MAX_TID_COUNT)
-			ieee80211_sta_set_buffered(sta, tid, true);
+			ieee80211_sta_set_buffered_dup(sta, tid, true);
 
 		if (txqs)
 			iwl_trans_freeze_txq_timer(mvm->trans, txqs, true);
@@ -2620,7 +2620,7 @@ static void iwl_mvm_check_uapsd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	if (!(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT))
 		return;
 
-	if (iwlwifi_mod_params.uapsd_disable) {
+	if (iwlwifi_mod_params_dup.uapsd_disable) {
 		vif->driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;
 		return;
 	}
@@ -2731,10 +2731,10 @@ static int iwl_mvm_mac_sta_state(struct ieee80211_hw *hw,
 	if (sta->tdls && ret == 0) {
 		if (old_state == IEEE80211_STA_NOTEXIST &&
 		    new_state == IEEE80211_STA_NONE)
-			ieee80211_reserve_tid(sta, IWL_MVM_TDLS_FW_TID);
+			ieee80211_reserve_tid_dup(sta, IWL_MVM_TDLS_FW_TID);
 		else if (old_state == IEEE80211_STA_NONE &&
 			 new_state == IEEE80211_STA_NOTEXIST)
-			ieee80211_unreserve_tid(sta, IWL_MVM_TDLS_FW_TID);
+			ieee80211_unreserve_tid_dup(sta, IWL_MVM_TDLS_FW_TID);
 	}
 
 	return ret;
@@ -2863,7 +2863,7 @@ static int iwl_mvm_mac_sched_scan_stop(struct ieee80211_hw *hw,
 	/* Due to a race condition, it's possible that mac80211 asks
 	 * us to stop a sched_scan when it's already stopped.  This
 	 * can happen, for instance, if we stopped the scan ourselves,
-	 * called ieee80211_sched_scan_stopped() and the userspace called
+	 * called ieee80211_sched_scan_stopped_dup() and the userspace called
 	 * stop sched scan scan before ieee80211_sched_scan_stopped_work()
 	 * could run.  To handle this, simply return if the scan is
 	 * not running.
@@ -2893,7 +2893,7 @@ static int iwl_mvm_mac_set_key(struct ieee80211_hw *hw,
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 	int ret;
 
-	if (iwlwifi_mod_params.sw_crypto) {
+	if (iwlwifi_mod_params_dup.sw_crypto) {
 		IWL_DEBUG_MAC80211(mvm, "leave - hwcrypto disabled\n");
 		return -EOPNOTSUPP;
 	}
@@ -3046,7 +3046,7 @@ static int iwl_mvm_send_aux_roc_cmd(struct iwl_mvm *mvm,
 		.channel_info.channel = channel->hw_value,
 		.channel_info.width = PHY_VHT_CHANNEL_MODE20,
 		/* Set the time and duration */
-		.apply_time = cpu_to_le32(iwl_read_prph(mvm->trans, time_reg)),
+		.apply_time = cpu_to_le32(iwl_read_prph_dup(mvm->trans, time_reg)),
 		.apply_time_max_delay =
 			cpu_to_le32(MSEC_TO_TU(AUX_ROC_MAX_DELAY_ON_CHANNEL)),
 		.duration = cpu_to_le32(MSEC_TO_TU(duration)),
@@ -3079,7 +3079,7 @@ static int iwl_mvm_send_aux_roc_cmd(struct iwl_mvm *mvm,
 	 * time another notification (that the time event started)
 	 * might already be processed unsuccessfully.
 	 */
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_time_event,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_time_event,
 				   time_event_response,
 				   ARRAY_SIZE(time_event_response),
 				   iwl_mvm_rx_aux_roc, te_data);
@@ -3089,12 +3089,12 @@ static int iwl_mvm_send_aux_roc_cmd(struct iwl_mvm *mvm,
 
 	if (res) {
 		IWL_ERR(mvm, "Couldn't send HOT_SPOT_CMD: %d\n", res);
-		iwl_remove_notification(&mvm->notif_wait, &wait_time_event);
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_time_event);
 		goto out_clear_te;
 	}
 
 	/* No need to wait for anything, so just pass 1 (0 isn't valid) */
-	res = iwl_wait_notification(&mvm->notif_wait, &wait_time_event, 1);
+	res = iwl_wait_notification_dup(&mvm->notif_wait, &wait_time_event, 1);
 	/* should never fail */
 	WARN_ON_ONCE(res);
 
@@ -3180,7 +3180,7 @@ static int iwl_mvm_roc(struct ieee80211_hw *hw,
 	if (channel == mvmvif->phy_ctxt->channel)
 		goto schedule_time_event;
 
-	cfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);
+	cfg80211_chandef_create_dup(&chandef, channel, NL80211_CHAN_NO_HT);
 
 	/*
 	 * Change the PHY context configuration as it is currently referenced
@@ -3729,7 +3729,7 @@ static void iwl_mvm_channel_switch(struct ieee80211_hw *hw,
 {
 	/* By implementing this operation, we prevent mac80211 from
 	 * starting its own channel switch timer, so that we can call
-	 * ieee80211_chswitch_done() ourselves at the right time
+	 * ieee80211_chswitch_done_dup() ourselves at the right time
 	 * (which is when the absence time event starts).
 	 */
 
--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h
@@ -912,7 +912,7 @@ static inline bool iwl_mvm_is_d0i3_supported(struct iwl_mvm *mvm)
 {
 	return mvm->trans->cfg->d0i3 &&
 	       mvm->trans->d0i3_mode != IWL_D0I3_MODE_OFF &&
-	       !iwlwifi_mod_params.d0i3_disable &&
+	       !iwlwifi_mod_params_dup.d0i3_disable &&
 	       (mvm->fw->ucode_capa.capa[0] & IWL_UCODE_TLV_CAPA_D0I3_SUPPORT);
 }
 
@@ -923,7 +923,7 @@ static inline bool iwl_mvm_is_lar_supported(struct iwl_mvm *mvm)
 		IWL_UCODE_TLV_CAPA_LAR_SUPPORT;
 
 #if 0 /* Disable LAR feature in RHEL6 */
-	if (iwlwifi_mod_params.lar_disable)
+	if (iwlwifi_mod_params_dup.lar_disable)
 #endif
 		return false;
 
--- a/drivers/net/wireless/iwlwifi/mvm/nvm.c
+++ b/drivers/net/wireless/iwlwifi/mvm/nvm.c
@@ -315,11 +315,11 @@ iwl_parse_nvm_sections(struct iwl_mvm *mvm)
 		(const __le16 *)sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data;
 	phy_sku = (const __le16 *)sections[NVM_SECTION_TYPE_PHY_SKU].data;
 
-	lar_enabled = !iwlwifi_mod_params.lar_disable &&
+	lar_enabled = !iwlwifi_mod_params_dup.lar_disable &&
 		      (mvm->fw->ucode_capa.capa[0] &
 		       IWL_UCODE_TLV_CAPA_LAR_SUPPORT);
 
-	return iwl_parse_nvm_data(mvm->trans->dev, mvm->cfg, hw, sw, calib,
+	return iwl_parse_nvm_data_dup(mvm->trans->dev, mvm->cfg, hw, sw, calib,
 				  regulatory, mac_override, phy_sku,
 				  mvm->fw->valid_tx_ant, mvm->fw->valid_rx_ant,
 				  lar_enabled, mac_addr0, mac_addr1);
--- a/drivers/net/wireless/iwlwifi/mvm/ops.c
+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c
@@ -120,7 +120,7 @@ static int __init iwl_mvm_init(void)
 		return ret;
 	}
 
-	ret = iwl_opmode_register("iwlmvm", &iwl_mvm_ops);
+	ret = iwl_opmode_register_dup("iwlmvm", &iwl_mvm_ops);
 
 	if (ret) {
 		pr_err("Unable to register MVM op_mode: %d\n", ret);
@@ -133,7 +133,7 @@ module_init(iwl_mvm_init);
 
 static void __exit iwl_mvm_exit(void)
 {
-	iwl_opmode_deregister("iwlmvm");
+	iwl_opmode_deregister_dup("iwlmvm");
 	iwl_mvm_rate_control_unregister();
 }
 module_exit(iwl_mvm_exit);
@@ -195,7 +195,7 @@ static void iwl_mvm_nic_config(struct iwl_op_mode *op_mode)
 	 * to lose ownership and not being able to obtain it back.
 	 */
 	if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
-		iwl_set_bits_mask_prph(mvm->trans, APMG_PS_CTRL_REG,
+		iwl_set_bits_mask_prph_dup(mvm->trans, APMG_PS_CTRL_REG,
 				       APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,
 				       ~APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);
 }
@@ -431,7 +431,7 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	mvm->fw = fw;
 	mvm->hw = hw;
 
-	mvm->restart_fw = iwlwifi_mod_params.restart_fw ? -1 : 0;
+	mvm->restart_fw = iwlwifi_mod_params_dup.restart_fw ? -1 : 0;
 
 	mvm->aux_queue = 15;
 	mvm->first_agg_queue = 16;
@@ -454,7 +454,7 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 
 	mvm->workqueue = create_singlethread_workqueue(DRV_NAME);
 	if (!mvm->workqueue) {
-		ieee80211_free_hw(mvm->hw);
+		ieee80211_free_hw_dup(mvm->hw);
 		return NULL;
 	}
 
@@ -479,7 +479,7 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	trans_cfg.op_mode = op_mode;
 	trans_cfg.no_reclaim_cmds = no_reclaim_cmds;
 	trans_cfg.n_no_reclaim_cmds = ARRAY_SIZE(no_reclaim_cmds);
-	trans_cfg.rx_buf_size_8k = iwlwifi_mod_params.amsdu_size_8K;
+	trans_cfg.rx_buf_size_8k = iwlwifi_mod_params_dup.amsdu_size_8K;
 
 	if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_DW_BC_TABLE)
 		trans_cfg.bc_table_dword = true;
@@ -512,10 +512,10 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	trans->dbg_trigger_tlv = mvm->fw->dbg_trigger_tlv;
 
 	/* set up notification wait support */
-	iwl_notification_wait_init(&mvm->notif_wait);
+	iwl_notification_wait_init_dup(&mvm->notif_wait);
 
 	/* Init phy db */
-	mvm->phy_db = iwl_phy_db_init(trans);
+	mvm->phy_db = iwl_phy_db_init_dup(trans);
 	if (!mvm->phy_db) {
 		IWL_ERR(mvm, "Cannot init phy_db\n");
 		goto out_free;
@@ -527,8 +527,8 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	min_backoff = calc_min_backoff(trans, cfg);
 	iwl_mvm_tt_initialize(mvm, min_backoff);
 	/* set the nvm_file_name according to priority */
-	if (iwlwifi_mod_params.nvm_file) {
-		mvm->nvm_file_name = iwlwifi_mod_params.nvm_file;
+	if (iwlwifi_mod_params_dup.nvm_file) {
+		mvm->nvm_file_name = iwlwifi_mod_params_dup.nvm_file;
 	} else if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
 		if (CSR_HW_REV_STEP(trans->hw_rev) == SILICON_B_STEP)
 			mvm->nvm_file_name = mvm->cfg->default_nvm_file_B_step;
@@ -592,15 +592,15 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 	return op_mode;
 
  out_unregister:
-	ieee80211_unregister_hw(mvm->hw);
+	ieee80211_unregister_hw_dup(mvm->hw);
 	iwl_mvm_leds_exit(mvm);
  out_free:
-	iwl_phy_db_free(mvm->phy_db);
+	iwl_phy_db_free_dup(mvm->phy_db);
 	kfree(mvm->scan_cmd);
 	if (!cfg->no_power_up_nic_in_init || !mvm->nvm_file_name)
 		iwl_trans_op_mode_leave(trans);
 	destroy_workqueue(mvm->workqueue);
-	ieee80211_free_hw(mvm->hw);
+	ieee80211_free_hw_dup(mvm->hw);
 	return NULL;
 }
 
@@ -613,7 +613,7 @@ static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)
 
 	iwl_mvm_tt_exit(mvm);
 
-	ieee80211_unregister_hw(mvm->hw);
+	ieee80211_unregister_hw_dup(mvm->hw);
 
 	kfree(mvm->scan_cmd);
 	kfree(mvm->mcast_filter_cmd);
@@ -630,7 +630,7 @@ static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)
 
 	iwl_trans_op_mode_leave(mvm->trans);
 
-	iwl_phy_db_free(mvm->phy_db);
+	iwl_phy_db_free_dup(mvm->phy_db);
 	mvm->phy_db = NULL;
 
 	iwl_free_nvm_data(mvm->nvm_data);
@@ -639,7 +639,7 @@ static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)
 
 	destroy_workqueue(mvm->workqueue);
 
-	ieee80211_free_hw(mvm->hw);
+	ieee80211_free_hw_dup(mvm->hw);
 }
 
 struct iwl_async_handler_entry {
@@ -739,7 +739,7 @@ static int iwl_mvm_rx_dispatch(struct iwl_op_mode *op_mode,
 	 * even if the RX handler consumes the RXB we have
 	 * access to it in the notification wait entry.
 	 */
-	iwl_notification_wait_notify(&mvm->notif_wait, pkt);
+	iwl_notification_wait_notify_dup(&mvm->notif_wait, pkt);
 
 	for (i = 0; i < ARRAY_SIZE(iwl_mvm_rx_handlers); i++) {
 		const struct iwl_rx_handlers *rx_h = &iwl_mvm_rx_handlers[i];
@@ -785,7 +785,7 @@ static void iwl_mvm_stop_sw_queue(struct iwl_op_mode *op_mode, int queue)
 		return;
 	}
 
-	ieee80211_stop_queue(mvm->hw, mq);
+	ieee80211_stop_queue_dup(mvm->hw, mq);
 }
 
 static void iwl_mvm_wake_sw_queue(struct iwl_op_mode *op_mode, int queue)
@@ -803,7 +803,7 @@ static void iwl_mvm_wake_sw_queue(struct iwl_op_mode *op_mode, int queue)
 		return;
 	}
 
-	ieee80211_wake_queue(mvm->hw, mq);
+	ieee80211_wake_queue_dup(mvm->hw, mq);
 }
 
 void iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state)
@@ -813,7 +813,7 @@ void iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state)
 	else
 		clear_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);
 
-	wiphy_rfkill_set_hw_state(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
+	wiphy_rfkill_set_hw_state_dup(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
 }
 
 static bool iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
@@ -826,11 +826,11 @@ static bool iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
 	else
 		clear_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status);
 
-	wiphy_rfkill_set_hw_state(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
+	wiphy_rfkill_set_hw_state_dup(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
 
 	/* iwl_run_init_mvm_ucode is waiting for results, abort it */
 	if (calibrating)
-		iwl_abort_notification_waits(&mvm->notif_wait);
+		iwl_abort_notification_waits_dup(&mvm->notif_wait);
 
 	/*
 	 * Stop the device if we run OPERATIONAL firmware or if we are in the
@@ -846,7 +846,7 @@ static void iwl_mvm_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)
 
 	info = IEEE80211_SKB_CB(skb);
 	iwl_trans_free_tx_cmd(mvm->trans, info->driver_data[1]);
-	ieee80211_free_txskb(mvm->hw, skb);
+	ieee80211_free_txskb_dup(mvm->hw, skb);
 }
 
 struct iwl_mvm_reprobe {
@@ -877,9 +877,9 @@ static void iwl_mvm_fw_error_dump_wk(struct work_struct *work)
 
 	/* stop recording */
 	if (mvm->cfg->device_family == IWL_DEVICE_FAMILY_7000) {
-		iwl_set_bits_prph(mvm->trans, MON_BUFF_SAMPLE_CTL, 0x100);
+		iwl_set_bits_prph_dup(mvm->trans, MON_BUFF_SAMPLE_CTL, 0x100);
 	} else {
-		iwl_write_prph(mvm->trans, DBGC_IN_SAMPLE, 0);
+		iwl_write_prph_dup(mvm->trans, DBGC_IN_SAMPLE, 0);
 		/* wait before we collect the data till the DBGC stop */
 		udelay(100);
 	}
@@ -898,7 +898,7 @@ static void iwl_mvm_fw_error_dump_wk(struct work_struct *work)
 
 void iwl_mvm_nic_restart(struct iwl_mvm *mvm, bool fw_error)
 {
-	iwl_abort_notification_waits(&mvm->notif_wait);
+	iwl_abort_notification_waits_dup(&mvm->notif_wait);
 
 	/*
 	 * This is a bit racy, but worst case we tell mac80211 about
@@ -951,7 +951,7 @@ void iwl_mvm_nic_restart(struct iwl_mvm *mvm, bool fw_error)
 
 		if (fw_error && mvm->restart_fw > 0)
 			mvm->restart_fw--;
-		ieee80211_restart_hw(mvm->hw);
+		ieee80211_restart_hw_dup(mvm->hw);
 	}
 }
 
@@ -1133,7 +1133,7 @@ int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode)
 		return 1;
 	}
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_enter_d0i3_iterator,
 						   &d0i3_iter_data);
@@ -1225,7 +1225,7 @@ out:
 		struct sk_buff *skb = __skb_dequeue(&mvm->d0i3_tx);
 
 		if (!sta || iwl_mvm_tx_skb(mvm, skb, sta))
-			ieee80211_free_txskb(mvm->hw, skb);
+			ieee80211_free_txskb_dup(mvm->hw, skb);
 
 		/* if the skb_queue is not empty, we need to wake queues */
 		wake_queues = true;
@@ -1234,7 +1234,7 @@ out:
 	wake_up(&mvm->d0i3_exit_waitq);
 	mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
 	if (wake_queues)
-		ieee80211_wake_queues(mvm->hw);
+		ieee80211_wake_queues_dup(mvm->hw);
 
 	spin_unlock_bh(&mvm->d0i3_tx_lock);
 }
@@ -1269,7 +1269,7 @@ static void iwl_mvm_d0i3_exit_work(struct work_struct *wk)
 		IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |
 		IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH;
 	if (wakeup_reasons & disconnection_reasons)
-		ieee80211_iterate_active_interfaces(
+		ieee80211_iterate_active_interfaces_dup(
 			mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 			iwl_mvm_d0i3_disconnect_iter, mvm);
 out:
@@ -1307,7 +1307,7 @@ int _iwl_mvm_exit_d0i3(struct iwl_mvm *mvm)
 	if (ret)
 		goto out;
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_exit_d0i3_iterator,
 						   mvm);
@@ -1332,7 +1332,7 @@ static void iwl_mvm_napi_add(struct iwl_op_mode *op_mode,
 {
 	struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 
-	ieee80211_napi_add(mvm->hw, napi, napi_dev, poll, weight);
+	ieee80211_napi_add_dup(mvm->hw, napi, napi_dev, poll, weight);
 }
 
 static const struct iwl_op_mode_ops iwl_mvm_ops = {
--- a/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
+++ b/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
@@ -286,7 +286,7 @@ int iwl_mvm_phy_ctx_count(struct iwl_mvm *mvm)
 {
 	unsigned long phy_ctxt_counter = 0;
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_binding_iterator,
 						   &phy_ctxt_counter);
--- a/drivers/net/wireless/iwlwifi/mvm/power.c
+++ b/drivers/net/wireless/iwlwifi/mvm/power.c
@@ -517,7 +517,7 @@ int iwl_mvm_power_uapsd_misbehaving_ap_notif(struct iwl_mvm *mvm,
 	struct iwl_uapsd_misbehaving_ap_notif *notif = (void *)pkt->data;
 	u8 ap_sta_id = le32_to_cpu(notif->sta_id);
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_power_uapsd_misbehav_ap_iterator, &ap_sta_id);
 
@@ -625,7 +625,7 @@ static void iwl_mvm_power_set_pm(struct iwl_mvm *mvm,
 	lockdep_assert_held(&mvm->mutex);
 
 	/* set pm_enable to false */
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 					IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_power_disable_pm_iterator,
 					NULL);
@@ -881,7 +881,7 @@ static int iwl_mvm_power_set_ps(struct iwl_mvm *mvm)
 	/* disable PS if CAM */
 	disable_ps = (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM);
 	/* ...or if any of the vifs require PS to be off */
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 					IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_power_ps_disabled_iterator,
 					&disable_ps);
@@ -929,7 +929,7 @@ int iwl_mvm_power_update_ps(struct iwl_mvm *mvm)
 	lockdep_assert_held(&mvm->mutex);
 
 	/* get vifs info */
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 					IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_power_get_vifs_iterator, &vifs);
 
@@ -950,7 +950,7 @@ int iwl_mvm_power_update_mac(struct iwl_mvm *mvm)
 	lockdep_assert_held(&mvm->mutex);
 
 	/* get vifs info */
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 					IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_power_get_vifs_iterator, &vifs);
 
--- a/drivers/net/wireless/iwlwifi/mvm/quota.c
+++ b/drivers/net/wireless/iwlwifi/mvm/quota.c
@@ -194,7 +194,7 @@ int iwl_mvm_update_quotas(struct iwl_mvm *mvm,
 	/* iterator data above must match */
 	BUILD_BUG_ON(MAX_BINDINGS != 4);
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_quota_iterator, &data);
 
--- a/drivers/net/wireless/iwlwifi/mvm/rs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/rs.c
@@ -569,7 +569,7 @@ static int rs_tl_turn_on_agg_for_tid(struct iwl_mvm *mvm,
 
 	IWL_DEBUG_HT(mvm, "Starting Tx agg: STA: %pM tid: %d\n",
 		     sta->addr, tid);
-	ret = ieee80211_start_tx_ba_session(sta, tid, 5000);
+	ret = ieee80211_start_tx_ba_session_dup(sta, tid, 5000);
 	if (ret == -EAGAIN) {
 		/*
 		 * driver and mac80211 is out of sync
@@ -578,7 +578,7 @@ static int rs_tl_turn_on_agg_for_tid(struct iwl_mvm *mvm,
 		 */
 		IWL_ERR(mvm, "Fail start Tx agg on tid: %d\n",
 			tid);
-		ieee80211_stop_tx_ba_session(sta, tid);
+		ieee80211_stop_tx_ba_session_dup(sta, tid);
 	}
 	return ret;
 }
@@ -1185,7 +1185,7 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
 		IWL_DEBUG_RATE(mvm, "Tx idle for too long. reinit rs\n");
 		for (t = 0; t < IWL_MAX_TID_COUNT; t++)
-			ieee80211_stop_tx_ba_session(sta, t);
+			ieee80211_stop_tx_ba_session_dup(sta, t);
 
 		iwl_mvm_rs_rate_init(mvm, sta, info->band, false);
 		return;
@@ -2380,7 +2380,7 @@ lq_update:
 					IWL_DEBUG_RATE(mvm,
 						       "Stop aggregation on tid %d\n",
 						       tid);
-					ieee80211_stop_tx_ba_session(sta, tid);
+					ieee80211_stop_tx_ba_session_dup(sta, tid);
 				}
 			}
 			rs_set_stay_in_table(mvm, 1, lq_sta);
@@ -2589,7 +2589,7 @@ static void rs_get_rate(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta,
 	}
 
 	/* Send management frames and NO_ACK data using lowest rate. */
-	if (rate_control_send_low(sta, mvm_sta, txrc))
+	if (rate_control_send_low_dup(sta, mvm_sta, txrc))
 		return;
 
 	iwl_mvm_hwrate_to_tx_rate(lq_sta->last_rate_n_flags,
@@ -2902,7 +2902,7 @@ static void rs_rate_update(void *mvm_r,
 
 	/* Stop any ongoing aggregations as rs starts off assuming no agg */
 	for (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)
-		ieee80211_stop_tx_ba_session(sta, tid);
+		ieee80211_stop_tx_ba_session_dup(sta, tid);
 
 	iwl_mvm_rs_rate_init(mvm, sta, sband->band, false);
 }
@@ -3160,14 +3160,14 @@ static void rs_set_lq_ss_params(struct iwl_mvm *mvm,
 	if (!lq_sta->bfer_capable)
 		goto out;
 
-	ieee80211_iterate_stations_atomic(mvm->hw,
+	ieee80211_iterate_stations_atomic_dup(mvm->hw,
 					  rs_bfer_active_iter,
 					  &data);
 	bfer_mvmsta = data.bfer_mvmsta;
 
 	/* This code is safe as it doesn't run concurrently for different
 	 * stations. This is guaranteed by the fact that calls to
-	 * ieee80211_tx_status wouldn't run concurrently for a single HW.
+	 * ieee80211_tx_status_dup wouldn't run concurrently for a single HW.
 	 */
 	if (!bfer_mvmsta) {
 		IWL_DEBUG_RATE(mvm, "No sta with BFER allowed found. Allow\n");
@@ -3735,12 +3735,12 @@ static const struct rate_control_ops rs_mvm_ops = {
 
 int iwl_mvm_rate_control_register(void)
 {
-	return ieee80211_rate_control_register(&rs_mvm_ops);
+	return ieee80211_rate_control_register_dup(&rs_mvm_ops);
 }
 
 void iwl_mvm_rate_control_unregister(void)
 {
-	ieee80211_rate_control_unregister(&rs_mvm_ops);
+	ieee80211_rate_control_unregister_dup(&rs_mvm_ops);
 }
 
 /**
--- a/drivers/net/wireless/iwlwifi/mvm/rs.h
+++ b/drivers/net/wireless/iwlwifi/mvm/rs.h
@@ -363,7 +363,7 @@ void iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
  * or reason to place it as a stand alone module.  The driver can call
  * iwl_rate_control_register in order to register the rate control callbacks
  * with the mac80211 subsystem.  This should be performed prior to calling
- * ieee80211_register_hw
+ * ieee80211_register_hw_dup
  *
  */
 int iwl_mvm_rate_control_register(void);
@@ -371,7 +371,7 @@ int iwl_mvm_rate_control_register(void);
 /**
  * iwl_rate_control_unregister - Unregister the rate control callbacks
  *
- * This should be called after calling ieee80211_unregister_hw, but before
+ * This should be called after calling ieee80211_unregister_hw_dup, but before
  * the driver is unloaded.
  */
 void iwl_mvm_rate_control_unregister(void);
--- a/drivers/net/wireless/iwlwifi/mvm/rx.c
+++ b/drivers/net/wireless/iwlwifi/mvm/rx.c
@@ -108,12 +108,12 @@ static void iwl_mvm_pass_packet_to_mac80211(struct iwl_mvm *mvm,
 	 * an additional 8 bytes for SNAP/ethertype, see below) so that
 	 * splice() or TCP coalesce are more efficient.
 	 *
-	 * Since, in addition, ieee80211_data_to_8023() always pull in at
+	 * Since, in addition, ieee80211_data_to_8023_dup() always pull in at
 	 * least 8 bytes (possibly more for mesh) we can do the same here
 	 * to save the cost of doing it later. That still doesn't pull in
 	 * the actual IP header since the typical case has a SNAP header.
 	 * If the latter changes (there are efforts in the standards group
-	 * to do so) we should revisit this and ieee80211_data_to_8023().
+	 * to do so) we should revisit this and ieee80211_data_to_8023_dup().
 	 */
 	hdrlen = (len <= skb_tailroom(skb)) ? len :
 					      sizeof(*hdr) + crypt_len + 8;
@@ -129,7 +129,7 @@ static void iwl_mvm_pass_packet_to_mac80211(struct iwl_mvm *mvm,
 				fraglen, rxb->truesize);
 	}
 
-	ieee80211_rx(mvm->hw, skb);
+	ieee80211_rx_dup(mvm->hw, skb);
 }
 
 /*
@@ -314,7 +314,7 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 		(phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_BAND_24)) ?
 				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;
 	rx_status->freq =
-		ieee80211_channel_to_frequency(le16_to_cpu(phy_info->channel),
+		ieee80211_channel_to_frequency_dup(le16_to_cpu(phy_info->channel),
 					       rx_status->band);
 	/*
 	 * TSF as indicated by the fw is at INA time, but mac80211 expects the
@@ -333,14 +333,14 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 	 * a blocked station on a new channel we can TX to it again.
 	 */
 	if (unlikely(mvm->csa_tx_block_bcn_timeout)) {
-		sta = ieee80211_find_sta(
+		sta = ieee80211_find_sta_dup(
 			rcu_dereference(mvm->csa_tx_blocked_vif), hdr->addr2);
 		if (sta)
 			iwl_mvm_sta_modify_disable_tx_ap(mvm, sta, false);
 	}
 
 	/* This is fine since we don't support multiple AP interfaces */
-	sta = ieee80211_find_sta_by_ifaddr(mvm->hw, hdr->addr2, NULL);
+	sta = ieee80211_find_sta_by_ifaddr_dup(mvm->hw, hdr->addr2, NULL);
 	if (sta) {
 		struct iwl_mvm_sta *mvmsta;
 		mvmsta = iwl_mvm_sta_from_mac80211(sta);
@@ -516,7 +516,7 @@ static void iwl_mvm_stat_iterator(void *_data, u8 *mac,
 		mvmvif->bf_data.last_cqm_event = sig;
 		IWL_DEBUG_RX(mvm, "cqm_iterator cqm low %d\n",
 			     sig);
-		ieee80211_cqm_rssi_notify(
+		ieee80211_cqm_rssi_notify_dup(
 			vif,
 			NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 			GFP_KERNEL);
@@ -525,7 +525,7 @@ static void iwl_mvm_stat_iterator(void *_data, u8 *mac,
 		mvmvif->bf_data.last_cqm_event = sig;
 		IWL_DEBUG_RX(mvm, "cqm_iterator cqm high %d\n",
 			     sig);
-		ieee80211_cqm_rssi_notify(
+		ieee80211_cqm_rssi_notify_dup(
 			vif,
 			NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 			GFP_KERNEL);
@@ -613,7 +613,7 @@ void iwl_mvm_handle_rx_statistics(struct iwl_mvm *mvm,
 	if (!(mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_ASYNC_DTM))
 		iwl_mvm_tt_temp_changed(mvm, temperature);
 
-	ieee80211_iterate_active_interfaces(mvm->hw,
+	ieee80211_iterate_active_interfaces_dup(mvm->hw,
 					    IEEE80211_IFACE_ITER_NORMAL,
 					    iwl_mvm_stat_iterator,
 					    &data);
--- a/drivers/net/wireless/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/iwlwifi/mvm/scan.c
@@ -212,7 +212,7 @@ static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
 	enum ieee80211_band band;
 	u8 frag_passive_dwell = 0;
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 					    IEEE80211_IFACE_ITER_NORMAL,
 					    iwl_mvm_scan_condition_iterator,
 					    &global_cnt);
@@ -332,7 +332,7 @@ int iwl_mvm_rx_scan_offload_results(struct iwl_mvm *mvm,
 				    struct iwl_device_cmd *cmd)
 {
 	IWL_DEBUG_SCAN(mvm, "Scheduled scan results\n");
-	ieee80211_sched_scan_results(mvm->hw);
+	ieee80211_sched_scan_results_dup(mvm->hw);
 
 	return 0;
 }
@@ -362,10 +362,10 @@ int iwl_mvm_rx_scan_offload_complete_notif(struct iwl_mvm *mvm,
 	/* only call mac80211 completion if the stop was initiated by FW */
 	if (mvm->scan_status == IWL_MVM_SCAN_SCHED) {
 		mvm->scan_status = IWL_MVM_SCAN_NONE;
-		ieee80211_sched_scan_stopped(mvm->hw);
+		ieee80211_sched_scan_stopped_dup(mvm->hw);
 	} else if (mvm->scan_status == IWL_MVM_SCAN_OS) {
 		mvm->scan_status = IWL_MVM_SCAN_NONE;
-		ieee80211_scan_completed(mvm->hw,
+		ieee80211_scan_completed_dup(mvm->hw,
 				scan_notif->status == IWL_SCAN_OFFLOAD_ABORTED);
 		iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
 	}
@@ -592,7 +592,7 @@ int iwl_mvm_scan_offload_stop(struct iwl_mvm *mvm, bool notify)
 		goto out;
 	}
 
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_scan_done,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_scan_done,
 				   scan_done_notif,
 				   ARRAY_SIZE(scan_done_notif),
 				   NULL, NULL);
@@ -601,14 +601,14 @@ int iwl_mvm_scan_offload_stop(struct iwl_mvm *mvm, bool notify)
 	if (ret) {
 		IWL_DEBUG_SCAN(mvm, "Send stop %sscan failed %d\n",
 			       sched ? "offloaded " : "", ret);
-		iwl_remove_notification(&mvm->notif_wait, &wait_scan_done);
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_scan_done);
 		goto out;
 	}
 
 	IWL_DEBUG_SCAN(mvm, "Successfully sent stop %sscan\n",
 		       sched ? "offloaded " : "");
 
-	ret = iwl_wait_notification(&mvm->notif_wait, &wait_scan_done, 1 * HZ);
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &wait_scan_done, 1 * HZ);
 out:
 	/*
 	 * Clear the scan status so the next scan requests will succeed. This
@@ -623,9 +623,9 @@ out:
 
 	if (notify) {
 		if (sched)
-			ieee80211_sched_scan_stopped(mvm->hw);
+			ieee80211_sched_scan_stopped_dup(mvm->hw);
 		else
-			ieee80211_scan_completed(mvm->hw, true);
+			ieee80211_scan_completed_dup(mvm->hw, true);
 	}
 
 	return ret;
@@ -687,7 +687,7 @@ static u8 *iwl_mvm_copy_and_insert_ds_elem(struct iwl_mvm *mvm, const u8 *ies,
 		return newpos + len;
 	}
 
-	offs = ieee80211_ie_split(ies, len,
+	offs = ieee80211_ie_split_dup(ies, len,
 				  before_ds_params,
 				  ARRAY_SIZE(before_ds_params),
 				  0);
@@ -1025,7 +1025,7 @@ int iwl_mvm_cancel_scan(struct iwl_mvm *mvm)
 		return 0;
 
 	if (iwl_mvm_is_radio_killed(mvm)) {
-		ieee80211_scan_completed(mvm->hw, true);
+		ieee80211_scan_completed_dup(mvm->hw, true);
 		iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
 		mvm->scan_status = IWL_MVM_SCAN_NONE;
 		return 0;
@@ -1500,12 +1500,12 @@ int iwl_mvm_rx_umac_scan_complete_notif(struct iwl_mvm *mvm,
 	mvm->scan_uid[uid_idx] = 0;
 
 	if (!sched) {
-		ieee80211_scan_completed(mvm->hw,
+		ieee80211_scan_completed_dup(mvm->hw,
 					 notif->status ==
 						IWL_SCAN_OFFLOAD_ABORTED);
 		iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
 	} else if (!iwl_mvm_find_scan_type(mvm, IWL_UMAC_SCAN_UID_SCHED_SCAN)) {
-		ieee80211_sched_scan_stopped(mvm->hw);
+		ieee80211_sched_scan_stopped_dup(mvm->hw);
 	} else {
 		IWL_DEBUG_SCAN(mvm, "Another sched scan is running\n");
 	}
@@ -1566,7 +1566,7 @@ static int iwl_umac_scan_stop(struct iwl_mvm *mvm,
 	};
 	int i, ret = -EIO;
 
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_scan_done,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_scan_done,
 				   scan_done_notif,
 				   ARRAY_SIZE(scan_done_notif),
 				   iwl_scan_umac_done_check, &scan_done);
@@ -1579,7 +1579,7 @@ static int iwl_umac_scan_stop(struct iwl_mvm *mvm,
 
 			if (iwl_mvm_is_radio_killed(mvm) &&
 			    (type & IWL_UMAC_SCAN_UID_REG_SCAN)) {
-				ieee80211_scan_completed(mvm->hw, true);
+				ieee80211_scan_completed_dup(mvm->hw, true);
 				iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
 				break;
 			}
@@ -1592,19 +1592,19 @@ static int iwl_umac_scan_stop(struct iwl_mvm *mvm,
 
 	if (ret) {
 		IWL_DEBUG_SCAN(mvm, "Couldn't stop scan\n");
-		iwl_remove_notification(&mvm->notif_wait, &wait_scan_done);
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_scan_done);
 		return ret;
 	}
 
-	ret = iwl_wait_notification(&mvm->notif_wait, &wait_scan_done, 1 * HZ);
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &wait_scan_done, 1 * HZ);
 	if (ret)
 		return ret;
 
 	if (notify) {
 		if (type & IWL_UMAC_SCAN_UID_SCHED_SCAN)
-			ieee80211_sched_scan_stopped(mvm->hw);
+			ieee80211_sched_scan_stopped_dup(mvm->hw);
 		if (type & IWL_UMAC_SCAN_UID_REG_SCAN) {
-			ieee80211_scan_completed(mvm->hw, true);
+			ieee80211_scan_completed_dup(mvm->hw, true);
 			iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
 		}
 	}
@@ -1637,13 +1637,13 @@ void iwl_mvm_report_scan_aborted(struct iwl_mvm *mvm)
 
 		uid = iwl_mvm_find_first_scan(mvm, IWL_UMAC_SCAN_UID_REG_SCAN);
 		if (uid < IWL_MVM_MAX_SIMULTANEOUS_SCANS) {
-			ieee80211_scan_completed(mvm->hw, true);
+			ieee80211_scan_completed_dup(mvm->hw, true);
 			mvm->scan_uid[uid] = 0;
 		}
 		uid = iwl_mvm_find_first_scan(mvm,
 					      IWL_UMAC_SCAN_UID_SCHED_SCAN);
 		if (uid < IWL_MVM_MAX_SIMULTANEOUS_SCANS && !mvm->restart_fw) {
-			ieee80211_sched_scan_stopped(mvm->hw);
+			ieee80211_sched_scan_stopped_dup(mvm->hw);
 			mvm->scan_uid[uid] = 0;
 		}
 
@@ -1662,7 +1662,7 @@ void iwl_mvm_report_scan_aborted(struct iwl_mvm *mvm)
 		case IWL_MVM_SCAN_NONE:
 			break;
 		case IWL_MVM_SCAN_OS:
-			ieee80211_scan_completed(mvm->hw, true);
+			ieee80211_scan_completed_dup(mvm->hw, true);
 			break;
 		case IWL_MVM_SCAN_SCHED:
 			/*
@@ -1671,7 +1671,7 @@ void iwl_mvm_report_scan_aborted(struct iwl_mvm *mvm)
 			 * restarted.
 			 */
 			if (!mvm->restart_fw)
-				ieee80211_sched_scan_stopped(mvm->hw);
+				ieee80211_sched_scan_stopped_dup(mvm->hw);
 			break;
 		}
 	}
--- a/drivers/net/wireless/iwlwifi/mvm/sf.c
+++ b/drivers/net/wireless/iwlwifi/mvm/sf.c
@@ -296,7 +296,7 @@ int iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *changed_vif,
 	    (changed_vif && changed_vif->type == NL80211_IFTYPE_P2P_DEVICE))
 		return 0;
 
-	ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+	ieee80211_iterate_active_interfaces_atomic_dup(mvm->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   iwl_mvm_bound_iface_iterator,
 						   &data);
--- a/drivers/net/wireless/iwlwifi/mvm/sta.c
+++ b/drivers/net/wireless/iwlwifi/mvm/sta.c
@@ -965,7 +965,7 @@ int iwl_mvm_sta_tx_agg_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
 	if (tid_data->ssn == tid_data->next_reclaimed) {
 		tid_data->state = IWL_AGG_STARTING;
-		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_start_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 	} else {
 		tid_data->state = IWL_EMPTYING_HW_QUEUE_ADDBA;
 	}
@@ -1038,7 +1038,7 @@ int iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	 * our state has been cleared anyway.
 	 */
 	if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
-		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_stop_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 		return 0;
 	}
 
@@ -1071,7 +1071,7 @@ int iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 		mvm->queue_to_mac80211[txq_id] = IWL_INVALID_MAC80211_QUEUE;
 		spin_unlock_bh(&mvmsta->lock);
 
-		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_stop_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 
 		iwl_mvm_sta_tx_agg(mvm, sta, tid, txq_id, false);
 
@@ -1088,7 +1088,7 @@ int iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 		lockdep_assert_held(&mvm->mutex);
 		mvm->queue_to_mac80211[txq_id] = IWL_INVALID_MAC80211_QUEUE;
 
-		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_stop_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 		tid_data->state = IWL_AGG_OFF;
 		err = 0;
 		break;
@@ -1277,9 +1277,9 @@ static int iwl_mvm_send_sta_igtk(struct iwl_mvm *mvm,
 		const u8 *pn;
 
 		memcpy(igtk_cmd.IGTK, keyconf->key, keyconf->keylen);
-		ieee80211_aes_cmac_calculate_k1_k2(keyconf,
+		ieee80211_aes_cmac_calculate_k1_k2_dup(keyconf,
 						   igtk_cmd.K1, igtk_cmd.K2);
-		ieee80211_get_key_rx_seq(keyconf, 0, &seq);
+		ieee80211_get_key_rx_seq_dup(keyconf, 0, &seq);
 		pn = seq.aes_cmac.pn;
 		igtk_cmd.receive_seq_cnt = cpu_to_le64(((u64) pn[5] << 0) |
 						       ((u64) pn[4] << 8) |
@@ -1335,8 +1335,8 @@ static int __iwl_mvm_set_sta_key(struct iwl_mvm *mvm,
 	case WLAN_CIPHER_SUITE_TKIP:
 		addr = iwl_mvm_get_mac_addr(mvm, vif, sta);
 		/* get phase 1 key from mac80211 */
-		ieee80211_get_key_rx_seq(keyconf, 0, &seq);
-		ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);
+		ieee80211_get_key_rx_seq_dup(keyconf, 0, &seq);
+		ieee80211_get_tkip_rx_p1k_dup(keyconf, addr, seq.tkip.iv32, p1k);
 		ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, mcast,
 					   seq.tkip.iv32, p1k, 0);
 		break;
@@ -1623,7 +1623,7 @@ void iwl_mvm_sta_modify_sleep_tx_count(struct iwl_mvm *mvm,
 				 "TID %d state is %d\n",
 				 tid, tid_data->state)) {
 				spin_unlock_bh(&mvmsta->lock);
-				ieee80211_sta_eosp(sta);
+				ieee80211_sta_eosp_dup(sta);
 				return;
 			}
 
@@ -1639,7 +1639,7 @@ void iwl_mvm_sta_modify_sleep_tx_count(struct iwl_mvm *mvm,
 
 		cmd.sleep_tx_count = cpu_to_le16(cnt - remaining);
 		if (WARN_ON(cnt - remaining == 0)) {
-			ieee80211_sta_eosp(sta);
+			ieee80211_sta_eosp_dup(sta);
 			return;
 		}
 	}
@@ -1675,7 +1675,7 @@ int iwl_mvm_rx_eosp_notif(struct iwl_mvm *mvm,
 	rcu_read_lock();
 	sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
 	if (!IS_ERR_OR_NULL(sta))
-		ieee80211_sta_eosp(sta);
+		ieee80211_sta_eosp_dup(sta);
 	rcu_read_unlock();
 
 	return 0;
@@ -1719,7 +1719,7 @@ void iwl_mvm_sta_modify_disable_tx_ap(struct iwl_mvm *mvm,
 	 * for this station.
 	 */
 	if (disable || !atomic_read(&mvm->pending_frames[mvm_sta->sta_id]))
-		ieee80211_sta_block_awake(mvm->hw, sta, disable);
+		ieee80211_sta_block_awake_dup(mvm->hw, sta, disable);
 
 	iwl_mvm_sta_modify_disable_tx(mvm, mvm_sta, disable);
 
--- a/drivers/net/wireless/iwlwifi/mvm/tdls.c
+++ b/drivers/net/wireless/iwlwifi/mvm/tdls.c
@@ -85,7 +85,7 @@ void iwl_mvm_teardown_tdls_peers(struct iwl_mvm *mvm)
 			continue;
 
 		mvmsta = iwl_mvm_sta_from_mac80211(sta);
-		ieee80211_tdls_oper_request(mvmsta->vif, sta->addr,
+		ieee80211_tdls_oper_request_dup(mvmsta->vif, sta->addr,
 				NL80211_TDLS_TEARDOWN,
 				WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED,
 				GFP_KERNEL);
@@ -255,7 +255,7 @@ static void iwl_mvm_tdls_update_cs_state(struct iwl_mvm *mvm,
 	/* we only send requests to our switching peer - update sent time */
 	if (state == IWL_MVM_TDLS_SW_REQ_SENT)
 		mvm->tdls_cs.peer.sent_timestamp =
-			iwl_read_prph(mvm->trans, DEVICE_SYSTEM_TIME_REG);
+			iwl_read_prph_dup(mvm->trans, DEVICE_SYSTEM_TIME_REG);
 
 	if (state == IWL_MVM_TDLS_SW_IDLE)
 		mvm->tdls_cs.cur_sta_id = IWL_MVM_STATION_COUNT;
@@ -297,7 +297,7 @@ int iwl_mvm_rx_tdls_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 	 * Also convert TU to msec.
 	 */
 	delay = TU_TO_MS(vif->bss_conf.dtim_period * vif->bss_conf.beacon_int);
-	mod_delayed_work(mvm->workqueue, &mvm->tdls_cs.dwork,
+	schedule_delayed_work(&mvm->tdls_cs.dwork,
 			 msecs_to_jiffies(delay));
 
 	iwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_ACTIVE);
@@ -425,7 +425,7 @@ iwl_mvm_tdls_config_channel_switch(struct iwl_mvm *mvm,
 	cmd.timing.switch_timeout = cpu_to_le32(switch_timeout);
 
 	rcu_read_lock();
-	sta = ieee80211_find_sta(vif, peer);
+	sta = ieee80211_find_sta_dup(vif, peer);
 	if (!sta) {
 		rcu_read_unlock();
 		ret = -ENOENT;
@@ -617,7 +617,7 @@ iwl_mvm_tdls_channel_switch(struct ieee80211_hw *hw,
 	 */
 	delay = 2 * TU_TO_MS(vif->bss_conf.dtim_period *
 			     vif->bss_conf.beacon_int);
-	mod_delayed_work(mvm->workqueue, &mvm->tdls_cs.dwork,
+	schedule_delayed_work(&mvm->tdls_cs.dwork,
 			 msecs_to_jiffies(delay));
 
 out:
@@ -731,7 +731,7 @@ retry:
 	/* register a timeout in case we don't succeed in switching */
 	delay = vif->bss_conf.dtim_period * vif->bss_conf.beacon_int *
 		1024 / 1000;
-	mod_delayed_work(mvm->workqueue, &mvm->tdls_cs.dwork,
+	schedule_delayed_work(&mvm->tdls_cs.dwork,
 			 msecs_to_jiffies(delay));
 	mutex_unlock(&mvm->mutex);
 }
--- a/drivers/net/wireless/iwlwifi/mvm/time-event.c
+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.c
@@ -160,12 +160,12 @@ static void iwl_mvm_csa_noa_start(struct iwl_mvm *mvm)
 	 * So we just do nothing here and the switch
 	 * will be performed on the last TBTT.
 	 */
-	if (!ieee80211_csa_is_complete(csa_vif)) {
+	if (!ieee80211_csa_is_complete_dup(csa_vif)) {
 		IWL_WARN(mvm, "CSA NOA started too early\n");
 		goto out_unlock;
 	}
 
-	ieee80211_csa_finish(csa_vif);
+	ieee80211_csa_finish_dup(csa_vif);
 
 	rcu_read_unlock();
 
@@ -216,7 +216,7 @@ iwl_mvm_te_handle_notify_csa(struct iwl_mvm *mvm,
 			break;
 		}
 		iwl_mvm_csa_client_absent(mvm, te_data->vif);
-		ieee80211_chswitch_done(te_data->vif, true);
+		ieee80211_chswitch_done_dup(te_data->vif, true);
 		break;
 	default:
 		/* should never happen */
@@ -316,7 +316,7 @@ static void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,
 
 		switch (te_data->vif->type) {
 		case NL80211_IFTYPE_P2P_DEVICE:
-			ieee80211_remain_on_channel_expired(mvm->hw);
+			ieee80211_remain_on_channel_expired_dup(mvm->hw);
 			iwl_mvm_roc_finished(mvm);
 			break;
 		case NL80211_IFTYPE_STATION:
@@ -339,7 +339,7 @@ static void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,
 		if (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE) {
 			set_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);
 			iwl_mvm_ref(mvm, IWL_MVM_REF_ROC);
-			ieee80211_ready_on_channel(mvm->hw);
+			ieee80211_ready_on_channel_dup(mvm->hw);
 		} else if (te_data->id == TE_CHANNEL_SWITCH_PERIOD) {
 			iwl_mvm_te_handle_notify_csa(mvm, te_data, notif);
 		}
@@ -383,7 +383,7 @@ static int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,
 
 	if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_END) {
 		/* End TE, notify mac80211 */
-		ieee80211_remain_on_channel_expired(mvm->hw);
+		ieee80211_remain_on_channel_expired_dup(mvm->hw);
 		iwl_mvm_roc_finished(mvm); /* flush aux queue */
 		list_del(&te_data->list); /* remove from list */
 		te_data->running = false;
@@ -393,7 +393,7 @@ static int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,
 	} else if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_START) {
 		set_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status);
 		te_data->running = true;
-		ieee80211_ready_on_channel(mvm->hw); /* Start TE */
+		ieee80211_ready_on_channel_dup(mvm->hw); /* Start TE */
 	} else {
 		IWL_DEBUG_TE(mvm,
 			     "ERROR: Unknown Aux ROC Time Event (action = %d)\n",
@@ -529,7 +529,7 @@ static int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,
 	 * time another notification (that the time event started)
 	 * might already be processed unsuccessfully.
 	 */
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_time_event,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_time_event,
 				   time_event_response,
 				   ARRAY_SIZE(time_event_response),
 				   iwl_mvm_time_event_response, te_data);
@@ -538,12 +538,12 @@ static int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,
 					    sizeof(*te_cmd), te_cmd);
 	if (ret) {
 		IWL_ERR(mvm, "Couldn't send TIME_EVENT_CMD: %d\n", ret);
-		iwl_remove_notification(&mvm->notif_wait, &wait_time_event);
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_time_event);
 		goto out_clear_te;
 	}
 
 	/* No need to wait for anything, so just pass 1 (0 isn't valid) */
-	ret = iwl_wait_notification(&mvm->notif_wait, &wait_time_event, 1);
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &wait_time_event, 1);
 	/* should never fail */
 	WARN_ON_ONCE(ret);
 
@@ -597,7 +597,7 @@ void iwl_mvm_protect_session(struct iwl_mvm *mvm,
 	time_cmd.id = cpu_to_le32(TE_BSS_STA_AGGRESSIVE_ASSOC);
 
 	time_cmd.apply_time =
-		cpu_to_le32(iwl_read_prph(mvm->trans, DEVICE_SYSTEM_TIME_REG));
+		cpu_to_le32(iwl_read_prph_dup(mvm->trans, DEVICE_SYSTEM_TIME_REG));
 
 	time_cmd.max_frags = TE_V2_FRAG_NONE;
 	time_cmd.max_delay = cpu_to_le32(max_delay);
@@ -618,7 +618,7 @@ void iwl_mvm_protect_session(struct iwl_mvm *mvm,
 	 * Create notification_wait for the TIME_EVENT_NOTIFICATION to use
 	 * right after we send the time event
 	 */
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_te_notif,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_te_notif,
 				   te_notif_response,
 				   ARRAY_SIZE(te_notif_response),
 				   iwl_mvm_te_notif, te_data);
@@ -626,8 +626,8 @@ void iwl_mvm_protect_session(struct iwl_mvm *mvm,
 	/* If TE was sent OK - wait for the notification that started */
 	if (iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd)) {
 		IWL_ERR(mvm, "Failed to add TE to protect session\n");
-		iwl_remove_notification(&mvm->notif_wait, &wait_te_notif);
-	} else if (iwl_wait_notification(&mvm->notif_wait, &wait_te_notif,
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_te_notif);
+	} else if (iwl_wait_notification_dup(&mvm->notif_wait, &wait_te_notif,
 					 TU_TO_JIFFIES(max_delay))) {
 		IWL_ERR(mvm, "Failed to protect session until TE\n");
 	}
--- a/drivers/net/wireless/iwlwifi/mvm/tt.c
+++ b/drivers/net/wireless/iwlwifi/mvm/tt.c
@@ -192,18 +192,18 @@ int iwl_mvm_get_temp(struct iwl_mvm *mvm)
 
 	lockdep_assert_held(&mvm->mutex);
 
-	iwl_init_notification_wait(&mvm->notif_wait, &wait_temp_notif,
+	iwl_init_notification_wait_dup(&mvm->notif_wait, &wait_temp_notif,
 				   temp_notif, ARRAY_SIZE(temp_notif),
 				   iwl_mvm_temp_notif_wait, &temp);
 
 	ret = iwl_mvm_get_temp_cmd(mvm);
 	if (ret) {
 		IWL_ERR(mvm, "Failed to get the temperature (err=%d)\n", ret);
-		iwl_remove_notification(&mvm->notif_wait, &wait_temp_notif);
+		iwl_remove_notification_dup(&mvm->notif_wait, &wait_temp_notif);
 		return ret;
 	}
 
-	ret = iwl_wait_notification(&mvm->notif_wait, &wait_temp_notif,
+	ret = iwl_wait_notification_dup(&mvm->notif_wait, &wait_temp_notif,
 				    IWL_MVM_TEMP_NOTIF_WAIT_TIMEOUT);
 	if (ret) {
 		IWL_ERR(mvm, "Getting the temperature timed out\n");
@@ -350,7 +350,7 @@ void iwl_mvm_tt_handler(struct iwl_mvm *mvm)
 		    temperature >= params->dynamic_smps_entry) {
 			IWL_DEBUG_TEMP(mvm, "Enable dynamic SMPS\n");
 			tt->dynamic_smps = true;
-			ieee80211_iterate_active_interfaces_atomic(
+			ieee80211_iterate_active_interfaces_atomic_dup(
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_tt_smps_iterator, mvm);
 			throttle_enable = true;
@@ -358,7 +358,7 @@ void iwl_mvm_tt_handler(struct iwl_mvm *mvm)
 			   temperature <= params->dynamic_smps_exit) {
 			IWL_DEBUG_TEMP(mvm, "Disable dynamic SMPS\n");
 			tt->dynamic_smps = false;
-			ieee80211_iterate_active_interfaces_atomic(
+			ieee80211_iterate_active_interfaces_atomic_dup(
 					mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 					iwl_mvm_tt_smps_iterator, mvm);
 		}
--- a/drivers/net/wireless/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/iwlwifi/mvm/tx.c
@@ -258,7 +258,7 @@ void iwl_mvm_set_tx_cmd_crypto(struct iwl_mvm *mvm,
 
 	case WLAN_CIPHER_SUITE_TKIP:
 		tx_cmd->sec_ctl = TX_CMD_SEC_TKIP;
-		ieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);
+		ieee80211_get_tkip_p2k_dup(keyconf, skb_frag, tx_cmd->key);
 		break;
 
 	case WLAN_CIPHER_SUITE_WEP104:
@@ -363,7 +363,7 @@ int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)
 	tx_cmd = (struct iwl_tx_cmd *)dev_cmd->payload;
 
 	/* Copy MAC header from skb into command buffer */
-	memcpy(tx_cmd->hdr, hdr, ieee80211_hdrlen(hdr->frame_control));
+	memcpy(tx_cmd->hdr, hdr, ieee80211_hdrlen_dup(hdr->frame_control));
 
 	if (iwl_trans_tx(mvm->trans, skb, dev_cmd, info->hw_queue)) {
 		iwl_trans_free_tx_cmd(mvm->trans, dev_cmd);
@@ -411,7 +411,7 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
 	 * will always send a notification, and for PS-Poll responses
 	 * we'll notify mac80211 when getting frame status
 	 */
-	info->flags &= ~IEEE80211_TX_STATUS_EOSP;
+	info->flags &= ~ieee80211_tx_status_EOSP;
 
 	spin_lock(&mvmsta->lock);
 
@@ -431,7 +431,7 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
 	}
 
 	/* Copy MAC header from skb into command buffer */
-	memcpy(tx_cmd->hdr, hdr, ieee80211_hdrlen(fc));
+	memcpy(tx_cmd->hdr, hdr, ieee80211_hdrlen_dup(fc));
 
 	WARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);
 
@@ -488,7 +488,7 @@ static void iwl_mvm_check_ratid_empty(struct iwl_mvm *mvm,
 		 * knows we no longer have frames buffered for the station on
 		 * this TID (for the TIM bitmap calculation.)
 		 */
-		ieee80211_sta_set_buffered(sta, tid, false);
+		ieee80211_sta_set_buffered_dup(sta, tid, false);
 	}
 
 	if (tid_data->ssn != tid_data->next_reclaimed)
@@ -500,7 +500,7 @@ static void iwl_mvm_check_ratid_empty(struct iwl_mvm *mvm,
 				    "Can continue addBA flow ssn = next_recl = %d\n",
 				    tid_data->next_reclaimed);
 		tid_data->state = IWL_AGG_STARTING;
-		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_start_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 		break;
 
 	case IWL_EMPTYING_HW_QUEUE_DELBA:
@@ -516,7 +516,7 @@ static void iwl_mvm_check_ratid_empty(struct iwl_mvm *mvm,
 		 */
 		mvm->queue_to_mac80211[tid_data->txq_id] =
 					IWL_INVALID_MAC80211_QUEUE;
-		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_stop_tx_ba_cb_irqsafe_dup(vif, sta->addr, tid);
 		break;
 
 	default:
@@ -689,7 +689,7 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
 		info->status.status_driver_data[0] =
 				(void *)(uintptr_t)tx_resp->reduced_tpc;
 
-		ieee80211_tx_status(mvm->hw, skb);
+		ieee80211_tx_status_dup(mvm->hw, skb);
 	}
 
 	if (txq_id >= mvm->first_agg_queue) {
@@ -750,7 +750,7 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
 
 		if (mvmsta->next_status_eosp) {
 			mvmsta->next_status_eosp = false;
-			ieee80211_sta_eosp(sta);
+			ieee80211_sta_eosp_dup(sta);
 		}
 	} else {
 		mvmsta = NULL;
@@ -783,7 +783,7 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
 		spin_lock_bh(&mvmsta->lock);
 
 		if (!mvmsta->disable_tx)
-			ieee80211_sta_block_awake(mvm->hw, sta, false);
+			ieee80211_sta_block_awake_dup(mvm->hw, sta, false);
 
 		spin_unlock_bh(&mvmsta->lock);
 	}
@@ -1043,7 +1043,7 @@ out:
 
 	while (!skb_queue_empty(&reclaimed_skbs)) {
 		skb = __skb_dequeue(&reclaimed_skbs);
-		ieee80211_tx_status(mvm->hw, skb);
+		ieee80211_tx_status_dup(mvm->hw, skb);
 	}
 
 	return 0;
--- a/drivers/net/wireless/iwlwifi/mvm/utils.c
+++ b/drivers/net/wireless/iwlwifi/mvm/utils.c
@@ -774,7 +774,7 @@ void iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 			smps_mode = IEEE80211_SMPS_DYNAMIC;
 	}
 
-	ieee80211_request_smps(vif, smps_mode);
+	ieee80211_request_smps_dup(vif, smps_mode);
 }
 
 int iwl_mvm_request_statistics(struct iwl_mvm *mvm, bool clear)
@@ -837,7 +837,7 @@ bool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm)
 	if (mvm->cfg->rx_with_siso_diversity)
 		return false;
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 			mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 			iwl_mvm_diversity_iter, &result);
 
@@ -878,7 +878,7 @@ bool iwl_mvm_low_latency(struct iwl_mvm *mvm)
 {
 	bool result = false;
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 			mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 			iwl_mvm_ll_iter, &result);
 
@@ -910,7 +910,7 @@ struct ieee80211_vif *iwl_mvm_get_bss_vif(struct iwl_mvm *mvm)
 {
 	struct iwl_bss_iter_data bss_iter_data = {};
 
-	ieee80211_iterate_active_interfaces_atomic(
+	ieee80211_iterate_active_interfaces_atomic_dup(
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_bss_iface_iterator, &bss_iter_data);
 
@@ -987,5 +987,5 @@ void iwl_mvm_connection_loss(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 	iwl_mvm_fw_dbg_collect_trig(mvm, trig, "%s", errmsg);
 
 out:
-	ieee80211_connection_loss(vif);
+	ieee80211_connection_loss_dup(vif);
 }
--- a/drivers/net/wireless/iwlwifi/pcie/drv.c
+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c
@@ -81,195 +81,6 @@
 
 /* Hardware specific file defines the PCI IDs table for that hardware module */
 static const struct pci_device_id iwl_hw_card_ids[] = {
-#if IS_ENABLED(CONFIG_IWLDVM)
-	{IWL_PCI_DEVICE(0x4232, 0x1201, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1301, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1204, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1304, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1205, iwl5100_bgn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1305, iwl5100_bgn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1206, iwl5100_abg_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1306, iwl5100_abg_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1221, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1321, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1224, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1324, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1225, iwl5100_bgn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1325, iwl5100_bgn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1226, iwl5100_abg_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4232, 0x1326, iwl5100_abg_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1211, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1311, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1214, iwl5100_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1314, iwl5100_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1215, iwl5100_bgn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1315, iwl5100_bgn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1216, iwl5100_abg_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4237, 0x1316, iwl5100_abg_cfg)}, /* Half Mini Card */
-
-/* 5300 Series WiFi */
-	{IWL_PCI_DEVICE(0x4235, 0x1021, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1121, iwl5300_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1024, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1124, iwl5300_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1001, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1101, iwl5300_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1004, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4235, 0x1104, iwl5300_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4236, 0x1011, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4236, 0x1111, iwl5300_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x4236, 0x1014, iwl5300_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x4236, 0x1114, iwl5300_agn_cfg)}, /* Half Mini Card */
-
-/* 5350 Series WiFi/WiMax */
-	{IWL_PCI_DEVICE(0x423A, 0x1001, iwl5350_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423A, 0x1021, iwl5350_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423B, 0x1011, iwl5350_agn_cfg)}, /* Mini Card */
-
-/* 5150 Series Wifi/WiMax */
-	{IWL_PCI_DEVICE(0x423C, 0x1201, iwl5150_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1301, iwl5150_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1206, iwl5150_abg_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1306, iwl5150_abg_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1221, iwl5150_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1321, iwl5150_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x423C, 0x1326, iwl5150_abg_cfg)}, /* Half Mini Card */
-
-	{IWL_PCI_DEVICE(0x423D, 0x1211, iwl5150_agn_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423D, 0x1311, iwl5150_agn_cfg)}, /* Half Mini Card */
-	{IWL_PCI_DEVICE(0x423D, 0x1216, iwl5150_abg_cfg)}, /* Mini Card */
-	{IWL_PCI_DEVICE(0x423D, 0x1316, iwl5150_abg_cfg)}, /* Half Mini Card */
-
-/* 6x00 Series */
-	{IWL_PCI_DEVICE(0x422B, 0x1101, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x422B, 0x1108, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x422B, 0x1121, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x422B, 0x1128, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x422C, 0x1301, iwl6000i_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x422C, 0x1306, iwl6000i_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x422C, 0x1307, iwl6000i_2bg_cfg)},
-	{IWL_PCI_DEVICE(0x422C, 0x1321, iwl6000i_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x422C, 0x1326, iwl6000i_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x4238, 0x1111, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x4238, 0x1118, iwl6000_3agn_cfg)},
-	{IWL_PCI_DEVICE(0x4239, 0x1311, iwl6000i_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x4239, 0x1316, iwl6000i_2abg_cfg)},
-
-/* 6x05 Series */
-	{IWL_PCI_DEVICE(0x0082, 0x1301, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1306, iwl6005_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1307, iwl6005_2bg_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1308, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1321, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1326, iwl6005_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1328, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0085, 0x1311, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0085, 0x1318, iwl6005_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0085, 0x1316, iwl6005_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0xC020, iwl6005_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x0085, 0xC220, iwl6005_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x0085, 0xC228, iwl6005_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x4820, iwl6005_2agn_d_cfg)},
-	{IWL_PCI_DEVICE(0x0082, 0x1304, iwl6005_2agn_mow1_cfg)},/* low 5GHz active */
-	{IWL_PCI_DEVICE(0x0082, 0x1305, iwl6005_2agn_mow2_cfg)},/* high 5GHz active */
-
-/* 6x30 Series */
-	{IWL_PCI_DEVICE(0x008A, 0x5305, iwl1030_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x008A, 0x5307, iwl1030_bg_cfg)},
-	{IWL_PCI_DEVICE(0x008A, 0x5325, iwl1030_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x008A, 0x5327, iwl1030_bg_cfg)},
-	{IWL_PCI_DEVICE(0x008B, 0x5315, iwl1030_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x008B, 0x5317, iwl1030_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0090, 0x5211, iwl6030_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0090, 0x5215, iwl6030_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0090, 0x5216, iwl6030_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5201, iwl6030_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5205, iwl6030_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5206, iwl6030_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5207, iwl6030_2bg_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5221, iwl6030_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5225, iwl6030_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0091, 0x5226, iwl6030_2abg_cfg)},
-
-/* 6x50 WiFi/WiMax Series */
-	{IWL_PCI_DEVICE(0x0087, 0x1301, iwl6050_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0087, 0x1306, iwl6050_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0087, 0x1321, iwl6050_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0087, 0x1326, iwl6050_2abg_cfg)},
-	{IWL_PCI_DEVICE(0x0089, 0x1311, iwl6050_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x0089, 0x1316, iwl6050_2abg_cfg)},
-
-/* 6150 WiFi/WiMax Series */
-	{IWL_PCI_DEVICE(0x0885, 0x1305, iwl6150_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0885, 0x1307, iwl6150_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0885, 0x1325, iwl6150_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0885, 0x1327, iwl6150_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0886, 0x1315, iwl6150_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0886, 0x1317, iwl6150_bg_cfg)},
-
-/* 1000 Series WiFi */
-	{IWL_PCI_DEVICE(0x0083, 0x1205, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1305, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1225, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1325, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0084, 0x1215, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0084, 0x1315, iwl1000_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1206, iwl1000_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1306, iwl1000_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1226, iwl1000_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0083, 0x1326, iwl1000_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0084, 0x1216, iwl1000_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0084, 0x1316, iwl1000_bg_cfg)},
-
-/* 100 Series WiFi */
-	{IWL_PCI_DEVICE(0x08AE, 0x1005, iwl100_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x08AE, 0x1007, iwl100_bg_cfg)},
-	{IWL_PCI_DEVICE(0x08AF, 0x1015, iwl100_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x08AF, 0x1017, iwl100_bg_cfg)},
-	{IWL_PCI_DEVICE(0x08AE, 0x1025, iwl100_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x08AE, 0x1027, iwl100_bg_cfg)},
-
-/* 130 Series WiFi */
-	{IWL_PCI_DEVICE(0x0896, 0x5005, iwl130_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0896, 0x5007, iwl130_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0897, 0x5015, iwl130_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0897, 0x5017, iwl130_bg_cfg)},
-	{IWL_PCI_DEVICE(0x0896, 0x5025, iwl130_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0896, 0x5027, iwl130_bg_cfg)},
-
-/* 2x00 Series */
-	{IWL_PCI_DEVICE(0x0890, 0x4022, iwl2000_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0891, 0x4222, iwl2000_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0890, 0x4422, iwl2000_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0890, 0x4822, iwl2000_2bgn_d_cfg)},
-
-/* 2x30 Series */
-	{IWL_PCI_DEVICE(0x0887, 0x4062, iwl2030_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0888, 0x4262, iwl2030_2bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0887, 0x4462, iwl2030_2bgn_cfg)},
-
-/* 6x35 Series */
-	{IWL_PCI_DEVICE(0x088E, 0x4060, iwl6035_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x088E, 0x406A, iwl6035_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x088F, 0x4260, iwl6035_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x088F, 0x426A, iwl6035_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x088E, 0x4460, iwl6035_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x088E, 0x446A, iwl6035_2agn_sff_cfg)},
-	{IWL_PCI_DEVICE(0x088E, 0x4860, iwl6035_2agn_cfg)},
-	{IWL_PCI_DEVICE(0x088F, 0x5260, iwl6035_2agn_cfg)},
-
-/* 105 Series */
-	{IWL_PCI_DEVICE(0x0894, 0x0022, iwl105_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0895, 0x0222, iwl105_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0894, 0x0422, iwl105_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0894, 0x0822, iwl105_bgn_d_cfg)},
-
-/* 135 Series */
-	{IWL_PCI_DEVICE(0x0892, 0x0062, iwl135_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0893, 0x0262, iwl135_bgn_cfg)},
-	{IWL_PCI_DEVICE(0x0892, 0x0462, iwl135_bgn_cfg)},
-#endif /* CONFIG_IWLDVM */
-
 #if IS_ENABLED(CONFIG_IWLMVM)
 /* 7260 Series */
 	{IWL_PCI_DEVICE(0x08B1, 0x4070, iwl7260_2ac_cfg)},
@@ -413,37 +224,6 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x095B, 0x5290, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5490, iwl7265_2ac_cfg)},
 
-/* 8000 Series */
-	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x1010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0110, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x1110, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0250, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x1050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0150, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0x0030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0x1130, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0x1030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0xC010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0xD010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0xC030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0xD030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0xC050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0xD050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x8010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x9010, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0x8030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F4, 0x9030, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x8050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x9050, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0004, iwl8260_2n_cfg)},
-	{IWL_PCI_DEVICE(0x24F5, 0x0010, iwl4165_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F6, 0x0030, iwl4165_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0810, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0910, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0850, iwl8260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x24F3, 0x0950, iwl8260_2ac_cfg)},
 #endif /* CONFIG_IWLMVM */
 
 	{0}
--- a/drivers/net/wireless/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/rx.c
@@ -138,8 +138,8 @@ static inline __le32 iwl_pcie_dma_addr2rbd_ptr(dma_addr_t dma_addr)
  */
 int iwl_pcie_rx_stop(struct iwl_trans *trans)
 {
-	iwl_write_direct32(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
-	return iwl_poll_direct_bit(trans, FH_MEM_RSSR_RX_STATUS_REG,
+	iwl_write_direct32_dup(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
+	return iwl_poll_direct_bit_dup(trans, FH_MEM_RSSR_RX_STATUS_REG,
 				   FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE, 1000);
 }
 
@@ -437,21 +437,21 @@ static void iwl_pcie_rx_hw_init(struct iwl_trans *trans, struct iwl_rxq *rxq)
 		rb_size = FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K;
 
 	/* Stop Rx DMA */
-	iwl_write_direct32(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
+	iwl_write_direct32_dup(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
 	/* reset and flush pointers */
-	iwl_write_direct32(trans, FH_MEM_RCSR_CHNL0_RBDCB_WPTR, 0);
-	iwl_write_direct32(trans, FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ, 0);
-	iwl_write_direct32(trans, FH_RSCSR_CHNL0_RDPTR, 0);
+	iwl_write_direct32_dup(trans, FH_MEM_RCSR_CHNL0_RBDCB_WPTR, 0);
+	iwl_write_direct32_dup(trans, FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ, 0);
+	iwl_write_direct32_dup(trans, FH_RSCSR_CHNL0_RDPTR, 0);
 
 	/* Reset driver's Rx queue write index */
-	iwl_write_direct32(trans, FH_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);
+	iwl_write_direct32_dup(trans, FH_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);
 
 	/* Tell device where to find RBD circular buffer in DRAM */
-	iwl_write_direct32(trans, FH_RSCSR_CHNL0_RBDCB_BASE_REG,
+	iwl_write_direct32_dup(trans, FH_RSCSR_CHNL0_RBDCB_BASE_REG,
 			   (u32)(rxq->bd_dma >> 8));
 
 	/* Tell device where in DRAM to update its Rx status */
-	iwl_write_direct32(trans, FH_RSCSR_CHNL0_STTS_WPTR_REG,
+	iwl_write_direct32_dup(trans, FH_RSCSR_CHNL0_STTS_WPTR_REG,
 			   rxq->rb_stts_dma >> 4);
 
 	/* Enable Rx DMA
@@ -462,7 +462,7 @@ static void iwl_pcie_rx_hw_init(struct iwl_trans *trans, struct iwl_rxq *rxq)
 	 * RB timeout 0x10
 	 * 256 RBDs
 	 */
-	iwl_write_direct32(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG,
+	iwl_write_direct32_dup(trans, FH_MEM_RCSR_CHNL0_CONFIG_REG,
 			   FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL |
 			   FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY |
 			   FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL |
@@ -779,9 +779,9 @@ static void iwl_pcie_irq_handle_error(struct iwl_trans *trans)
 
 	/* W/A for WiFi/WiMAX coex and WiMAX own the RF */
 	if (trans->cfg->internal_wimax_coex &&
-	    (!(iwl_read_prph(trans, APMG_CLK_CTRL_REG) &
+	    (!(iwl_read_prph_dup(trans, APMG_CLK_CTRL_REG) &
 			     APMS_CLK_VAL_MRB_FUNC_MODE) ||
-	     (iwl_read_prph(trans, APMG_PS_CTRL_REG) &
+	     (iwl_read_prph_dup(trans, APMG_PS_CTRL_REG) &
 			    APMG_PS_CTRL_VAL_RESET_REQ))) {
 		clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
 		iwl_op_mode_wimax_active(trans->op_mode);
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@ -165,11 +165,11 @@ static void iwl_trans_pcie_write_shr(struct iwl_trans *trans, u32 reg, u32 val)
 static void iwl_pcie_set_pwr(struct iwl_trans *trans, bool vaux)
 {
 	if (vaux && pci_pme_capable(to_pci_dev(trans->dev), PCI_D3cold))
-		iwl_set_bits_mask_prph(trans, APMG_PS_CTRL_REG,
+		iwl_set_bits_mask_prph_dup(trans, APMG_PS_CTRL_REG,
 				       APMG_PS_CTRL_VAL_PWR_SRC_VAUX,
 				       ~APMG_PS_CTRL_MSK_PWR_SRC);
 	else
-		iwl_set_bits_mask_prph(trans, APMG_PS_CTRL_REG,
+		iwl_set_bits_mask_prph_dup(trans, APMG_PS_CTRL_REG,
 				       APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,
 				       ~APMG_PS_CTRL_MSK_PWR_SRC);
 }
@@ -257,10 +257,10 @@ static int iwl_pcie_apm_init(struct iwl_trans *trans)
 
 	/*
 	 * Wait for clock stabilization; once stabilized, access to
-	 * device-internal resources is supported, e.g. iwl_write_prph()
+	 * device-internal resources is supported, e.g. iwl_write_prph_dup()
 	 * and accesses to uCode SRAM.
 	 */
-	ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+	ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY, 25000);
 	if (ret < 0) {
@@ -283,11 +283,11 @@ static int iwl_pcie_apm_init(struct iwl_trans *trans)
 		 * just to discard the value. But that's the way the hardware
 		 * seems to like it.
 		 */
-		iwl_read_prph(trans, OSC_CLK);
-		iwl_read_prph(trans, OSC_CLK);
-		iwl_set_bits_prph(trans, OSC_CLK, OSC_CLK_FORCE_CONTROL);
-		iwl_read_prph(trans, OSC_CLK);
-		iwl_read_prph(trans, OSC_CLK);
+		iwl_read_prph_dup(trans, OSC_CLK);
+		iwl_read_prph_dup(trans, OSC_CLK);
+		iwl_set_bits_prph_dup(trans, OSC_CLK, OSC_CLK_FORCE_CONTROL);
+		iwl_read_prph_dup(trans, OSC_CLK);
+		iwl_read_prph_dup(trans, OSC_CLK);
 	}
 
 	/*
@@ -298,16 +298,16 @@ static int iwl_pcie_apm_init(struct iwl_trans *trans)
 	 * bits already set by default in "CLK_CTRL_REG" after reset.
 	 */
 	if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
-		iwl_write_prph(trans, APMG_CLK_EN_REG,
+		iwl_write_prph_dup(trans, APMG_CLK_EN_REG,
 			       APMG_CLK_VAL_DMA_CLK_RQT);
 		udelay(20);
 
 		/* Disable L1-Active */
-		iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,
+		iwl_set_bits_prph_dup(trans, APMG_PCIDEV_STT_REG,
 				  APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
 
 		/* Clear the interrupt in APMG if the NIC is in RFKILL */
-		iwl_write_prph(trans, APMG_RTC_INT_STT_REG,
+		iwl_write_prph_dup(trans, APMG_RTC_INT_STT_REG,
 			       APMG_RTC_INT_STT_RFKILL);
 	}
 
@@ -350,7 +350,7 @@ static void iwl_pcie_apm_lp_xtal_enable(struct iwl_trans *trans)
 	 * Wait for clock stabilization; once stabilized, access to
 	 * device-internal resources is possible.
 	 */
-	ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+	ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   25000);
@@ -366,7 +366,7 @@ static void iwl_pcie_apm_lp_xtal_enable(struct iwl_trans *trans)
 	 * Clear "disable persistence" to avoid LP XTAL resetting when
 	 * SHRD_HW_RST is applied in S3.
 	 */
-	iwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,
+	iwl_clear_bits_prph_dup(trans, APMG_PCIDEV_STT_REG,
 				    APMG_PCIDEV_STT_VAL_PERSIST_DIS);
 
 	/*
@@ -434,7 +434,7 @@ static int iwl_pcie_apm_stop_master(struct iwl_trans *trans)
 	/* stop device's busmaster DMA activity */
 	iwl_set_bit(trans, CSR_RESET, CSR_RESET_REG_FLAG_STOP_MASTER);
 
-	ret = iwl_poll_bit(trans, CSR_RESET,
+	ret = iwl_poll_bit_dup(trans, CSR_RESET,
 			   CSR_RESET_REG_FLAG_MASTER_DISABLED,
 			   CSR_RESET_REG_FLAG_MASTER_DISABLED, 100);
 	if (ret < 0)
@@ -455,7 +455,7 @@ static void iwl_pcie_apm_stop(struct iwl_trans *trans, bool op_mode_leave)
 
 		/* inform ME that we are leaving */
 		if (trans->cfg->device_family == IWL_DEVICE_FAMILY_7000)
-			iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,
+			iwl_set_bits_prph_dup(trans, APMG_PCIDEV_STT_REG,
 					  APMG_PCIDEV_STT_VAL_WAKE_ME);
 		else if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
 			iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
@@ -529,7 +529,7 @@ static int iwl_pcie_set_hw_ready(struct iwl_trans *trans)
 		    CSR_HW_IF_CONFIG_REG_BIT_NIC_READY);
 
 	/* See if we got it */
-	ret = iwl_poll_bit(trans, CSR_HW_IF_CONFIG_REG,
+	ret = iwl_poll_bit_dup(trans, CSR_HW_IF_CONFIG_REG,
 			   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,
 			   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,
 			   HW_READY_TIMEOUT);
@@ -587,30 +587,30 @@ static int iwl_pcie_load_firmware_chunk(struct iwl_trans *trans, u32 dst_addr,
 
 	trans_pcie->ucode_write_complete = false;
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_TCSR_CHNL_TX_CONFIG_REG(FH_SRVC_CHNL),
 			   FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE);
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_SRVC_CHNL_SRAM_ADDR_REG(FH_SRVC_CHNL),
 			   dst_addr);
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_TFDIB_CTRL0_REG(FH_SRVC_CHNL),
 			   phy_addr & FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK);
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_TFDIB_CTRL1_REG(FH_SRVC_CHNL),
 			   (iwl_get_dma_hi_addr(phy_addr)
 				<< FH_MEM_TFDIB_REG1_ADDR_BITSHIFT) | byte_cnt);
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_TCSR_CHNL_TX_BUF_STS_REG(FH_SRVC_CHNL),
 			   1 << FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM |
 			   1 << FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX |
 			   FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID);
 
-	iwl_write_direct32(trans,
+	iwl_write_direct32_dup(trans,
 			   FH_TCSR_CHNL_TX_CONFIG_REG(FH_SRVC_CHNL),
 			   FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE	|
 			   FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE	|
@@ -660,7 +660,7 @@ static int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num,
 			extended_addr = true;
 
 		if (extended_addr)
-			iwl_set_bits_prph(trans, LMPM_CHICK,
+			iwl_set_bits_prph_dup(trans, LMPM_CHICK,
 					  LMPM_CHICK_EXTENDED_ADDR_SPACE);
 
 		memcpy(v_addr, (u8 *)section->data + offset, copy_size);
@@ -668,7 +668,7 @@ static int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num,
 						   copy_size);
 
 		if (extended_addr)
-			iwl_clear_bits_prph(trans, LMPM_CHICK,
+			iwl_clear_bits_prph_dup(trans, LMPM_CHICK,
 					    LMPM_CHICK_EXTENDED_ADDR_SPACE);
 
 		if (ret) {
@@ -697,7 +697,7 @@ static int iwl_pcie_rsa_race_bug_wa(struct iwl_trans *trans)
 	 * If the HW isn't locked and the rsa semaphore isn't accessible,
 	 * we are in trouble.
 	 */
-	val = iwl_read_prph(trans, PREG_AUX_BUS_WPROT_0);
+	val = iwl_read_prph_dup(trans, PREG_AUX_BUS_WPROT_0);
 	if (val & (BIT(1) | BIT(17))) {
 		IWL_INFO(trans,
 			 "can't access the RSA semaphore it is write protected\n");
@@ -705,14 +705,14 @@ static int iwl_pcie_rsa_race_bug_wa(struct iwl_trans *trans)
 	}
 
 	/* take ownership on the AUX IF */
-	iwl_write_prph(trans, WFPM_CTRL_REG, WFPM_AUX_CTL_AUX_IF_MAC_OWNER_MSK);
-	iwl_write_prph(trans, AUX_MISC_MASTER1_EN, AUX_MISC_MASTER1_EN_SBE_MSK);
+	iwl_write_prph_dup(trans, WFPM_CTRL_REG, WFPM_AUX_CTL_AUX_IF_MAC_OWNER_MSK);
+	iwl_write_prph_dup(trans, AUX_MISC_MASTER1_EN, AUX_MISC_MASTER1_EN_SBE_MSK);
 
 	do {
-		iwl_write_prph(trans, AUX_MISC_MASTER1_SMPHR_STATUS, 0x1);
-		val = iwl_read_prph(trans, AUX_MISC_MASTER1_SMPHR_STATUS);
+		iwl_write_prph_dup(trans, AUX_MISC_MASTER1_SMPHR_STATUS, 0x1);
+		val = iwl_read_prph_dup(trans, AUX_MISC_MASTER1_SMPHR_STATUS);
 		if (val == 0x1) {
-			iwl_write_prph(trans, RSA_ENABLE, 0);
+			iwl_write_prph_dup(trans, RSA_ENABLE, 0);
 			return 0;
 		}
 
@@ -757,18 +757,18 @@ static int iwl_pcie_load_cpu_sections_8000(struct iwl_trans *trans,
 			return ret;
 
 		/* Notify the ucode of the loaded section number and status */
-		val = iwl_read_direct32(trans, FH_UCODE_LOAD_STATUS);
+		val = iwl_read_direct32_dup(trans, FH_UCODE_LOAD_STATUS);
 		val = val | (sec_num << shift_param);
-		iwl_write_direct32(trans, FH_UCODE_LOAD_STATUS, val);
+		iwl_write_direct32_dup(trans, FH_UCODE_LOAD_STATUS, val);
 		sec_num = (sec_num << 1) | 0x1;
 	}
 
 	*first_ucode_section = last_read_idx;
 
 	if (cpu == 1)
-		iwl_write_direct32(trans, FH_UCODE_LOAD_STATUS, 0xFFFF);
+		iwl_write_direct32_dup(trans, FH_UCODE_LOAD_STATUS, 0xFFFF);
 	else
-		iwl_write_direct32(trans, FH_UCODE_LOAD_STATUS, 0xFFFFFFFF);
+		iwl_write_direct32_dup(trans, FH_UCODE_LOAD_STATUS, 0xFFFFFFFF);
 
 	return 0;
 }
@@ -807,7 +807,7 @@ static int iwl_pcie_load_cpu_sections(struct iwl_trans *trans,
 	}
 
 	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
-		iwl_set_bits_prph(trans,
+		iwl_set_bits_prph_dup(trans,
 				  CSR_UCODE_LOAD_STATUS_ADDR,
 				  (LMPM_CPU_UCODE_LOADING_COMPLETED |
 				   LMPM_CPU_HDRS_LOADING_COMPLETED |
@@ -853,13 +853,13 @@ static void iwl_pcie_apply_destination(struct iwl_trans *trans)
 			iwl_clear_bit(trans, addr, BIT(val));
 			break;
 		case PRPH_ASSIGN:
-			iwl_write_prph(trans, addr, val);
+			iwl_write_prph_dup(trans, addr, val);
 			break;
 		case PRPH_SETBIT:
-			iwl_set_bits_prph(trans, addr, BIT(val));
+			iwl_set_bits_prph_dup(trans, addr, BIT(val));
 			break;
 		case PRPH_CLEARBIT:
-			iwl_clear_bits_prph(trans, addr, BIT(val));
+			iwl_clear_bits_prph_dup(trans, addr, BIT(val));
 			break;
 		default:
 			IWL_ERR(trans, "FW debug - unknown OP %d\n",
@@ -869,9 +869,9 @@ static void iwl_pcie_apply_destination(struct iwl_trans *trans)
 	}
 
 	if (dest->monitor_mode == EXTERNAL_MODE && trans_pcie->fw_mon_size) {
-		iwl_write_prph(trans, le32_to_cpu(dest->base_reg),
+		iwl_write_prph_dup(trans, le32_to_cpu(dest->base_reg),
 			       trans_pcie->fw_mon_phys >> dest->base_shift);
-		iwl_write_prph(trans, le32_to_cpu(dest->end_reg),
+		iwl_write_prph_dup(trans, le32_to_cpu(dest->end_reg),
 			       (trans_pcie->fw_mon_phys +
 				trans_pcie->fw_mon_size) >> dest->end_shift);
 	}
@@ -894,7 +894,7 @@ static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,
 
 	if (image->is_dual_cpus) {
 		/* set CPU2 header address */
-		iwl_write_prph(trans,
+		iwl_write_prph_dup(trans,
 			       LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR,
 			       LMPM_SECURE_CPU2_HDR_MEM_SPACE);
 
@@ -906,14 +906,14 @@ static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,
 	}
 
 	/* supported for 7000 only for the moment */
-	if (iwlwifi_mod_params.fw_monitor &&
+	if (iwlwifi_mod_params_dup.fw_monitor &&
 	    trans->cfg->device_family == IWL_DEVICE_FAMILY_7000) {
 		iwl_pcie_alloc_fw_monitor(trans);
 
 		if (trans_pcie->fw_mon_size) {
-			iwl_write_prph(trans, MON_BUFF_BASE_ADDR,
+			iwl_write_prph_dup(trans, MON_BUFF_BASE_ADDR,
 				       trans_pcie->fw_mon_phys >> 4);
-			iwl_write_prph(trans, MON_BUFF_END_ADDR,
+			iwl_write_prph_dup(trans, MON_BUFF_END_ADDR,
 				       (trans_pcie->fw_mon_phys +
 					trans_pcie->fw_mon_size) >> 4);
 		}
@@ -946,7 +946,7 @@ static int iwl_pcie_load_given_ucode_8000(struct iwl_trans *trans,
 
 	/* configure the ucode to be ready to get the secured image */
 	/* release CPU reset */
-	iwl_write_prph(trans, RELEASE_CPU_RESET, RELEASE_CPU_RESET_BIT);
+	iwl_write_prph_dup(trans, RELEASE_CPU_RESET, RELEASE_CPU_RESET_BIT);
 
 	/* load to FW the binary Secured sections of CPU1 */
 	ret = iwl_pcie_load_cpu_sections_8000(trans, image, 1,
@@ -1050,7 +1050,7 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool low_power)
 
 		/* Power-down device's busmaster DMA clocks */
 		if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
-			iwl_write_prph(trans, APMG_CLK_DIS_REG,
+			iwl_write_prph_dup(trans, APMG_CLK_DIS_REG,
 				       APMG_CLK_VAL_DMA_CLK_RQT);
 			udelay(5);
 		}
@@ -1175,7 +1175,7 @@ static int iwl_trans_pcie_d3_resume(struct iwl_trans *trans,
 	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
 		udelay(2);
 
-	ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+	ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 			   25000);
@@ -1400,7 +1400,7 @@ static bool iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans, bool silent,
 	 * 5000 series and later (including 1000 series) have non-volatile SRAM,
 	 * and do not save/restore SRAM when power cycling.
 	 */
-	ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+	ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 			   CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,
 			   (CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |
 			    CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP), 15000);
@@ -1609,10 +1609,10 @@ static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, u32 txq_bm)
 
 	for (cnt = 0; cnt < FH_TCSR_CHNL_NUM; cnt++)
 		IWL_ERR(trans, "FH TRBs(%d) = 0x%08x\n", cnt,
-			iwl_read_direct32(trans, FH_TX_TRB_REG(cnt)));
+			iwl_read_direct32_dup(trans, FH_TX_TRB_REG(cnt)));
 
 	for (cnt = 0; cnt < trans->cfg->base_params->num_of_queues; cnt++) {
-		u32 status = iwl_read_prph(trans, SCD_QUEUE_STATUS_BITS(cnt));
+		u32 status = iwl_read_prph_dup(trans, SCD_QUEUE_STATUS_BITS(cnt));
 		u8 fifo = (status >> SCD_QUEUE_STTS_REG_POS_TXF) & 0x7;
 		bool active = !!(status & BIT(SCD_QUEUE_STTS_REG_POS_ACTIVE));
 		u32 tbl_dw =
@@ -1627,9 +1627,9 @@ static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, u32 txq_bm)
 		IWL_ERR(trans,
 			"Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",
 			cnt, active ? "" : "in", fifo, tbl_dw,
-			iwl_read_prph(trans, SCD_QUEUE_RDPTR(cnt)) &
+			iwl_read_prph_dup(trans, SCD_QUEUE_RDPTR(cnt)) &
 				(TFD_QUEUE_SIZE_MAX - 1),
-			iwl_read_prph(trans, SCD_QUEUE_WRPTR(cnt)));
+			iwl_read_prph_dup(trans, SCD_QUEUE_WRPTR(cnt)));
 	}
 
 	return ret;
@@ -1651,7 +1651,7 @@ void iwl_trans_pcie_ref(struct iwl_trans *trans)
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	unsigned long flags;
 
-	if (iwlwifi_mod_params.d0i3_disable)
+	if (iwlwifi_mod_params_dup.d0i3_disable)
 		return;
 
 	spin_lock_irqsave(&trans_pcie->ref_lock, flags);
@@ -1665,7 +1665,7 @@ void iwl_trans_pcie_unref(struct iwl_trans *trans)
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	unsigned long flags;
 
-	if (iwlwifi_mod_params.d0i3_disable)
+	if (iwlwifi_mod_params_dup.d0i3_disable)
 		return;
 
 	spin_lock_irqsave(&trans_pcie->ref_lock, flags);
@@ -2246,9 +2246,9 @@ struct iwl_trans_dump_data *iwl_trans_pcie_dump_data(struct iwl_trans *trans)
 		base = le32_to_cpu(trans->dbg_dest_tlv->base_reg);
 		end = le32_to_cpu(trans->dbg_dest_tlv->end_reg);
 
-		base = iwl_read_prph(trans, base) <<
+		base = iwl_read_prph_dup(trans, base) <<
 		       trans->dbg_dest_tlv->base_shift;
-		end = iwl_read_prph(trans, end) <<
+		end = iwl_read_prph_dup(trans, end) <<
 		      trans->dbg_dest_tlv->end_shift;
 
 		/* Make "end" point to the actual end */
@@ -2320,11 +2320,11 @@ struct iwl_trans_dump_data *iwl_trans_pcie_dump_data(struct iwl_trans *trans)
 		data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_FW_MONITOR);
 		fw_mon_data = (void *)data->data;
 		fw_mon_data->fw_mon_wr_ptr =
-			cpu_to_le32(iwl_read_prph(trans, write_ptr));
+			cpu_to_le32(iwl_read_prph_dup(trans, write_ptr));
 		fw_mon_data->fw_mon_cycle_cnt =
-			cpu_to_le32(iwl_read_prph(trans, wrap_cnt));
+			cpu_to_le32(iwl_read_prph_dup(trans, wrap_cnt));
 		fw_mon_data->fw_mon_base_ptr =
-			cpu_to_le32(iwl_read_prph(trans, base));
+			cpu_to_le32(iwl_read_prph_dup(trans, base));
 
 		len += sizeof(*data) + sizeof(*fw_mon_data);
 		if (trans_pcie->fw_mon_page) {
@@ -2353,7 +2353,7 @@ struct iwl_trans_dump_data *iwl_trans_pcie_dump_data(struct iwl_trans *trans)
 			 * Update pointers to reflect actual values after
 			 * shifting
 			 */
-			base = iwl_read_prph(trans, base) <<
+			base = iwl_read_prph_dup(trans, base) <<
 			       trans->dbg_dest_tlv->base_shift;
 			iwl_trans_read_mem(trans, base, fw_mon_data->data,
 					   monitor_len / sizeof(u32));
@@ -2523,7 +2523,7 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 			    CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
 		udelay(2);
 
-		ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+		ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 				   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 				   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
 				   25000);
@@ -2535,10 +2535,10 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 		if (iwl_trans_grab_nic_access(trans, false, &flags)) {
 			u32 hw_step;
 
-			hw_step = __iwl_read_prph(trans, WFPM_CTRL_REG);
+			hw_step = __iwl_read_prph_dup(trans, WFPM_CTRL_REG);
 			hw_step |= ENABLE_WFPM;
-			__iwl_write_prph(trans, WFPM_CTRL_REG, hw_step);
-			hw_step = __iwl_read_prph(trans, AUX_MISC_REG);
+			__iwl_write_prph_dup(trans, WFPM_CTRL_REG, hw_step);
+			hw_step = __iwl_read_prph_dup(trans, AUX_MISC_REG);
 			hw_step = (hw_step >> HW_STEP_LOCATION_BITS) & 0xF;
 			if (hw_step == 0x3)
 				trans->hw_rev = (trans->hw_rev & 0xFFFFFFF3) |
--- a/drivers/net/wireless/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c
@@ -173,10 +173,10 @@ static void iwl_pcie_txq_stuck_timer(unsigned long data)
 
 	for (i = 0; i < FH_TCSR_CHNL_NUM; i++)
 		IWL_ERR(trans, "FH TRBs(%d) = 0x%08x\n", i,
-			iwl_read_direct32(trans, FH_TX_TRB_REG(i)));
+			iwl_read_direct32_dup(trans, FH_TX_TRB_REG(i)));
 
 	for (i = 0; i < trans->cfg->base_params->num_of_queues; i++) {
-		u32 status = iwl_read_prph(trans, SCD_QUEUE_STATUS_BITS(i));
+		u32 status = iwl_read_prph_dup(trans, SCD_QUEUE_STATUS_BITS(i));
 		u8 fifo = (status >> SCD_QUEUE_STTS_REG_POS_TXF) & 0x7;
 		bool active = !!(status & BIT(SCD_QUEUE_STTS_REG_POS_ACTIVE));
 		u32 tbl_dw =
@@ -192,12 +192,12 @@ static void iwl_pcie_txq_stuck_timer(unsigned long data)
 		IWL_ERR(trans,
 			"Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",
 			i, active ? "" : "in", fifo, tbl_dw,
-			iwl_read_prph(trans, SCD_QUEUE_RDPTR(i)) &
+			iwl_read_prph_dup(trans, SCD_QUEUE_RDPTR(i)) &
 				(TFD_QUEUE_SIZE_MAX - 1),
-			iwl_read_prph(trans, SCD_QUEUE_WRPTR(i)));
+			iwl_read_prph_dup(trans, SCD_QUEUE_WRPTR(i)));
 	}
 
-	iwl_force_nmi(trans);
+	iwl_force_nmi_dup(trans);
 }
 
 /*
@@ -562,7 +562,7 @@ static int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq,
 	 * Tell nic where to find circular buffer of Tx Frame Descriptors for
 	 * given Tx queue, and enable the DMA channel used for that queue.
 	 * Circular buffer (TFD queue in DRAM) physical base address */
-	iwl_write_direct32(trans, FH_MEM_CBBC_QUEUE(txq_id),
+	iwl_write_direct32_dup(trans, FH_MEM_CBBC_QUEUE(txq_id),
 			   txq->q.dma_addr >> 8);
 
 	return 0;
@@ -654,7 +654,7 @@ void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
 	memset(trans_pcie->queue_used, 0, sizeof(trans_pcie->queue_used));
 
 	trans_pcie->scd_base_addr =
-		iwl_read_prph(trans, SCD_SRAM_BASE_ADDR);
+		iwl_read_prph_dup(trans, SCD_SRAM_BASE_ADDR);
 
 	WARN_ON(scd_base_addr != 0 &&
 		scd_base_addr != trans_pcie->scd_base_addr);
@@ -664,14 +664,14 @@ void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
 				   SCD_CONTEXT_MEM_LOWER_BOUND,
 			    NULL, clear_dwords);
 
-	iwl_write_prph(trans, SCD_DRAM_BASE_ADDR,
+	iwl_write_prph_dup(trans, SCD_DRAM_BASE_ADDR,
 		       trans_pcie->scd_bc_tbls.dma >> 10);
 
 	/* The chain extension of the SCD doesn't work well. This feature is
 	 * enabled by default by the HW, so we need to disable it manually.
 	 */
 	if (trans->cfg->base_params->scd_chain_ext_wa)
-		iwl_write_prph(trans, SCD_CHAINEXT_EN, 0);
+		iwl_write_prph_dup(trans, SCD_CHAINEXT_EN, 0);
 
 	iwl_trans_ac_txq_enable(trans, trans_pcie->cmd_queue,
 				trans_pcie->cmd_fifo,
@@ -682,18 +682,18 @@ void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
 
 	/* Enable DMA channel */
 	for (chan = 0; chan < FH_TCSR_CHNL_NUM; chan++)
-		iwl_write_direct32(trans, FH_TCSR_CHNL_TX_CONFIG_REG(chan),
+		iwl_write_direct32_dup(trans, FH_TCSR_CHNL_TX_CONFIG_REG(chan),
 				   FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |
 				   FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);
 
 	/* Update FH chicken bits */
-	reg_val = iwl_read_direct32(trans, FH_TX_CHICKEN_BITS_REG);
-	iwl_write_direct32(trans, FH_TX_CHICKEN_BITS_REG,
+	reg_val = iwl_read_direct32_dup(trans, FH_TX_CHICKEN_BITS_REG);
+	iwl_write_direct32_dup(trans, FH_TX_CHICKEN_BITS_REG,
 			   reg_val | FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);
 
 	/* Enable L1-Active */
 	if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
-		iwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,
+		iwl_clear_bits_prph_dup(trans, APMG_PCIDEV_STT_REG,
 				    APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
 }
 
@@ -706,7 +706,7 @@ void iwl_trans_pcie_tx_reset(struct iwl_trans *trans)
 	     txq_id++) {
 		struct iwl_txq *txq = &trans_pcie->txq[txq_id];
 
-		iwl_write_direct32(trans, FH_MEM_CBBC_QUEUE(txq_id),
+		iwl_write_direct32_dup(trans, FH_MEM_CBBC_QUEUE(txq_id),
 				   txq->q.dma_addr >> 8);
 		iwl_pcie_txq_unmap(trans, txq_id);
 		txq->q.read_ptr = 0;
@@ -714,7 +714,7 @@ void iwl_trans_pcie_tx_reset(struct iwl_trans *trans)
 	}
 
 	/* Tell NIC where to find the "keep warm" buffer */
-	iwl_write_direct32(trans, FH_KW_MEM_ADDR_REG,
+	iwl_write_direct32_dup(trans, FH_KW_MEM_ADDR_REG,
 			   trans_pcie->kw.dma >> 4);
 
 	/*
@@ -744,7 +744,7 @@ static void iwl_pcie_tx_stop_fh(struct iwl_trans *trans)
 	}
 
 	/* Wait for DMA channels to be idle */
-	ret = iwl_poll_bit(trans, FH_TSSR_TX_STATUS_REG, mask, mask, 5000);
+	ret = iwl_poll_bit_dup(trans, FH_TSSR_TX_STATUS_REG, mask, mask, 5000);
 	if (ret < 0)
 		IWL_ERR(trans,
 			"Failing on timeout while stopping DMA channel %d [0x%08x]\n",
@@ -897,7 +897,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
 	iwl_scd_deactivate_fifos(trans);
 
 	/* Tell NIC where to find the "keep warm" buffer */
-	iwl_write_direct32(trans, FH_KW_MEM_ADDR_REG,
+	iwl_write_direct32_dup(trans, FH_KW_MEM_ADDR_REG,
 			   trans_pcie->kw.dma >> 4);
 
 	spin_unlock(&trans_pcie->irq_lock);
@@ -916,7 +916,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
 	}
 
 	if (trans->cfg->base_params->num_of_queues > 20)
-		iwl_set_bits_prph(trans, SCD_GP_CTRL,
+		iwl_set_bits_prph_dup(trans, SCD_GP_CTRL,
 				  SCD_GP_CTRL_ENABLE_31_QUEUES);
 
 	return 0;
@@ -1056,7 +1056,7 @@ static int iwl_pcie_set_cmd_in_flight(struct iwl_trans *trans,
 		if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
 			udelay(2);
 
-		ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+		ret = iwl_poll_bit_dup(trans, CSR_GP_CNTRL,
 				   CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,
 				   (CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |
 				    CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP),
@@ -1128,7 +1128,7 @@ static void iwl_pcie_cmdq_reclaim(struct iwl_trans *trans, int txq_id, int idx)
 		if (nfreed++ > 0) {
 			IWL_ERR(trans, "HCMD skipped: index (%d) %d %d\n",
 				idx, q->write_ptr, q->read_ptr);
-			iwl_force_nmi(trans);
+			iwl_force_nmi_dup(trans);
 		}
 	}
 
@@ -1223,13 +1223,13 @@ void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, u16 ssn,
 	 * Assumes that ssn_idx is valid (!= 0xFFF) */
 	txq->q.read_ptr = (ssn & 0xff);
 	txq->q.write_ptr = (ssn & 0xff);
-	iwl_write_direct32(trans, HBUS_TARG_WRPTR,
+	iwl_write_direct32_dup(trans, HBUS_TARG_WRPTR,
 			   (ssn & 0xff) | (txq_id << 8));
 
 	if (cfg) {
 		u8 frame_limit = cfg->frame_limit;
 
-		iwl_write_prph(trans, SCD_QUEUE_RDPTR(txq_id), ssn);
+		iwl_write_prph_dup(trans, SCD_QUEUE_RDPTR(txq_id), ssn);
 
 		/* Set up Tx window size and frame limit for this queue */
 		iwl_trans_write_mem32(trans, trans_pcie->scd_base_addr +
@@ -1243,7 +1243,7 @@ void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, u16 ssn,
 					SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK));
 
 		/* Set up status area in SRAM, map to Tx DMA/FIFO, activate */
-		iwl_write_prph(trans, SCD_QUEUE_STATUS_BITS(txq_id),
+		iwl_write_prph_dup(trans, SCD_QUEUE_STATUS_BITS(txq_id),
 			       (1 << SCD_QUEUE_STTS_REG_POS_ACTIVE) |
 			       (cfg->fifo << SCD_QUEUE_STTS_REG_POS_TXF) |
 			       (1 << SCD_QUEUE_STTS_REG_POS_WSL) |
@@ -1360,7 +1360,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 			had_nocopy = true;
 			if (WARN_ON(cmd->dataflags[i] & IWL_HCMD_DFL_DUP)) {
 				idx = -EINVAL;
-				goto free_dup_buf;
+				goto free_buf;
 			}
 		} else if (cmd->dataflags[i] & IWL_HCMD_DFL_DUP) {
 			/*
@@ -1372,7 +1372,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 			/* only allowed once */
 			if (WARN_ON(dup_buf)) {
 				idx = -EINVAL;
-				goto free_dup_buf;
+				goto free_buf;
 			}
 
 			dup_buf = kmemdup(cmddata[i], cmdlen[i],
@@ -1383,7 +1383,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 			/* NOCOPY must not be followed by normal! */
 			if (WARN_ON(had_nocopy)) {
 				idx = -EINVAL;
-				goto free_dup_buf;
+				goto free_buf;
 			}
 			copy_size += cmdlen[i];
 		}
@@ -1400,7 +1400,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 		 "Command %s (%#x) is too large (%d bytes)\n",
 		 get_cmd_string(trans_pcie, cmd->id), cmd->id, copy_size)) {
 		idx = -EINVAL;
-		goto free_dup_buf;
+		goto free_buf;
 	}
 
 	spin_lock_bh(&txq->lock);
@@ -1411,7 +1411,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 		IWL_ERR(trans, "No space in command queue\n");
 		iwl_op_mode_cmd_queue_full(trans->op_mode);
 		idx = -ENOSPC;
-		goto free_dup_buf;
+		goto free_buf;
 	}
 
 	idx = get_cmd_index(q, q->write_ptr);
@@ -1550,7 +1550,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
 
  out:
 	spin_unlock_bh(&txq->lock);
- free_dup_buf:
+ free_buf:
 	if (idx < 0)
 		kfree(dup_buf);
 	return idx;
@@ -1699,7 +1699,7 @@ static int iwl_pcie_send_hcmd_sync(struct iwl_trans *trans,
 			       get_cmd_string(trans_pcie, cmd->id));
 		ret = -ETIMEDOUT;
 
-		iwl_force_nmi(trans);
+		iwl_force_nmi_dup(trans);
 		iwl_trans_fw_error(trans);
 
 		goto cancel;
@@ -1779,7 +1779,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
 	u16 len, tb1_len, tb2_len;
 	bool wait_write_ptr;
 	__le16 fc = hdr->frame_control;
-	u8 hdr_len = ieee80211_hdrlen(fc);
+	u8 hdr_len = ieee80211_hdrlen_dup(fc);
 	u16 wifi_seq;
 
 	txq = &trans_pcie->txq[txq_id];
--- a/include/linux/nl80211.h
+++ b/include/linux/nl80211.h
@@ -4382,7 +4382,7 @@ enum nl80211_crit_proto_id {
 /**
  * enum nl80211_rxmgmt_flags - flags for received management frame.
  *
- * Used by cfg80211_rx_mgmt()
+ * Used by cfg80211_rx_mgmt_dup()
  *
  * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
  */
--- a/include/net/cfg80211-wext.h
+++ b/include/net/cfg80211-wext.h
@@ -20,35 +20,35 @@
  * These are used only by drivers that aren't yet fully
  * converted to cfg80211.
  */
-int cfg80211_wext_giwname(struct net_device *dev,
+int cfg80211_wext_giwname_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  char *name, char *extra);
-int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_siwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_giwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_siwscan(struct net_device *dev,
+int cfg80211_wext_siwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *wrqu, char *extra);
-int cfg80211_wext_giwscan(struct net_device *dev,
+int cfg80211_wext_giwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_point *data, char *extra);
-int cfg80211_wext_giwrange(struct net_device *dev,
+int cfg80211_wext_giwrange_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_point *data, char *extra);
-int cfg80211_wext_siwrts(struct net_device *dev,
+int cfg80211_wext_siwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_giwrts(struct net_device *dev,
+int cfg80211_wext_giwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_siwfrag(struct net_device *dev,
+int cfg80211_wext_siwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwfrag(struct net_device *dev,
+int cfg80211_wext_giwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwretry(struct net_device *dev,
+int cfg80211_wext_giwretry_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_param *retry, char *extra);
 
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -393,14 +393,14 @@ cfg80211_get_chandef_type(const struct cfg80211_chan_def *chandef)
 }
 
 /**
- * cfg80211_chandef_create - create channel definition using channel type
+ * cfg80211_chandef_create_dup - create channel definition using channel type
  * @chandef: the channel definition struct to fill
  * @channel: the control channel
  * @chantype: the channel type
  *
  * Given a channel type, create a channel definition.
  */
-void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
+void cfg80211_chandef_create_dup(struct cfg80211_chan_def *chandef,
 			     struct ieee80211_channel *channel,
 			     enum nl80211_channel_type chantype);
 
@@ -423,7 +423,7 @@ cfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,
 }
 
 /**
- * cfg80211_chandef_compatible - check if two channel definitions are compatible
+ * cfg80211_chandef_compatible_dup - check if two channel definitions are compatible
  * @chandef1: first channel definition
  * @chandef2: second channel definition
  *
@@ -431,36 +431,36 @@ cfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,
  * chandef1 or chandef2 otherwise.
  */
 const struct cfg80211_chan_def *
-cfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,
+cfg80211_chandef_compatible_dup(const struct cfg80211_chan_def *chandef1,
 			    const struct cfg80211_chan_def *chandef2);
 
 /**
- * cfg80211_chandef_valid - check if a channel definition is valid
+ * cfg80211_chandef_valid_dup - check if a channel definition is valid
  * @chandef: the channel definition to check
  * Return: %true if the channel definition is valid. %false otherwise.
  */
-bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);
+bool cfg80211_chandef_valid_dup(const struct cfg80211_chan_def *chandef);
 
 /**
- * cfg80211_chandef_usable - check if secondary channels can be used
+ * cfg80211_chandef_usable_dup - check if secondary channels can be used
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @prohibited_flags: the regulatory channel flags that must not be set
  * Return: %true if secondary channels are usable. %false otherwise.
  */
-bool cfg80211_chandef_usable(struct wiphy *wiphy,
+bool cfg80211_chandef_usable_dup(struct wiphy *wiphy,
 			     const struct cfg80211_chan_def *chandef,
 			     u32 prohibited_flags);
 
 /**
- * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * cfg80211_chandef_dfs_required_dup - checks if radar detection is required
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @iftype: the interface type as specified in &enum nl80211_iftype
  * Returns:
  *	1 if radar detection is required, 0 if it is not, < 0 on error
  */
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+int cfg80211_chandef_dfs_required_dup(struct wiphy *wiphy,
 				  const struct cfg80211_chan_def *chandef,
 				  enum nl80211_iftype iftype);
 
@@ -849,7 +849,7 @@ enum cfg80211_station_type {
 };
 
 /**
- * cfg80211_check_station_change - validate parameter changes
+ * cfg80211_check_station_change_dup - validate parameter changes
  * @wiphy: the wiphy this operates on
  * @params: the new parameters for a station
  * @statype: the type of station being modified
@@ -860,7 +860,7 @@ enum cfg80211_station_type {
  * not will return an error code. Note that it may modify the parameters for
  * backward compatibility reasons, so don't use them before calling this.
  */
-int cfg80211_check_station_change(struct wiphy *wiphy,
+int cfg80211_check_station_change_dup(struct wiphy *wiphy,
 				  struct station_parameters *params,
 				  enum cfg80211_station_type statype);
 
@@ -1046,7 +1046,7 @@ struct sta_bss_parameters {
  * @assoc_req_ies: IEs from (Re)Association Request.
  *	This is used only when in AP mode with drivers that do not use
  *	user space MLME/SME implementation. The information is provided for
- *	the cfg80211_new_sta() calls to notify user space of the IEs.
+ *	the cfg80211_new_sta_dup() calls to notify user space of the IEs.
  * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
  * @sta_flags: station flags mask & values
  * @beacon_loss_count: Number of times beacon loss event has triggered.
@@ -1108,7 +1108,7 @@ struct station_info {
 };
 
 /**
- * cfg80211_get_station - retrieve information about a given station
+ * cfg80211_get_station_dup - retrieve information about a given station
  * @dev: the device where the station is supposed to be connected to
  * @mac_addr: the mac address of the station of interest
  * @sinfo: pointer to the structure to fill with the information
@@ -1117,7 +1117,7 @@ struct station_info {
  * otherwise returns a negative error code and the content of sinfo has to be
  * considered undefined.
  */
-int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+int cfg80211_get_station_dup(struct net_device *dev, const u8 *mac_addr,
 			 struct station_info *sinfo);
 
 /**
@@ -1630,7 +1630,7 @@ struct cfg80211_bss {
 };
 
 /**
- * ieee80211_bss_get_ie - find IE with given ID
+ * ieee80211_bss_get_ie_dup - find IE with given ID
  * @bss: the bss to search
  * @ie: the IE ID
  *
@@ -1638,7 +1638,7 @@ struct cfg80211_bss {
  * rcu_read_lock() must be held when calling this function.
  * Return: %NULL if not found.
  */
-const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie);
+const u8 *ieee80211_bss_get_ie_dup(struct cfg80211_bss *bss, u8 ie);
 
 
 /**
@@ -1690,7 +1690,7 @@ enum cfg80211_assoc_req_flags {
  * (re)association.
  * @bss: The BSS to associate with. If the call is successful the driver is
  *	given a reference that it must give back to cfg80211_send_rx_assoc()
- *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
+ *	or to cfg80211_assoc_timeout_dup(). To ensure proper refcounting, new
  *	association requests while already associating must be rejected.
  * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
  * @ie_len: Length of ie buffer in octets
@@ -2235,7 +2235,7 @@ struct cfg80211_qos_map {
  *	validated in cfg80211, in particular the auth/assoc/authorized flags
  *	might come to the driver in invalid combinations -- make sure to check
  *	them, also against the existing state! Drivers must call
- *	cfg80211_check_station_change() to validate the information.
+ *	cfg80211_check_station_change_dup() to validate the information.
  * @get_station: get station information for the station identified by @mac
  * @dump_station: dump station callback -- resume dump at index @idx
  *
@@ -2271,7 +2271,7 @@ struct cfg80211_qos_map {
  *	be stored for when a monitor interface becomes active.
  *
  * @scan: Request to do a scan. If returning zero, the scan request is given
- *	the driver, and will be valid until passed to cfg80211_scan_done().
+ *	the driver, and will be valid until passed to cfg80211_scan_done_dup().
  *	For scan results, call cfg80211_inform_bss(); you can call this outside
  *	the scan/scan_done bracket too.
  *
@@ -2285,15 +2285,15 @@ struct cfg80211_qos_map {
  *	(invoked with the wireless_dev mutex held)
  *
  * @connect: Connect to the ESS with the specified parameters. When connected,
- *	call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.
- *	If the connection fails for some reason, call cfg80211_connect_result()
+ *	call cfg80211_connect_result_dup() with status code %WLAN_STATUS_SUCCESS.
+ *	If the connection fails for some reason, call cfg80211_connect_result_dup()
  *	with the status from the AP.
  *	(invoked with the wireless_dev mutex held)
  * @disconnect: Disconnect from the BSS/ESS.
  *	(invoked with the wireless_dev mutex held)
  *
  * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
- *	cfg80211_ibss_joined(), also call that function when changing BSSID due
+ *	cfg80211_ibss_joined_dup(), also call that function when changing BSSID due
  *	to a merge.
  *	(invoked with the wireless_dev mutex held)
  * @leave_ibss: Leave the IBSS.
@@ -2326,7 +2326,7 @@ struct cfg80211_qos_map {
  *	channel for the specified duration to complete an off-channel
  *	operation (e.g., public action frame exchange). When the driver is
  *	ready on the requested channel, it must indicate this with an event
- *	notification by calling cfg80211_ready_on_channel().
+ *	notification by calling cfg80211_ready_on_channel_dup().
  * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
  *	This allows the operation to be terminated prior to timeout based on
  *	the duration value.
@@ -2359,7 +2359,7 @@ struct cfg80211_qos_map {
  *	call must stop the scheduled scan and be ready for starting a new one
  *	before it returns, i.e. @sched_scan_start may be called immediately
  *	after that again and should not fail in that case. The driver should
- *	not call cfg80211_sched_scan_stopped() for a requested stop (when this
+ *	not call cfg80211_sched_scan_stopped_dup() for a requested stop (when this
  *	method returns 0.)
  *
  * @mgmt_frame_register: Notify driver that a management frame type was
@@ -2377,7 +2377,7 @@ struct cfg80211_qos_map {
  * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
  *
  * @probe_client: probe an associated client, must return a cookie that it
- *	later passes to cfg80211_probe_status().
+ *	later passes to cfg80211_probe_status_dup().
  *
  * @set_noack_map: Set the NoAck Map for the TIDs.
  *
@@ -2411,7 +2411,7 @@ struct cfg80211_qos_map {
  * @channel_switch: initiate channel-switch procedure (with CSA). Driver is
  *	responsible for veryfing if the switch is possible. Since this is
  *	inherently tricky driver may decide to disconnect an interface later
- *	with cfg80211_stop_iface(). This doesn't mean driver can accept
+ *	with cfg80211_stop_iface_dup(). This doesn't mean driver can accept
  *	everything. It should do it's best to verify requests and reject them
  *	as soon as possible.
  *
@@ -2743,7 +2743,7 @@ struct cfg80211_ops {
  * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
  * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
  *	when there are virtual interfaces in AP mode by calling
- *	cfg80211_report_obss_beacon().
+ *	cfg80211_report_obss_beacon_dup().
  * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device
  *	responds to probe-requests in hardware.
  * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
@@ -2976,10 +2976,10 @@ struct wiphy_vendor_command {
 /**
  * struct wiphy - wireless hardware description
  * @reg_notifier: the driver's regulatory notification callback,
- *	note that if your driver uses wiphy_apply_custom_regulatory()
+ *	note that if your driver uses wiphy_apply_custom_regulatory_dup()
  *	the reg_notifier's request can be passed as NULL
  * @regd: the driver's regulatory domain, if one was requested via
- * 	the regulatory_hint() API. This can be used by the driver
+ * 	the regulatory_hint_dup() API. This can be used by the driver
  *	on the reg_notifier() if it chooses to ignore future
  *	regulatory domain changes caused by other drivers.
  * @signal_type: signal type reported in &struct cfg80211_bss.
@@ -3298,7 +3298,7 @@ static inline const char *wiphy_name(const struct wiphy *wiphy)
 }
 
 /**
- * wiphy_new_nm - create a new wiphy for use with cfg80211
+ * wiphy_new_nm_dup - create a new wiphy for use with cfg80211
  *
  * @ops: The configuration operations for this device
  * @sizeof_priv: The size of the private area to allocate
@@ -3311,7 +3311,7 @@ static inline const char *wiphy_name(const struct wiphy *wiphy)
  * Return: A pointer to the new wiphy. This pointer must be
  * assigned to each netdev's ieee80211_ptr for proper operation.
  */
-struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+struct wiphy *wiphy_new_nm_dup(const struct cfg80211_ops *ops, int sizeof_priv,
 			   const char *requested_name);
 
 /**
@@ -3329,20 +3329,20 @@ struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
 static inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,
 				      int sizeof_priv)
 {
-	return wiphy_new_nm(ops, sizeof_priv, NULL);
+	return wiphy_new_nm_dup(ops, sizeof_priv, NULL);
 }
 
 /**
- * wiphy_register - register a wiphy with cfg80211
+ * wiphy_register_dup - register a wiphy with cfg80211
  *
  * @wiphy: The wiphy to register.
  *
  * Return: A non-negative wiphy index or a negative error code.
  */
-int wiphy_register(struct wiphy *wiphy);
+int wiphy_register_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_unregister - deregister a wiphy from cfg80211
+ * wiphy_unregister_dup - deregister a wiphy from cfg80211
  *
  * @wiphy: The wiphy to unregister.
  *
@@ -3350,14 +3350,14 @@ int wiphy_register(struct wiphy *wiphy);
  * pointer, but the call may sleep to wait for an outstanding
  * request that is being handled.
  */
-void wiphy_unregister(struct wiphy *wiphy);
+void wiphy_unregister_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_free - free wiphy
+ * wiphy_free_dup - free wiphy
  *
  * @wiphy: The wiphy to free
  */
-void wiphy_free(struct wiphy *wiphy);
+void wiphy_free_dup(struct wiphy *wiphy);
 
 /* internal structs */
 struct cfg80211_conn;
@@ -3512,19 +3512,19 @@ static inline void *wdev_priv(struct wireless_dev *wdev)
  */
 
 /**
- * ieee80211_channel_to_frequency - convert channel number to frequency
+ * ieee80211_channel_to_frequency_dup - convert channel number to frequency
  * @chan: channel number
  * @band: band, necessary due to channel number overlap
  * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
  */
-int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);
+int ieee80211_channel_to_frequency_dup(int chan, enum ieee80211_band band);
 
 /**
- * ieee80211_frequency_to_channel - convert frequency to channel number
+ * ieee80211_frequency_to_channel_dup - convert frequency to channel number
  * @freq: center frequency
  * Return: The corresponding channel, or 0 if the conversion failed.
  */
-int ieee80211_frequency_to_channel(int freq);
+int ieee80211_frequency_to_channel_dup(int freq);
 
 /*
  * Name indirection necessary because the ieee80211 code also has
@@ -3533,7 +3533,7 @@ int ieee80211_frequency_to_channel(int freq);
  * to include both header files you'll (rightfully!) get a symbol
  * clash.
  */
-struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
+struct ieee80211_channel *__ieee80211_get_channel_dup(struct wiphy *wiphy,
 						  int freq);
 /**
  * ieee80211_get_channel - get channel struct from wiphy for specified frequency
@@ -3544,11 +3544,11 @@ struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
 static inline struct ieee80211_channel *
 ieee80211_get_channel(struct wiphy *wiphy, int freq)
 {
-	return __ieee80211_get_channel(wiphy, freq);
+	return __ieee80211_get_channel_dup(wiphy, freq);
 }
 
 /**
- * ieee80211_get_response_rate - get basic rate for a given rate
+ * ieee80211_get_response_rate_dup - get basic rate for a given rate
  *
  * @sband: the band to look for rates in
  * @basic_rates: bitmap of basic rates
@@ -3560,18 +3560,18 @@ ieee80211_get_channel(struct wiphy *wiphy, int freq)
  * rates in the band's bitrate table.
  */
 struct ieee80211_rate *
-ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
+ieee80211_get_response_rate_dup(struct ieee80211_supported_band *sband,
 			    u32 basic_rates, int bitrate);
 
 /**
- * ieee80211_mandatory_rates - get mandatory rates for a given band
+ * ieee80211_mandatory_rates_dup - get mandatory rates for a given band
  * @sband: the band to look for rates in
  * @scan_width: width of the control channel
  *
  * This function returns a bitmap of the mandatory rates for the given
  * band, bits are set according to the rate position in the bitrates array.
  */
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+u32 ieee80211_mandatory_rates_dup(struct ieee80211_supported_band *sband,
 			      enum nl80211_bss_scan_width scan_width);
 
 /*
@@ -3600,10 +3600,10 @@ struct ieee80211_radiotap_vendor_namespaces {
 /**
  * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args
  * @this_arg_index: index of current arg, valid after each successful call
- *	to ieee80211_radiotap_iterator_next()
+ *	to ieee80211_radiotap_iterator_next_dup()
  * @this_arg: pointer to current radiotap arg; it is valid after each
- *	call to ieee80211_radiotap_iterator_next() but also after
- *	ieee80211_radiotap_iterator_init() where it will point to
+ *	call to ieee80211_radiotap_iterator_next_dup() but also after
+ *	ieee80211_radiotap_iterator_init_dup() where it will point to
  *	the beginning of the actual data portion
  * @this_arg_size: length of the current arg, for convenience
  * @current_namespace: pointer to the current namespace definition
@@ -3647,20 +3647,20 @@ struct ieee80211_radiotap_iterator {
 };
 
 int
-ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
+ieee80211_radiotap_iterator_init_dup(struct ieee80211_radiotap_iterator *iterator,
 				 struct ieee80211_radiotap_header *radiotap_header,
 				 int max_length,
 				 const struct ieee80211_radiotap_vendor_namespaces *vns);
 
 int
-ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);
+ieee80211_radiotap_iterator_next_dup(struct ieee80211_radiotap_iterator *iterator);
 
 
-extern const unsigned char rfc1042_header[6];
-extern const unsigned char bridge_tunnel_header[6];
+extern const unsigned char rfc1042_header_dup[6];
+extern const unsigned char bridge_tunnel_header_dup[6];
 
 /**
- * ieee80211_get_hdrlen_from_skb - get header length from data
+ * ieee80211_get_hdrlen_from_skb_dup - get header length from data
  *
  * @skb: the frame
  *
@@ -3671,23 +3671,23 @@ extern const unsigned char bridge_tunnel_header[6];
  * headers). Or 0 if the data in the sk_buff is too short to contain a valid
  * 802.11 header.
  */
-unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);
+unsigned int ieee80211_get_hdrlen_from_skb_dup(const struct sk_buff *skb);
 
 /**
- * ieee80211_hdrlen - get header length in bytes from frame control
+ * ieee80211_hdrlen_dup - get header length in bytes from frame control
  * @fc: frame control field in little-endian format
  * Return: The header length in bytes.
  */
-unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);
+unsigned int __attribute_const__ ieee80211_hdrlen_dup(__le16 fc);
 
 /**
- * ieee80211_get_mesh_hdrlen - get mesh extension header length
+ * ieee80211_get_mesh_hdrlen_dup - get mesh extension header length
  * @meshhdr: the mesh extension header, only the flags field
  *	(first byte) will be accessed
  * Return: The length of the extension header, which is always at
  * least 6 bytes and at most 18 if address 5 and 6 are present.
  */
-unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);
+unsigned int ieee80211_get_mesh_hdrlen_dup(struct ieee80211s_hdr *meshhdr);
 
 /**
  * DOC: Data path helpers
@@ -3698,17 +3698,17 @@ unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);
  */
 
 /**
- * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
+ * ieee80211_data_to_8023_dup - convert an 802.11 data frame to 802.3
  * @skb: the 802.11 data frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
  * Return: 0 on success. Non-zero on error.
  */
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_to_8023_dup(struct sk_buff *skb, const u8 *addr,
 			   enum nl80211_iftype iftype);
 
 /**
- * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11
+ * ieee80211_data_from_8023_dup - convert an 802.3 frame to 802.11
  * @skb: the 802.3 frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
@@ -3716,12 +3716,12 @@ int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
  * @qos: build 802.11 QoS data frame
  * Return: 0 on success, or a negative error code.
  */
-int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_from_8023_dup(struct sk_buff *skb, const u8 *addr,
 			     enum nl80211_iftype iftype, const u8 *bssid,
 			     bool qos);
 
 /**
- * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
+ * ieee80211_amsdu_to_8023s_dup - decode an IEEE 802.11n A-MSDU frame
  *
  * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
  * 802.3 frames. The @list will be empty if the decode fails. The
@@ -3735,22 +3735,22 @@ int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
  * @extra_headroom: The hardware extra headroom for SKBs in the @list.
  * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.
  */
-void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
+void ieee80211_amsdu_to_8023s_dup(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
 			      bool has_80211_header);
 
 /**
- * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
+ * cfg80211_classify8021d_dup - determine the 802.1p/1d tag for a data frame
  * @skb: the data frame
  * @qos_map: Interworking QoS mapping or %NULL if not in use
  * Return: The 802.1p/1d tag.
  */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+unsigned int cfg80211_classify8021d_dup(struct sk_buff *skb,
 				    struct cfg80211_qos_map *qos_map);
 
 /**
- * cfg80211_find_ie - find information element in data
+ * cfg80211_find_ie_dup - find information element in data
  *
  * @eid: element ID
  * @ies: data consisting of IEs
@@ -3764,10 +3764,10 @@ unsigned int cfg80211_classify8021d(struct sk_buff *skb,
  * Note: There are no checks on the element length other than
  * having to fit into the given data.
  */
-const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len);
+const u8 *cfg80211_find_ie_dup(u8 eid, const u8 *ies, int len);
 
 /**
- * cfg80211_find_vendor_ie - find vendor specific information element in data
+ * cfg80211_find_vendor_ie_dup - find vendor specific information element in data
  *
  * @oui: vendor OUI
  * @oui_type: vendor-specific OUI type
@@ -3782,7 +3782,7 @@ const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len);
  * Note: There are no checks on the element length other than having to fit into
  * the given data.
  */
-const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
+const u8 *cfg80211_find_vendor_ie_dup(unsigned int oui, u8 oui_type,
 				  const u8 *ies, int len);
 
 /**
@@ -3792,7 +3792,7 @@ const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
  */
 
 /**
- * regulatory_hint - driver hint to the wireless core a regulatory domain
+ * regulatory_hint_dup - driver hint to the wireless core a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
  * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
@@ -3808,18 +3808,18 @@ const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
  * for a regulatory domain structure for the respective country.
  *
  * The wiphy must have been registered to cfg80211 prior to this call.
- * For cfg80211 drivers this means you must first use wiphy_register(),
- * for mac80211 drivers you must first use ieee80211_register_hw().
+ * For cfg80211 drivers this means you must first use wiphy_register_dup(),
+ * for mac80211 drivers you must first use ieee80211_register_hw_dup().
  *
  * Drivers should check the return value, its possible you can get
  * an -ENOMEM.
  *
  * Return: 0 on success. -ENOMEM.
  */
-int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
+int regulatory_hint_dup(struct wiphy *wiphy, const char *alpha2);
 
 /**
- * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
+ * wiphy_apply_custom_regulatory_dup - apply a custom driver regulatory domain
  * @wiphy: the wireless device we want to process the regulatory domain on
  * @regd: the custom regulatory domain to use for this wiphy
  *
@@ -3833,11 +3833,11 @@ int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
  * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
  * that called this helper.
  */
-void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+void wiphy_apply_custom_regulatory_dup(struct wiphy *wiphy,
 				   const struct ieee80211_regdomain *regd);
 
 /**
- * freq_reg_info - get regulatory information for the given frequency
+ * freq_reg_info_dup - get regulatory information for the given frequency
  * @wiphy: the wiphy for which we want to process this rule for
  * @center_freq: Frequency in KHz for which we want regulatory information for
  *
@@ -3854,17 +3854,17 @@ void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
  * See freq_in_rule_band() for our current definition of a band -- this is
  * purely subjective and right now it's 802.11 specific.
  */
-const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
+const struct ieee80211_reg_rule *freq_reg_info_dup(struct wiphy *wiphy,
 					       u32 center_freq);
 
 /**
- * reg_initiator_name - map regulatory request initiator enum to name
+ * reg_initiator_name_dup - map regulatory request initiator enum to name
  * @initiator: the regulatory request initiator
  *
  * You can use this to map the regulatory request initiator enum to a
  * proper string representation.
  */
-const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
+const char *reg_initiator_name_dup(enum nl80211_reg_initiator initiator);
 
 /*
  * callbacks for asynchronous cfg80211 methods, notification
@@ -3872,23 +3872,23 @@ const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
  */
 
 /**
- * cfg80211_scan_done - notify that scan finished
+ * cfg80211_scan_done_dup - notify that scan finished
  *
  * @request: the corresponding scan request
  * @aborted: set to true if the scan was aborted for any reason,
  *	userspace will be notified of that
  */
-void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted);
+void cfg80211_scan_done_dup(struct cfg80211_scan_request *request, bool aborted);
 
 /**
- * cfg80211_sched_scan_results - notify that new scan results are available
+ * cfg80211_sched_scan_results_dup - notify that new scan results are available
  *
  * @wiphy: the wiphy which got scheduled scan results
  */
-void cfg80211_sched_scan_results(struct wiphy *wiphy);
+void cfg80211_sched_scan_results_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3896,10 +3896,10 @@ void cfg80211_sched_scan_results(struct wiphy *wiphy);
  * scheduled scan had to be stopped, for whatever reason.  The driver
  * is then called back via the sched_scan_stop operation when done.
  */
-void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_rtnl_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3908,10 +3908,10 @@ void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
  * is then called back via the sched_scan_stop operation when done.
  * This function should be called with rtnl locked.
  */
-void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_rtnl_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_inform_bss_width_frame - inform cfg80211 of a received BSS frame
+ * cfg80211_inform_bss_width_frame_dup - inform cfg80211 of a received BSS frame
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3924,11 +3924,11 @@ void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+cfg80211_inform_bss_width_frame_dup(struct wiphy *wiphy,
 				struct ieee80211_channel *rx_channel,
 				enum nl80211_bss_scan_width scan_width,
 				struct ieee80211_mgmt *mgmt, size_t len,
@@ -3940,7 +3940,7 @@ cfg80211_inform_bss_frame(struct wiphy *wiphy,
 			  struct ieee80211_mgmt *mgmt, size_t len,
 			  s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width_frame(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_frame_dup(wiphy, rx_channel,
 					       NL80211_BSS_CHAN_WIDTH_20,
 					       mgmt, len, signal, gfp);
 }
@@ -3959,7 +3959,7 @@ enum cfg80211_bss_frame_type {
 };
 
 /**
- * cfg80211_inform_bss_width - inform cfg80211 of a new BSS
+ * cfg80211_inform_bss_width_dup - inform cfg80211 of a new BSS
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3977,11 +3977,11 @@ enum cfg80211_bss_frame_type {
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width(struct wiphy *wiphy,
+cfg80211_inform_bss_width_dup(struct wiphy *wiphy,
 			  struct ieee80211_channel *rx_channel,
 			  enum nl80211_bss_scan_width scan_width,
 			  enum cfg80211_bss_frame_type ftype,
@@ -3997,14 +3997,14 @@ cfg80211_inform_bss(struct wiphy *wiphy,
 		    u16 beacon_interval, const u8 *ie, size_t ielen,
 		    s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_dup(wiphy, rx_channel,
 					 NL80211_BSS_CHAN_WIDTH_20, ftype,
 					 bssid, tsf, capability,
 					 beacon_interval, ie, ielen, signal,
 					 gfp);
 }
 
-struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+struct cfg80211_bss *cfg80211_get_bss_dup(struct wiphy *wiphy,
 				      struct ieee80211_channel *channel,
 				      const u8 *bssid,
 				      const u8 *ssid, size_t ssid_len,
@@ -4014,30 +4014,30 @@ cfg80211_get_ibss(struct wiphy *wiphy,
 		  struct ieee80211_channel *channel,
 		  const u8 *ssid, size_t ssid_len)
 {
-	return cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,
+	return cfg80211_get_bss_dup(wiphy, channel, NULL, ssid, ssid_len,
 				WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
 }
 
 /**
- * cfg80211_ref_bss - reference BSS struct
+ * cfg80211_ref_bss_dup - reference BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct to reference
  *
  * Increments the refcount of the given BSS struct.
  */
-void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_ref_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_put_bss - unref BSS struct
+ * cfg80211_put_bss_dup - unref BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct
  *
  * Decrements the refcount of the given BSS struct.
  */
-void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_put_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_unlink_bss - unlink BSS from internal data structures
+ * cfg80211_unlink_bss_dup - unlink BSS from internal data structures
  * @wiphy: the wiphy
  * @bss: the bss to remove
  *
@@ -4046,7 +4046,7 @@ void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
  * function when you detect a BSS is gone. Normally BSSes will also time
  * out, so it is not necessary to use this function at all.
  */
-void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_unlink_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 static inline enum nl80211_bss_scan_width
 cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
@@ -4062,7 +4062,7 @@ cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
 }
 
 /**
- * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
+ * cfg80211_rx_mlme_mgmt_dup - notification of processed MLME management frame
  * @dev: network device
  * @buf: authentication frame (header + body)
  * @len: length of the frame data
@@ -4070,30 +4070,30 @@ cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
  * This function is called whenever an authentication, disassociation or
  * deauthentication frame has been received and processed in station mode.
  * After being asked to authenticate via cfg80211_ops::auth() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * While connected, the driver must calls this for received and processed
  * disassociation and deauthentication frames. If the frame couldn't be used
  * because it was unprotected, the driver must call the function
- * cfg80211_rx_unprot_mlme_mgmt() instead.
+ * cfg80211_rx_unprot_mlme_mgmt_dup() instead.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_rx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_auth_timeout - notification of timed out authentication
+ * cfg80211_auth_timeout_dup - notification of timed out authentication
  * @dev: network device
  * @addr: The MAC address of the device with which the authentication timed out
  *
  * This function may sleep. The caller must hold the corresponding wdev's
  * mutex.
  */
-void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
+void cfg80211_auth_timeout_dup(struct net_device *dev, const u8 *addr);
 
 /**
- * cfg80211_rx_assoc_resp - notification of processed association response
+ * cfg80211_rx_assoc_resp_dup - notification of processed association response
  * @dev: network device
  * @bss: the BSS that association was requested with, ownership of the pointer
  *	moves to cfg80211 in this call
@@ -4102,26 +4102,26 @@ void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
  * @uapsd_queues: bitmap of ACs configured to uapsd. -1 if n/a.
  *
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_assoc_resp(struct net_device *dev,
+void cfg80211_rx_assoc_resp_dup(struct net_device *dev,
 			    struct cfg80211_bss *bss,
 			    const u8 *buf, size_t len,
 			    int uapsd_queues);
 
 /**
- * cfg80211_assoc_timeout - notification of timed out association
+ * cfg80211_assoc_timeout_dup - notification of timed out association
  * @dev: network device
  * @bss: The BSS entry with which association timed out.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
+void cfg80211_assoc_timeout_dup(struct net_device *dev, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
+ * cfg80211_tx_mlme_mgmt_dup - notification of transmitted deauth/disassoc frame
  * @dev: network device
  * @buf: 802.11 frame (header + body)
  * @len: length of the frame data
@@ -4131,10 +4131,10 @@ void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
  * locally generated ones. This function may sleep. The caller must hold the
  * corresponding wdev's mutex.
  */
-void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_tx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
+ * cfg80211_rx_unprot_mlme_mgmt_dup - notification of unprotected mlme mgmt frame
  * @dev: network device
  * @buf: deauthentication frame (header + body)
  * @len: length of the frame data
@@ -4143,11 +4143,11 @@ void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
  * frame has been dropped in station mode because of MFP being used but the
  * frame was not protected. This function may sleep.
  */
-void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
+void cfg80211_rx_unprot_mlme_mgmt_dup(struct net_device *dev,
 				  const u8 *buf, size_t len);
 
 /**
- * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
+ * cfg80211_michael_mic_failure_dup - notification of Michael MIC failure (TKIP)
  * @dev: network device
  * @addr: The source MAC address of the frame
  * @key_type: The key type that the received frame used
@@ -4159,12 +4159,12 @@ void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
  * received frame. This matches with MLME-MICHAELMICFAILURE.indication()
  * primitive.
  */
-void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
+void cfg80211_michael_mic_failure_dup(struct net_device *dev, const u8 *addr,
 				  enum nl80211_key_type key_type, int key_id,
 				  const u8 *tsc, gfp_t gfp);
 
 /**
- * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS
+ * cfg80211_ibss_joined_dup - notify cfg80211 that device joined an IBSS
  *
  * @dev: network device
  * @bssid: the BSSID of the IBSS joined
@@ -4178,7 +4178,7 @@ void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
  * with the locally generated beacon -- this guarantees that there is
  * always a scan result for this IBSS. cfg80211 will handle the rest.
  */
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			  struct ieee80211_channel *channel, gfp_t gfp);
 
 /**
@@ -4194,7 +4194,7 @@ void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
  * detected, most likely via a beacon or, less likely, via a probe response.
  * cfg80211 then sends a notification to userspace.
  */
-void cfg80211_notify_new_peer_candidate(struct net_device *dev,
+void cfg80211_notify_new_peer_candidate_dup(struct net_device *dev,
 		const u8 *macaddr, const u8 *ie, u8 ie_len, gfp_t gfp);
 
 /**
@@ -4212,23 +4212,23 @@ void cfg80211_notify_new_peer_candidate(struct net_device *dev,
  */
 
 /**
- * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state
+ * wiphy_rfkill_set_hw_state_dup - notify cfg80211 about hw block state
  * @wiphy: the wiphy
  * @blocked: block status
  */
-void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);
+void wiphy_rfkill_set_hw_state_dup(struct wiphy *wiphy, bool blocked);
 
 /**
- * wiphy_rfkill_start_polling - start polling rfkill
+ * wiphy_rfkill_start_polling_dup - start polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_start_polling(struct wiphy *wiphy);
+void wiphy_rfkill_start_polling_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_rfkill_stop_polling - stop polling rfkill
+ * wiphy_rfkill_stop_polling_dup - stop polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
+void wiphy_rfkill_stop_polling_dup(struct wiphy *wiphy);
 
 /**
  * DOC: Vendor commands
@@ -4250,18 +4250,18 @@ void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
  * managers etc. need.
  */
 
-struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_reply_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int approxlen);
 
-struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_event_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int vendor_event_idx,
 					   int approxlen, gfp_t gfp);
 
-void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
+void __cfg80211_send_event_skb_dup(struct sk_buff *skb, gfp_t gfp);
 
 /**
  * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
@@ -4281,7 +4281,7 @@ void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
  * which can then read that data out of the vendor data attribute.
  * You must not modify the skb in any other way.
  *
- * When done, call cfg80211_vendor_cmd_reply() with the skb and return
+ * When done, call cfg80211_vendor_cmd_reply_dup() with the skb and return
  * its error code as the result of the doit() operation.
  *
  * Return: An allocated and pre-filled skb. %NULL if any errors happen.
@@ -4289,12 +4289,12 @@ void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
 static inline struct sk_buff *
 cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA, approxlen);
 }
 
 /**
- * cfg80211_vendor_cmd_reply - send the reply skb
+ * cfg80211_vendor_cmd_reply_dup - send the reply skb
  * @skb: The skb, must have been allocated with
  *	cfg80211_vendor_cmd_alloc_reply_skb()
  *
@@ -4305,7 +4305,7 @@ cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
  *
  * Return: An error code or 0 on success.
  */
-int cfg80211_vendor_cmd_reply(struct sk_buff *skb);
+int cfg80211_vendor_cmd_reply_dup(struct sk_buff *skb);
 
 /**
  * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
@@ -4327,7 +4327,7 @@ static inline struct sk_buff *
 cfg80211_vendor_event_alloc(struct wiphy *wiphy, int approxlen,
 			    int event_idx, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA,
 					  event_idx, approxlen, gfp);
 }
@@ -4342,7 +4342,7 @@ cfg80211_vendor_event_alloc(struct wiphy *wiphy, int approxlen,
  */
 static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #ifdef CONFIG_NL80211_TESTMODE
@@ -4383,7 +4383,7 @@ static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
 static inline struct sk_buff *
 cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, approxlen);
 }
 
@@ -4401,7 +4401,7 @@ cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
  */
 static inline int cfg80211_testmode_reply(struct sk_buff *skb)
 {
-	return cfg80211_vendor_cmd_reply(skb);
+	return cfg80211_vendor_cmd_reply_dup(skb);
 }
 
 /**
@@ -4428,7 +4428,7 @@ static inline int cfg80211_testmode_reply(struct sk_buff *skb)
 static inline struct sk_buff *
 cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, -1,
 					  approxlen, gfp);
 }
@@ -4445,7 +4445,7 @@ cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
  */
 static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),
@@ -4456,7 +4456,7 @@ static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
 #endif
 
 /**
- * cfg80211_connect_result - notify cfg80211 of connection result
+ * cfg80211_connect_result_dup - notify cfg80211 of connection result
  *
  * @dev: network device
  * @bssid: the BSSID of the AP
@@ -4472,13 +4472,13 @@ static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
  * It should be called by the underlying driver whenever connect() has
  * succeeded.
  */
-void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			     const u8 *req_ie, size_t req_ie_len,
 			     const u8 *resp_ie, size_t resp_ie_len,
 			     u16 status, gfp_t gfp);
 
 /**
- * cfg80211_roamed - notify cfg80211 of roaming
+ * cfg80211_roamed_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @channel: the channel of the new AP
@@ -4492,14 +4492,14 @@ void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
  * It should be called by the underlying driver whenever it roamed
  * from one AP to another while connected.
  */
-void cfg80211_roamed(struct net_device *dev,
+void cfg80211_roamed_dup(struct net_device *dev,
 		     struct ieee80211_channel *channel,
 		     const u8 *bssid,
 		     const u8 *req_ie, size_t req_ie_len,
 		     const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_roamed_bss - notify cfg80211 of roaming
+ * cfg80211_roamed_bss_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @bss: entry of bss to which STA got roamed
@@ -4515,17 +4515,17 @@ void cfg80211_roamed(struct net_device *dev,
  * while connected. Drivers which have roaming implemented in firmware
  * may use this function to avoid a race in bss entry timeout where the bss
  * entry of the new AP is seen in the driver, but gets timed out by the time
- * it is accessed in __cfg80211_roamed() due to delay in scheduling
+ * it is accessed in __cfg80211_roamed_dup() due to delay in scheduling
  * rdev->event_work. In case of any failures, the reference is released
- * either in cfg80211_roamed_bss() or in __cfg80211_romed(), Otherwise,
+ * either in cfg80211_roamed_bss_dup() or in __cfg80211_romed(), Otherwise,
  * it will be released while diconneting from the current bss.
  */
-void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_roamed_bss_dup(struct net_device *dev, struct cfg80211_bss *bss,
 			 const u8 *req_ie, size_t req_ie_len,
 			 const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_disconnected - notify cfg80211 that connection was dropped
+ * cfg80211_disconnected_dup - notify cfg80211 that connection was dropped
  *
  * @dev: network device
  * @ie: information elements of the deauth/disassoc frame (may be %NULL)
@@ -4536,11 +4536,11 @@ void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
  * After it calls this function, the driver should enter an idle state
  * and not try to connect to any AP any more.
  */
-void cfg80211_disconnected(struct net_device *dev, u16 reason,
+void cfg80211_disconnected_dup(struct net_device *dev, u16 reason,
 			   const u8 *ie, size_t ie_len, gfp_t gfp);
 
 /**
- * cfg80211_ready_on_channel - notification of remain_on_channel start
+ * cfg80211_ready_on_channel_dup - notification of remain_on_channel start
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
@@ -4548,44 +4548,44 @@ void cfg80211_disconnected(struct net_device *dev, u16 reason,
  *	channel
  * @gfp: allocation flags
  */
-void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_ready_on_channel_dup(struct wireless_dev *wdev, u64 cookie,
 			       struct ieee80211_channel *chan,
 			       unsigned int duration, gfp_t gfp);
 
 /**
- * cfg80211_remain_on_channel_expired - remain_on_channel duration expired
+ * cfg80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
  * @gfp: allocation flags
  */
-void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_remain_on_channel_expired_dup(struct wireless_dev *wdev, u64 cookie,
 					struct ieee80211_channel *chan,
 					gfp_t gfp);
 
 
 /**
- * cfg80211_new_sta - notify userspace about station
+ * cfg80211_new_sta_dup - notify userspace about station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @sinfo: the station information
  * @gfp: allocation flags
  */
-void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_new_sta_dup(struct net_device *dev, const u8 *mac_addr,
 		      struct station_info *sinfo, gfp_t gfp);
 
 /**
- * cfg80211_del_sta - notify userspace about deletion of a station
+ * cfg80211_del_sta_dup - notify userspace about deletion of a station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @gfp: allocation flags
  */
-void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
+void cfg80211_del_sta_dup(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
 
 /**
- * cfg80211_conn_failed - connection request failed notification
+ * cfg80211_conn_failed_dup - connection request failed notification
  *
  * @dev: the netdev
  * @mac_addr: the station's address
@@ -4599,12 +4599,12 @@ void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
  * The reason for connection failure can be any of the value from
  * nl80211_connect_failed_reason enum
  */
-void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_conn_failed_dup(struct net_device *dev, const u8 *mac_addr,
 			  enum nl80211_connect_failed_reason reason,
 			  gfp_t gfp);
 
 /**
- * cfg80211_rx_mgmt - notification of received, unprocessed management frame
+ * cfg80211_rx_mgmt_dup - notification of received, unprocessed management frame
  * @wdev: wireless device receiving the frame
  * @freq: Frequency on which the frame was received in MHz
  * @sig_dbm: signal strength in mBm, or 0 if unknown
@@ -4620,11 +4620,11 @@ void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
  * action frames; %false otherwise, in which case for action frames the
  * driver is responsible for rejecting the frame.
  */
-bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
+bool cfg80211_rx_mgmt_dup(struct wireless_dev *wdev, int freq, int sig_dbm,
 		      const u8 *buf, size_t len, u32 flags);
 
 /**
- * cfg80211_mgmt_tx_status - notification of TX status for management frame
+ * cfg80211_mgmt_tx_status_dup - notification of TX status for management frame
  * @wdev: wireless device receiving the frame
  * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()
  * @buf: Management frame (header + body)
@@ -4636,12 +4636,12 @@ bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
  * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
  * transmission attempt.
  */
-void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_mgmt_tx_status_dup(struct wireless_dev *wdev, u64 cookie,
 			     const u8 *buf, size_t len, bool ack, gfp_t gfp);
 
 
 /**
- * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event
+ * cfg80211_cqm_rssi_notify_dup - connection quality monitoring rssi event
  * @dev: network device
  * @rssi_event: the triggered RSSI event
  * @gfp: context flags
@@ -4649,12 +4649,12 @@ void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
  * This function is called when a configured connection quality monitoring
  * rssi threshold reached event occurs.
  */
-void cfg80211_cqm_rssi_notify(struct net_device *dev,
+void cfg80211_cqm_rssi_notify_dup(struct net_device *dev,
 			      enum nl80211_cqm_rssi_threshold_event rssi_event,
 			      gfp_t gfp);
 
 /**
- * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
+ * cfg80211_cqm_pktloss_notify_dup - notify userspace about packetloss to peer
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost -- should be a fixed threshold
@@ -4662,11 +4662,11 @@ void cfg80211_cqm_rssi_notify(struct net_device *dev,
  *	threshold (to account for temporary interference)
  * @gfp: context flags
  */
-void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+void cfg80211_cqm_pktloss_notify_dup(struct net_device *dev,
 				 const u8 *peer, u32 num_packets, gfp_t gfp);
 
 /**
- * cfg80211_cqm_txe_notify - TX error rate event
+ * cfg80211_cqm_txe_notify_dup - TX error rate event
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost
@@ -4677,31 +4677,31 @@ void cfg80211_cqm_pktloss_notify(struct net_device *dev,
  * Notify userspace when configured % TX failures over number of packets in a
  * given interval is exceeded.
  */
-void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
+void cfg80211_cqm_txe_notify_dup(struct net_device *dev, const u8 *peer,
 			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);
 
 /**
- * cfg80211_cqm_beacon_loss_notify - beacon loss event
+ * cfg80211_cqm_beacon_loss_notify_dup - beacon loss event
  * @dev: network device
  * @gfp: context flags
  *
  * Notify userspace about beacon loss from the connected AP.
  */
-void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+void cfg80211_cqm_beacon_loss_notify_dup(struct net_device *dev, gfp_t gfp);
 
 /**
- * cfg80211_radar_event - radar detection event
+ * cfg80211_radar_event_dup - radar detection event
  * @wiphy: the wiphy
  * @chandef: chandef for the current channel
  * @gfp: context flags
  *
  * This function is called when a radar is detected on the current chanenl.
  */
-void cfg80211_radar_event(struct wiphy *wiphy,
+void cfg80211_radar_event_dup(struct wiphy *wiphy,
 			  struct cfg80211_chan_def *chandef, gfp_t gfp);
 
 /**
- * cfg80211_cac_event - Channel availability check (CAC) event
+ * cfg80211_cac_event_dup - Channel availability check (CAC) event
  * @netdev: network device
  * @chandef: chandef for the current channel
  * @event: type of event
@@ -4711,34 +4711,34 @@ void cfg80211_radar_event(struct wiphy *wiphy,
  * or aborted. This must be called to notify the completion of a CAC process,
  * also by full-MAC drivers.
  */
-void cfg80211_cac_event(struct net_device *netdev,
+void cfg80211_cac_event_dup(struct net_device *netdev,
 			const struct cfg80211_chan_def *chandef,
 			enum nl80211_radar_event event, gfp_t gfp);
 
 
 /**
- * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+ * cfg80211_gtk_rekey_notify_dup - notify userspace about driver rekeying
  * @dev: network device
  * @bssid: BSSID of AP (to avoid races)
  * @replay_ctr: new replay counter
  * @gfp: allocation flags
  */
-void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
+void cfg80211_gtk_rekey_notify_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
+ * cfg80211_pmksa_candidate_notify_dup - notify about PMKSA caching candidate
  * @dev: network device
  * @index: candidate index (the smaller the index, the higher the priority)
  * @bssid: BSSID of AP
  * @preauth: Whether AP advertises support for RSN pre-authentication
  * @gfp: allocation flags
  */
-void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
+void cfg80211_pmksa_candidate_notify_dup(struct net_device *dev, int index,
 				     const u8 *bssid, bool preauth, gfp_t gfp);
 
 /**
- * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
+ * cfg80211_rx_spurious_frame_dup - inform userspace about a spurious frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4749,11 +4749,11 @@ void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_spurious_frame(struct net_device *dev,
+bool cfg80211_rx_spurious_frame_dup(struct net_device *dev,
 				const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame
+ * cfg80211_rx_unexpected_4addr_frame_dup - inform about unexpected WDS frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4765,22 +4765,22 @@ bool cfg80211_rx_spurious_frame(struct net_device *dev,
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
+bool cfg80211_rx_unexpected_4addr_frame_dup(struct net_device *dev,
 					const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_probe_status - notify userspace about probe status
+ * cfg80211_probe_status_dup - notify userspace about probe status
  * @dev: the device the probe was sent on
  * @addr: the address of the peer
  * @cookie: the cookie filled in @probe_client previously
  * @acked: indicates whether probe was acked or not
  * @gfp: allocation flags
  */
-void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
+void cfg80211_probe_status_dup(struct net_device *dev, const u8 *addr,
 			   u64 cookie, bool acked, gfp_t gfp);
 
 /**
- * cfg80211_report_obss_beacon - report beacon from other APs
+ * cfg80211_report_obss_beacon_dup - report beacon from other APs
  * @wiphy: The wiphy that received the beacon
  * @frame: the frame
  * @len: length of the frame
@@ -4791,12 +4791,12 @@ void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
  * received. It is not useful to call this when there is no
  * netdev that is in AP/GO mode.
  */
-void cfg80211_report_obss_beacon(struct wiphy *wiphy,
+void cfg80211_report_obss_beacon_dup(struct wiphy *wiphy,
 				 const u8 *frame, size_t len,
 				 int freq, int sig_dbm);
 
 /**
- * cfg80211_reg_can_beacon - check if beaconing is allowed
+ * cfg80211_reg_can_beacon_dup - check if beaconing is allowed
  * @wiphy: the wiphy
  * @chandef: the channel definition
  * @iftype: interface type
@@ -4804,23 +4804,23 @@ void cfg80211_report_obss_beacon(struct wiphy *wiphy,
  * Return: %true if there is no secondary channel or the secondary channel(s)
  * can be used for beaconing (i.e. is not a radar channel etc.)
  */
-bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
+bool cfg80211_reg_can_beacon_dup(struct wiphy *wiphy,
 			     struct cfg80211_chan_def *chandef,
 			     enum nl80211_iftype iftype);
 
 /*
- * cfg80211_ch_switch_notify - update wdev channel and notify userspace
+ * cfg80211_ch_switch_notify_dup - update wdev channel and notify userspace
  * @dev: the device which switched channels
  * @chandef: the new channel definition
  *
  * Caller must acquire wdev_lock, therefore must only be called from sleepable
  * driver context!
  */
-void cfg80211_ch_switch_notify(struct net_device *dev,
+void cfg80211_ch_switch_notify_dup(struct net_device *dev,
 			       struct cfg80211_chan_def *chandef);
 
 /*
- * cfg80211_ch_switch_started_notify - notify channel switch start
+ * cfg80211_ch_switch_started_notify_dup - notify channel switch start
  * @dev: the device on which the channel switch started
  * @chandef: the future channel definition
  * @count: the number of TBTTs until the channel switch happens
@@ -4829,23 +4829,23 @@ void cfg80211_ch_switch_notify(struct net_device *dev,
  * started, so that it can take appropriate actions (eg. starting
  * channel switch on other vifs), if necessary.
  */
-void cfg80211_ch_switch_started_notify(struct net_device *dev,
+void cfg80211_ch_switch_started_notify_dup(struct net_device *dev,
 				       struct cfg80211_chan_def *chandef,
 				       u8 count);
 
 /**
- * ieee80211_operating_class_to_band - convert operating class to band
+ * ieee80211_operating_class_to_band_dup - convert operating class to band
  *
  * @operating_class: the operating class to convert
  * @band: band pointer to fill
  *
  * Returns %true if the conversion was successful, %false otherwise.
  */
-bool ieee80211_operating_class_to_band(u8 operating_class,
+bool ieee80211_operating_class_to_band_dup(u8 operating_class,
 				       enum ieee80211_band *band);
 
 /*
- * cfg80211_tdls_oper_request - request userspace to perform TDLS operation
+ * cfg80211_tdls_oper_request_dup - request userspace to perform TDLS operation
  * @dev: the device on which the operation is requested
  * @peer: the MAC address of the peer device
  * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or
@@ -4859,20 +4859,20 @@ bool ieee80211_operating_class_to_band(u8 operating_class,
  * if it can automatically determine when a TDLS link could be useful (e.g.,
  * based on traffic and signal strength for a peer).
  */
-void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
+void cfg80211_tdls_oper_request_dup(struct net_device *dev, const u8 *peer,
 				enum nl80211_tdls_operation oper,
 				u16 reason_code, gfp_t gfp);
 
 /*
- * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)
+ * cfg80211_calculate_bitrate_dup - calculate actual bitrate (in 100Kbps units)
  * @rate: given rate_info to calculate bitrate from
  *
  * return 0 if MCS index >= 32
  */
-u32 cfg80211_calculate_bitrate(struct rate_info *rate);
+u32 cfg80211_calculate_bitrate_dup(struct rate_info *rate);
 
 /**
- * cfg80211_unregister_wdev - remove the given wdev
+ * cfg80211_unregister_wdev_dup - remove the given wdev
  * @wdev: struct wireless_dev to remove
  *
  * Call this function only for wdevs that have no netdev assigned,
@@ -4885,10 +4885,10 @@ u32 cfg80211_calculate_bitrate(struct rate_info *rate);
  *
  * Requires the RTNL to be held.
  */
-void cfg80211_unregister_wdev(struct wireless_dev *wdev);
+void cfg80211_unregister_wdev_dup(struct wireless_dev *wdev);
 
 /**
- * struct cfg80211_ft_event - FT Information Elements
+ * struct cfg80211_ft_event_dup - FT Information Elements
  * @ies: FT IEs
  * @ies_len: length of the FT IE in bytes
  * @target_ap: target AP's MAC address
@@ -4904,15 +4904,15 @@ struct cfg80211_ft_event_params {
 };
 
 /**
- * cfg80211_ft_event - notify userspace about FT IE and RIC IE
+ * cfg80211_ft_event_dup - notify userspace about FT IE and RIC IE
  * @netdev: network device
  * @ft_event: IE information
  */
-void cfg80211_ft_event(struct net_device *netdev,
+void cfg80211_ft_event_dup(struct net_device *netdev,
 		       struct cfg80211_ft_event_params *ft_event);
 
 /**
- * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer
+ * cfg80211_get_p2p_attr_dup - find and copy a P2P attribute from IE buffer
  * @ies: the input IE buffer
  * @len: the input length
  * @attr: the attribute ID to find
@@ -4927,12 +4927,12 @@ void cfg80211_ft_event(struct net_device *netdev,
  * malformed or the attribute can't be found (respectively), or the
  * length of the found attribute (which can be zero).
  */
-int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
+int cfg80211_get_p2p_attr_dup(const u8 *ies, unsigned int len,
 			  enum ieee80211_p2p_attr_id attr,
 			  u8 *buf, unsigned int bufsize);
 
 /**
- * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN
+ * cfg80211_report_wowlan_wakeup_dup - report wakeup from WoWLAN
  * @wdev: the wireless device reporting the wakeup
  * @wakeup: the wakeup report
  * @gfp: allocation flags
@@ -4942,12 +4942,12 @@ int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
  * pass %NULL as the @wakeup parameter to advertise that something
  * else caused the wakeup.
  */
-void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
+void cfg80211_report_wowlan_wakeup_dup(struct wireless_dev *wdev,
 				   struct cfg80211_wowlan_wakeup *wakeup,
 				   gfp_t gfp);
 
 /**
- * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
+ * cfg80211_crit_proto_stopped_dup() - indicate critical protocol stopped by driver.
  *
  * @wdev: the wireless device for which critical protocol is stopped.
  * @gfp: allocation flags
@@ -4956,18 +4956,18 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
  * operation back to normal. One reason could be that the duration given
  * by .crit_proto_start() has expired.
  */
-void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);
+void cfg80211_crit_proto_stopped_dup(struct wireless_dev *wdev, gfp_t gfp);
 
 /**
- * ieee80211_get_num_supported_channels - get number of channels device has
+ * ieee80211_get_num_supported_channels_dup - get number of channels device has
  * @wiphy: the wiphy
  *
  * Return: the number of channels supported by the device.
  */
-unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
+unsigned int ieee80211_get_num_supported_channels_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_check_combinations - check interface combinations
+ * cfg80211_check_combinations_dup - check interface combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -4983,13 +4983,13 @@ unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
  * combination of interfaces and their types are allowed according to
  * the interface combinations.
  */
-int cfg80211_check_combinations(struct wiphy *wiphy,
+int cfg80211_check_combinations_dup(struct wiphy *wiphy,
 				const int num_different_channels,
 				const u8 radar_detect,
 				const int iftype_num[NUM_NL80211_IFTYPES]);
 
 /**
- * cfg80211_iter_combinations - iterate over matching combinations
+ * cfg80211_iter_combinations_dup - iterate over matching combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -5007,7 +5007,7 @@ int cfg80211_check_combinations(struct wiphy *wiphy,
  * combinations it fits in at a given moment, e.g. for channel switching
  * purposes.
  */
-int cfg80211_iter_combinations(struct wiphy *wiphy,
+int cfg80211_iter_combinations_dup(struct wiphy *wiphy,
 			       const int num_different_channels,
 			       const u8 radar_detect,
 			       const int iftype_num[NUM_NL80211_IFTYPES],
@@ -5016,7 +5016,7 @@ int cfg80211_iter_combinations(struct wiphy *wiphy,
 			       void *data);
 
 /*
- * cfg80211_stop_iface - trigger interface disconnection
+ * cfg80211_stop_iface_dup - trigger interface disconnection
  *
  * @wiphy: the wiphy
  * @wdev: wireless device
@@ -5027,11 +5027,11 @@ int cfg80211_iter_combinations(struct wiphy *wiphy,
  *
  * Note: This doesn't need any locks and is asynchronous.
  */
-void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+void cfg80211_stop_iface_dup(struct wiphy *wiphy, struct wireless_dev *wdev,
 			 gfp_t gfp);
 
 /**
- * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
+ * cfg80211_shutdown_all_interfaces_dup - shut down all interfaces for a wiphy
  * @wiphy: the wiphy to shut down
  *
  * This function shuts down all interfaces belonging to this wiphy by
@@ -5042,7 +5042,7 @@ void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
  * Callers must hold the RTNL and be able to deal with callbacks into
  * the driver while the function is running.
  */
-void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
+void cfg80211_shutdown_all_interfaces_dup(struct wiphy *wiphy);
 
 
 /* ethtool helper */
--- a/include/net/iw_handler.h
+++ b/include/net/iw_handler.h
@@ -216,7 +216,7 @@
  * --------
  *	- Move event definition in <linux/wireless.h>
  *	- Add Wireless Event support :
- *		o wireless_send_event() prototype
+ *		o wireless_send_event_dup() prototype
  *		o iwe_stream_add_event/point() inline functions
  * V3 to V4
  * --------
@@ -440,7 +440,7 @@ extern int dev_get_wireless_info(char * buffer, char **start, off_t offset,
 /* Second : functions that may be called by driver modules */
 
 /* Send a single event to user space */
-extern void wireless_send_event(struct net_device *	dev,
+extern void wireless_send_event_dup(struct net_device *	dev,
 				unsigned int		cmd,
 				union iwreq_data *	wrqu,
 				const char *		extra);
@@ -449,27 +449,27 @@ extern void wireless_send_event(struct net_device *	dev,
  * More on that later... */
 
 /* Standard handler for SIOCSIWSPY */
-extern int iw_handler_set_spy(struct net_device *	dev,
+extern int iw_handler_set_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCGIWSPY */
-extern int iw_handler_get_spy(struct net_device *	dev,
+extern int iw_handler_get_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCSIWTHRSPY */
-extern int iw_handler_set_thrspy(struct net_device *	dev,
+extern int iw_handler_set_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Standard handler for SIOCGIWTHRSPY */
-extern int iw_handler_get_thrspy(struct net_device *	dev,
+extern int iw_handler_get_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Driver call to update spy records */
-extern void wireless_spy_update(struct net_device *	dev,
+extern void wireless_spy_update_dup(struct net_device *	dev,
 				unsigned char *		address,
 				struct iw_quality *	wstats);
 
--- a/include/net/lib80211.h
+++ b/include/net/lib80211.h
@@ -114,13 +114,13 @@ struct lib80211_crypt_info {
 	int crypt_quiesced;
 };
 
-int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
+int lib80211_crypt_info_init_dup(struct lib80211_crypt_info *info, char *name,
                                 spinlock_t *lock);
-void lib80211_crypt_info_free(struct lib80211_crypt_info *info);
-int lib80211_register_crypto_ops(struct lib80211_crypto_ops *ops);
-int lib80211_unregister_crypto_ops(struct lib80211_crypto_ops *ops);
-struct lib80211_crypto_ops *lib80211_get_crypto_ops(const char *name);
-void lib80211_crypt_delayed_deinit(struct lib80211_crypt_info *info,
+void lib80211_crypt_info_free_dup(struct lib80211_crypt_info *info);
+int lib80211_register_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+int lib80211_unregister_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+struct lib80211_crypto_ops *lib80211_get_crypto_ops_dup(const char *name);
+void lib80211_crypt_delayed_deinit_dup(struct lib80211_crypt_info *info,
 				    struct lib80211_crypt_data **crypt);
 
 #endif /* LIB80211_H */
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -36,7 +36,7 @@ struct inet6_dev;
 /**
  * DOC: Calling mac80211 from interrupts
  *
- * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be
+ * Only ieee80211_tx_status_irqsafe_dup() and ieee80211_rx_irqsafe_dup() can be
  * called in hardware interrupt context. The low-level driver must not call any
  * other functions in hardware interrupt context. If there is a need for such
  * call, the low-level driver should first ACK the interrupt and perform the
@@ -566,7 +566,7 @@ struct ieee80211_bss_conf {
  * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
  *	This flag is actually used for management frame especially for P2P
  *	frames not being sent at CCK rate in 2GHz band.
- * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
+ * @ieee80211_tx_status_EOSP: This packet marks the end of service period,
  *	when its status is reported the service period ends. For frames in
  *	an SP that mac80211 transmits, it is already set; for driver frames
  *	the driver may set this flag. It is also used to do the same for
@@ -611,7 +611,7 @@ enum mac80211_tx_info_flags {
 	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
 	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
 	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
-	IEEE80211_TX_STATUS_EOSP		= BIT(28),
+	ieee80211_tx_status_EOSP		= BIT(28),
 	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
 	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
 	IEEE80211_TX_CTL_PS_RESPONSE		= BIT(31),
@@ -642,7 +642,7 @@ enum mac80211_tx_control_flags {
 	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
 	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \
 	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
-	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)
+	IEEE80211_TX_CTL_STBC | ieee80211_tx_status_EOSP)
 
 /**
  * enum mac80211_rate_control_flags - per-rate flags set by the
@@ -664,7 +664,7 @@ enum mac80211_tx_control_flags {
  * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission
  * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission
  *	(80+80 isn't supported yet)
- * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
+ * @IEEE80211_TX_RC_DATA: The frame should be transmitted on both of the
  *	adjacent 20 MHz channels, if the current channel type is
  *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
  * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
@@ -678,7 +678,7 @@ enum mac80211_rate_control_flags {
 	IEEE80211_TX_RC_MCS			= BIT(3),
 	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
 	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
-	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
+	IEEE80211_TX_RC_DATA		= BIT(6),
 	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
 	IEEE80211_TX_RC_VHT_MCS			= BIT(8),
 	IEEE80211_TX_RC_80_MHZ_WIDTH		= BIT(9),
@@ -1327,7 +1327,7 @@ static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
 }
 
 /**
- * wdev_to_ieee80211_vif - return a vif struct from a wdev
+ * wdev_to_ieee80211_vif_dup - return a vif struct from a wdev
  * @wdev: the wdev to get the vif for
  *
  * This can be used by mac80211 drivers with direct cfg80211 APIs
@@ -1337,7 +1337,7 @@ static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
  * associated with a vif that the driver knows about (e.g. monitor
  * or AP_VLAN interfaces.)
  */
-struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);
+struct ieee80211_vif *wdev_to_ieee80211_vif_dup(struct wireless_dev *wdev);
 
 /**
  * enum ieee80211_key_flags - key flags
@@ -1618,7 +1618,7 @@ struct ieee80211_tx_control {
  *	rely on the host system for such buffering. This option is used
  *	to configure the IEEE 802.11 upper layer to buffer broadcast and
  *	multicast frames when there are power saving stations so that
- *	the driver can fetch them with ieee80211_get_buffered_bc().
+ *	the driver can fetch them with ieee80211_get_buffered_bc_dup().
  *
  * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:
  *	Hardware is not capable of short slot operation on the 2.4 GHz band.
@@ -1795,7 +1795,7 @@ enum ieee80211_hw_flags {
  *
  * @rate_control_algorithm: rate control algorithm for this hardware.
  *	If unset (NULL), the default algorithm will be used. Must be
- *	set before calling ieee80211_register_hw().
+ *	set before calling ieee80211_register_hw_dup().
  *
  * @vif_data_size: size (in bytes) of the drv_priv data area
  *	within &struct ieee80211_vif.
@@ -1920,7 +1920,7 @@ struct ieee80211_tdls_ch_sw_params {
 };
 
 /**
- * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
+ * wiphy_to_ieee80211_hw_dup - return a mac80211 driver hw struct from a wiphy
  *
  * @wiphy: the &struct wiphy which we want to query
  *
@@ -1932,7 +1932,7 @@ struct ieee80211_tdls_ch_sw_params {
  *
  * Return: The mac80211 driver hw struct of @wiphy.
  */
-struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);
+struct ieee80211_hw *wiphy_to_ieee80211_hw_dup(struct wiphy *wiphy);
 
 /**
  * SET_IEEE80211_DEV - set device for 802.11 hardware
@@ -1984,14 +1984,14 @@ ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
 }
 
 /**
- * ieee80211_free_txskb - free TX skb
+ * ieee80211_free_txskb_dup - free TX skb
  * @hw: the hardware
  * @skb: the skb
  *
  * Free a transmit skb. Use this funtion when some failure
  * to transmit happened and thus status cannot be reported.
  */
-void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_free_txskb_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * DOC: Hardware crypto acceleration
@@ -2119,11 +2119,11 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * interface capability. The driver needs to enable beacon filter support
  * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
  * power save is enabled, the stack will not check for beacon loss and the
- * driver needs to notify about loss of beacons with ieee80211_beacon_loss().
+ * driver needs to notify about loss of beacons with ieee80211_beacon_loss_dup().
  *
  * The time (or number of beacons missed) until the firmware notifies the
  * driver of a beacon loss event (which in turn causes the driver to call
- * ieee80211_beacon_loss()) should be configurable and will be controlled
+ * ieee80211_beacon_loss_dup()) should be configurable and will be controlled
  * by mac80211 and the roaming algorithm in the future.
  *
  * Since there may be constantly changing information elements that nothing
@@ -2246,7 +2246,7 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
  * mac80211 expects the driver to handle most of the state machine for
  * powersaving clients and will ignore the PM bit in incoming frames.
- * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of
+ * Drivers then use ieee80211_sta_ps_transition_dup() to inform mac80211 of
  * stations' powersave transitions. In this mode, mac80211 also doesn't
  * handle PS-Poll/uAPSD.
  *
@@ -2270,7 +2270,7 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * callback; this callback is optional. mac80211 will then transmit
  * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER
  * on each frame. The last frame in the service period (or the only
- * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
+ * response to a PS-Poll) also has %ieee80211_tx_status_EOSP set to
  * indicate that it ends the service period; as this frame must have
  * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
  * When TX status is reported for this frame, the service period is
@@ -2286,13 +2286,13 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * processing of the EOSP. The cause is that allowing frames to be
  * transmitted to a certain station is out-of-band communication to
  * the device. To allow this problem to be solved, the driver can
- * call ieee80211_sta_block_awake() if frames are buffered when it
+ * call ieee80211_sta_block_awake_dup() if frames are buffered when it
  * is notified that the station went to sleep. When all these frames
  * have been filtered (see above), it must call the function again
  * to indicate that the station is no longer blocked.
  *
  * If the driver buffers frames in the driver for aggregation in any
- * way, it must use the ieee80211_sta_set_buffered() call when it is
+ * way, it must use the ieee80211_sta_set_buffered_dup() call when it is
  * notified of the station going to sleep to inform mac80211 of any
  * TIDs that have frames buffered. Note that when a station wakes up
  * this information is reset (hence the requirement to call it when
@@ -2311,14 +2311,14 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * filter those response frames except in the case of frames that
  * are buffered in the driver -- those must remain buffered to avoid
  * reordering. Because it is possible that no frames are released
- * in this case, the driver must call ieee80211_sta_eosp()
+ * in this case, the driver must call ieee80211_sta_eosp_dup()
  * to indicate to mac80211 that the service period ended anyway.
  *
  * Finally, if frames from multiple TIDs are released from mac80211
  * but the driver might reorder them, it must clear & set the flags
- * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
+ * appropriately (only the last frame may have %ieee80211_tx_status_EOSP)
  * and also take care of the EOSP and MORE_DATA bits in the frame.
- * The driver may also use ieee80211_sta_eosp() in this case.
+ * The driver may also use ieee80211_sta_eosp_dup() in this case.
  *
  * Note that if the driver ever buffers frames other than QoS-data
  * frames, it must take care to never send a non-QoS-data frame as
@@ -2348,7 +2348,7 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * if necessary will queue the frame on the right software queue that mirrors
  * the hardware queue.
  * Additionally, the driver has to then use these HW queue IDs for the queue
- * management functions (ieee80211_stop_queue() et al.)
+ * management functions (ieee80211_stop_queue_dup() et al.)
  *
  * The driver is free to set up the queue mappings as needed, multiple virtual
  * interfaces may map to the same hardware queues if needed. The setup has to
@@ -2439,7 +2439,7 @@ enum ieee80211_filter_flags {
  *
  * Note that drivers MUST be able to deal with a TX aggregation
  * session being stopped even before they OK'ed starting it by
- * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
+ * calling ieee80211_start_tx_ba_cb_irqsafe_dup, because the peer
  * might receive the addBA frame and send a delBA right away!
  *
  * @IEEE80211_AMPDU_RX_START: start RX aggregation
@@ -2448,13 +2448,13 @@ enum ieee80211_filter_flags {
  * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
  * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting
  *	queued packets, now unaggregated. After all packets are transmitted the
- *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe().
+ *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe_dup().
  * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,
  *	called when the station is removed. There's no need or reason to call
- *	ieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the
+ *	ieee80211_stop_tx_ba_cb_irqsafe_dup() in this case as mac80211 assumes the
  *	session is gone and removes the station.
  * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped
- *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and
+ *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe_dup() yet and
  *	now the connection is dropped and the station will be removed. Drivers
  *	should clean up and drop remaining packets when this is called.
  */
@@ -2652,7 +2652,7 @@ enum ieee80211_reconfig_type {
  *	host is suspended, it can assign this callback to retrieve the data
  *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
  *	After rekeying was done it should (for example during resume) notify
- *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().
+ *	userspace of the new replay counter using ieee80211_gtk_rekey_notify_dup().
  *
  * @set_default_unicast_key: Set the default (unicast) key index, useful for
  *	WEP when the device sends data packets autonomously, e.g. for ARP
@@ -2667,7 +2667,7 @@ enum ieee80211_reconfig_type {
  *	entire IEs after the SSID, so that drivers need not look at these
  *	at all but just send them after the SSID -- mac80211 includes the
  *	(extended) supported rates and HT information (where applicable).
- *	When the scan finishes, ieee80211_scan_completed() must be called;
+ *	When the scan finishes, ieee80211_scan_completed_dup() must be called;
  *	note that it also must be called when the scan cannot finish due to
  *	any error unless this callback returned a negative error code.
  *	The callback can sleep.
@@ -2675,18 +2675,18 @@ enum ieee80211_reconfig_type {
  * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
  *	The driver should ask the hardware to cancel the scan (if possible),
  *	but the scan will be completed only after the driver will call
- *	ieee80211_scan_completed().
+ *	ieee80211_scan_completed_dup().
  *	This callback is needed for wowlan, to prevent enqueueing a new
  *	scan_work after the low-level driver was already suspended.
  *	The callback can sleep.
  *
  * @sched_scan_start: Ask the hardware to start scanning repeatedly at
  *	specific intervals.  The driver must call the
- *	ieee80211_sched_scan_results() function whenever it finds results.
+ *	ieee80211_sched_scan_results_dup() function whenever it finds results.
  *	This process will continue until sched_scan_stop is called.
  *
  * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
- *	In this case, ieee80211_sched_scan_stopped() must not be called.
+ *	In this case, ieee80211_sched_scan_stopped_dup() must not be called.
  *
  * @sw_scan_start: Notifier function that is called just before a software scan
  *	is started. Can be NULL, if the driver doesn't need this notification.
@@ -2822,7 +2822,7 @@ enum ieee80211_reconfig_type {
  *
  * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
  *	need to set wiphy->rfkill_poll to %true before registration,
- *	and need to call wiphy_rfkill_set_hw_state() in the callback.
+ *	and need to call wiphy_rfkill_set_hw_state_dup() in the callback.
  *	The callback can sleep.
  *
  * @set_coverage_class: Set slot time for given coverage class as specified
@@ -2845,7 +2845,7 @@ enum ieee80211_reconfig_type {
  *
  * @channel_switch: Drivers that need (or want) to offload the channel
  *	switch operation for CSAs received from the AP may implement this
- *	callback. They must then call ieee80211_chswitch_done() to indicate
+ *	callback. They must then call ieee80211_chswitch_done_dup() to indicate
  *	completion of the channel switch.
  *
  * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
@@ -2856,12 +2856,12 @@ enum ieee80211_reconfig_type {
  * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
  *
  * @remain_on_channel: Starts an off-channel period on the given channel, must
- *	call back to ieee80211_ready_on_channel() when on that channel. Note
+ *	call back to ieee80211_ready_on_channel_dup() when on that channel. Note
  *	that normal channel traffic is not stopped as this is intended for hw
  *	offload. Frames to transmit on the off-channel channel are transmitted
  *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
  *	duration (which will always be non-zero) expires, the driver must call
- *	ieee80211_remain_on_channel_expired().
+ *	ieee80211_remain_on_channel_expired_dup().
  *	Note that this callback may be called while the device is in IDLE and
  *	must be accepted in this case.
  *	This callback may sleep.
@@ -2895,7 +2895,7 @@ enum ieee80211_reconfig_type {
  *	from, for PS-poll it will always have only a single bit set.
  *	In the case this is used for a PS-poll initiated release, the
  *	@num_frames parameter will always be 1 so code can be shared. In
- *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
+ *	this case the driver must also set %ieee80211_tx_status_EOSP flag
  *	on the TX status (and must report TX status) so that the PS-poll
  *	period is properly ended. This is used to avoid sending multiple
  *	responses for a retried PS-poll frame.
@@ -2903,20 +2903,20 @@ enum ieee80211_reconfig_type {
  *	bigger than one, but the driver may send fewer frames (it must send
  *	at least one, however). In this case it is also responsible for
  *	setting the EOSP flag in the QoS header of the frames. Also, when the
- *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
+ *	service period ends, the driver must set %ieee80211_tx_status_EOSP
  *	on the last frame in the SP. Alternatively, it may call the function
- *	ieee80211_sta_eosp() to inform mac80211 of the end of the SP.
+ *	ieee80211_sta_eosp_dup() to inform mac80211 of the end of the SP.
  *	This callback must be atomic.
  * @allow_buffered_frames: Prepare device to allow the given number of frames
  *	to go out to the given station. The frames will be sent by mac80211
  *	via the usual TX path after this call. The TX information for frames
  *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set
- *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
+ *	and the last one will also have %ieee80211_tx_status_EOSP set. In case
  *	frames from multiple TIDs are released and the driver might reorder
- *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
+ *	them between the TIDs, it must set the %ieee80211_tx_status_EOSP flag
  *	on the last frame and clear it on all others and also handle the EOSP
  *	bit in the QoS header correctly. Alternatively, it can also call the
- *	ieee80211_sta_eosp() function.
+ *	ieee80211_sta_eosp_dup() function.
  *	The @tids parameter is a bitmap and tells the driver which TIDs the
  *	frames will be on; it will at most have two bits set.
  *	This callback must be atomic.
@@ -2975,7 +2975,7 @@ enum ieee80211_reconfig_type {
  *	disabled/enabled via @bss_info_changed.
  * @stop_ap: Stop operation on the AP interface.
  *
- * @reconfig_complete: Called after a call to ieee80211_restart_hw() and
+ * @reconfig_complete: Called after a call to ieee80211_restart_hw_dup() and
  *	during resume, when the reconfiguration has completed.
  *	This can help the driver implement the reconfiguration step (and
  *	indicate mac80211 is ready to receive frames).
@@ -2989,10 +2989,10 @@ enum ieee80211_reconfig_type {
  *	Beacons are modified to include CSA or ECSA IEs before calling this
  *	function. The corresponding count fields in these IEs must be
  *	decremented, and when they reach 1 the driver must call
- *	ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
+ *	ieee80211_csa_finish_dup(). Drivers which use ieee80211_beacon_get()
  *	get the csa counter decremented by mac80211, but must check if it is
- *	1 using ieee80211_csa_is_complete() after the beacon has been
- *	transmitted and then call ieee80211_csa_finish().
+ *	1 using ieee80211_csa_is_complete_dup() after the beacon has been
+ *	transmitted and then call ieee80211_csa_finish_dup().
  *	If the CSA count starts as zero or 1, this function will not be called,
  *	since there won't be any time to beacon before the switch anyway.
  * @pre_channel_switch: This is an optional callback that is called
@@ -3267,7 +3267,7 @@ struct ieee80211_ops {
 };
 
 /**
- * ieee80211_alloc_hw_nm - Allocate a new hardware device
+ * ieee80211_alloc_hw_nm_dup - Allocate a new hardware device
  *
  * This must be called once for each hardware device. The returned pointer
  * must be used to refer to this device when calling other functions.
@@ -3282,7 +3282,7 @@ struct ieee80211_ops {
  *
  * Return: A pointer to the new hardware device, or %NULL on error.
  */
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
+struct ieee80211_hw *ieee80211_alloc_hw_nm_dup(size_t priv_data_len,
 					   const struct ieee80211_ops *ops,
 					   const char *requested_name);
 
@@ -3304,11 +3304,11 @@ static inline
 struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
 					const struct ieee80211_ops *ops)
 {
-	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
+	return ieee80211_alloc_hw_nm_dup(priv_data_len, ops, NULL);
 }
 
 /**
- * ieee80211_register_hw - Register hardware device
+ * ieee80211_register_hw_dup - Register hardware device
  *
  * You must call this function before any other functions in
  * mac80211. Note that before a hardware can be registered, you
@@ -3318,7 +3318,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
  *
  * Return: 0 on success. An error code otherwise.
  */
-int ieee80211_register_hw(struct ieee80211_hw *hw);
+int ieee80211_register_hw_dup(struct ieee80211_hw *hw);
 
 /**
  * struct ieee80211_tpt_blink - throughput blink description
@@ -3345,11 +3345,11 @@ enum ieee80211_tpt_led_trigger_flags {
 };
 
 #ifdef CONFIG_MAC80211_LEDS
-char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+char *__ieee80211_get_tx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_rx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_assoc_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_radio_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_create_tpt_led_trigger_dup(struct ieee80211_hw *hw,
 					 unsigned int flags,
 					 const struct ieee80211_tpt_blink *blink_table,
 					 unsigned int blink_table_len);
@@ -3369,7 +3369,7 @@ char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
 static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_tx_led_name(hw);
+	return __ieee80211_get_tx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3390,7 +3390,7 @@ static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
 static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_rx_led_name(hw);
+	return __ieee80211_get_rx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3411,7 +3411,7 @@ static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
 static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_assoc_led_name(hw);
+	return __ieee80211_get_assoc_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3432,7 +3432,7 @@ static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
 static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_radio_led_name(hw);
+	return __ieee80211_get_radio_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3448,7 +3448,7 @@ static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
  * Return: %NULL (in case of error, or if no LED triggers are
  * configured) or the name of the new trigger.
  *
- * Note: This function must be called before ieee80211_register_hw().
+ * Note: This function must be called before ieee80211_register_hw_dup().
  */
 static inline char *
 ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
@@ -3456,7 +3456,7 @@ ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
 				 unsigned int blink_table_len)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
+	return __ieee80211_create_tpt_led_trigger_dup(hw, flags, blink_table,
 						  blink_table_len);
 #else
 	return NULL;
@@ -3464,28 +3464,28 @@ ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
 }
 
 /**
- * ieee80211_unregister_hw - Unregister a hardware device
+ * ieee80211_unregister_hw_dup - Unregister a hardware device
  *
  * This function instructs mac80211 to free allocated resources
  * and unregister netdevices from the networking subsystem.
  *
  * @hw: the hardware to unregister
  */
-void ieee80211_unregister_hw(struct ieee80211_hw *hw);
+void ieee80211_unregister_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_free_hw - free hardware descriptor
+ * ieee80211_free_hw_dup - free hardware descriptor
  *
  * This function frees everything that was allocated, including the
- * private data for the driver. You must call ieee80211_unregister_hw()
+ * private data for the driver. You must call ieee80211_unregister_hw_dup()
  * before calling this function.
  *
  * @hw: the hardware to free
  */
-void ieee80211_free_hw(struct ieee80211_hw *hw);
+void ieee80211_free_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_restart_hw - restart hardware completely
+ * ieee80211_restart_hw_dup - restart hardware completely
  *
  * Call this function when the hardware was restarted for some reason
  * (hardware error, ...) and the driver is unable to restore its state
@@ -3496,10 +3496,10 @@ void ieee80211_free_hw(struct ieee80211_hw *hw);
  *
  * @hw: the hardware to restart
  */
-void ieee80211_restart_hw(struct ieee80211_hw *hw);
+void ieee80211_restart_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_napi_add - initialize mac80211 NAPI context
+ * ieee80211_napi_add_dup - initialize mac80211 NAPI context
  * @hw: the hardware to initialize the NAPI context on
  * @napi: the NAPI context to initialize
  * @napi_dev: dummy NAPI netdevice, here to not waste the space if the
@@ -3509,13 +3509,13 @@ void ieee80211_restart_hw(struct ieee80211_hw *hw);
  *
  * See also netif_napi_add().
  */
-void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
+void ieee80211_napi_add_dup(struct ieee80211_hw *hw, struct napi_struct *napi,
 			struct net_device *napi_dev,
 			int (*poll)(struct napi_struct *, int),
 			int weight);
 
 /**
- * ieee80211_rx - receive frame
+ * ieee80211_rx_dup - receive frame
  *
  * Use this function to hand received frames to mac80211. The receive
  * buffer in @skb must start with an IEEE 802.11 header. In case of a
@@ -3525,41 +3525,41 @@ void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls to
- * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
+ * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe_dup() may not be
  * mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * In process context use instead ieee80211_rx_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
- * ieee80211_rx_irqsafe - receive frame
+ * ieee80211_rx_irqsafe_dup - receive frame
  *
- * Like ieee80211_rx() but can be called in IRQ context
+ * Like ieee80211_rx_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
+ * Calls to this function, ieee80211_rx_dup() or ieee80211_rx_ni() may not
  * be mixed for a single hardware.Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_irqsafe_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * ieee80211_rx_ni - receive frame (in process context)
  *
- * Like ieee80211_rx() but can be called in process context
+ * Like ieee80211_rx_dup() but can be called in process context
  * (internally disables bottom halves).
  *
- * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may
+ * Calls to this function, ieee80211_rx_dup() and ieee80211_rx_irqsafe_dup() may
  * not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
@@ -3568,12 +3568,12 @@ static inline void ieee80211_rx_ni(struct ieee80211_hw *hw,
 				   struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_rx(hw, skb);
+	ieee80211_rx_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_sta_ps_transition - PS transition for connected sta
+ * ieee80211_sta_ps_transition_dup - PS transition for connected sta
  *
  * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
  * flag set, use this function to inform mac80211 about a connected station
@@ -3589,20 +3589,20 @@ static inline void ieee80211_rx_ni(struct ieee80211_hw *hw,
  *
  * Return: 0 on success. -EINVAL when the requested PS mode is already set.
  */
-int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);
+int ieee80211_sta_ps_transition_dup(struct ieee80211_sta *sta, bool start);
 
 /**
  * ieee80211_sta_ps_transition_ni - PS transition for connected sta
  *                                  (in process context)
  *
- * Like ieee80211_sta_ps_transition() but can be called in process context
+ * Like ieee80211_sta_ps_transition_dup() but can be called in process context
  * (internally disables bottom halves). Concurrent call restriction still
  * applies.
  *
  * @sta: currently connected sta
  * @start: start or stop PS
  *
- * Return: Like ieee80211_sta_ps_transition().
+ * Return: Like ieee80211_sta_ps_transition_dup().
  */
 static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
 						  bool start)
@@ -3610,7 +3610,7 @@ static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
 	int ret;
 
 	local_bh_disable();
-	ret = ieee80211_sta_ps_transition(sta, start);
+	ret = ieee80211_sta_ps_transition_dup(sta, start);
 	local_bh_enable();
 
 	return ret;
@@ -3620,10 +3620,10 @@ static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
  * The TX headroom reserved by mac80211 for its own tx_status functions.
  * This is enough for the radiotap header.
  */
-#define IEEE80211_TX_STATUS_HEADROOM	14
+#define ieee80211_tx_status_HEADROOM	14
 
 /**
- * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames
+ * ieee80211_sta_set_buffered_dup - inform mac80211 about driver-buffered frames
  * @sta: &struct ieee80211_sta pointer for the sleeping station
  * @tid: the TID that has buffered frames
  * @buffered: indicates whether or not frames are buffered for this TID
@@ -3650,11 +3650,11 @@ static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
  * TID to the AC as required instead of keeping track in all drivers that
  * use this API.
  */
-void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
+void ieee80211_sta_set_buffered_dup(struct ieee80211_sta *sta,
 				u8 tid, bool buffered);
 
 /**
- * ieee80211_get_tx_rates - get the selected transmit rates for a packet
+ * ieee80211_get_tx_rates_dup - get the selected transmit rates for a packet
  *
  * Call this function in a driver with per-packet rate selection support
  * to combine the rate info in the packet tx info with the most recent
@@ -3666,14 +3666,14 @@ void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
  * @dest: buffer for extracted rate/retry information
  * @max_rates: maximum number of rates to fetch
  */
-void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
+void ieee80211_get_tx_rates_dup(struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta,
 			    struct sk_buff *skb,
 			    struct ieee80211_tx_rate *dest,
 			    int max_rates);
 
 /**
- * ieee80211_tx_status - transmit status callback
+ * ieee80211_tx_status_dup - transmit status callback
  *
  * Call this function for all transmitted frames after they have been
  * transmitted. It is permissible to not call this function for
@@ -3681,43 +3681,43 @@ void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls
- * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()
+ * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe_dup()
  * may not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_rx() or ieee80211_rx_ni().
+ * ieee80211_rx_dup() or ieee80211_rx_ni().
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status(struct ieee80211_hw *hw,
+void ieee80211_tx_status_dup(struct ieee80211_hw *hw,
 			 struct sk_buff *skb);
 
 /**
- * ieee80211_tx_status_noskb - transmit status callback without skb
+ * ieee80211_tx_status_noskb_dup - transmit status callback without skb
  *
- * This function can be used as a replacement for ieee80211_tx_status
+ * This function can be used as a replacement for ieee80211_tx_status_dup
  * in drivers that cannot reliably map tx status information back to
  * specific skbs.
  *
  * Calls to this function for a single hardware must be synchronized
  * against each other. Calls to this function, ieee80211_tx_status_ni()
- * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
+ * and ieee80211_tx_status_irqsafe_dup() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @sta: the receiver station to which this packet is sent
  *	(NULL for multicast packets)
  * @info: tx status information
  */
-void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+void ieee80211_tx_status_noskb_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *sta,
 			       struct ieee80211_tx_info *info);
 
 /**
  * ieee80211_tx_status_ni - transmit status callback (in process context)
  *
- * Like ieee80211_tx_status() but can be called in process context.
+ * Like ieee80211_tx_status_dup() but can be called in process context.
  *
- * Calls to this function, ieee80211_tx_status() and
- * ieee80211_tx_status_irqsafe() may not be mixed
+ * Calls to this function, ieee80211_tx_status_dup() and
+ * ieee80211_tx_status_irqsafe_dup() may not be mixed
  * for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
@@ -3727,27 +3727,27 @@ static inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,
 					  struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_tx_status(hw, skb);
+	ieee80211_tx_status_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback
+ * ieee80211_tx_status_irqsafe_dup - IRQ-safe transmit status callback
  *
- * Like ieee80211_tx_status() but can be called in IRQ context
+ * Like ieee80211_tx_status_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_tx_status() and
+ * Calls to this function, ieee80211_tx_status_dup() and
  * ieee80211_tx_status_ni() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+void ieee80211_tx_status_irqsafe_dup(struct ieee80211_hw *hw,
 				 struct sk_buff *skb);
 
 /**
- * ieee80211_report_low_ack - report non-responding station
+ * ieee80211_report_low_ack_dup - report non-responding station
  *
  * When operating in AP-mode, call this function to report a non-responding
  * connected STA.
@@ -3755,7 +3755,7 @@ void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
  * @sta: the non-responding connected sta
  * @num_packets: number of packets sent to @sta without a response
  */
-void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
+void ieee80211_report_low_ack_dup(struct ieee80211_sta *sta, u32 num_packets);
 
 #define IEEE80211_MAX_CSA_COUNTERS_NUM 2
 
@@ -3775,7 +3775,7 @@ struct ieee80211_mutable_offsets {
 };
 
 /**
- * ieee80211_beacon_get_template - beacon template generation function
+ * ieee80211_beacon_get_template_dup - beacon template generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
@@ -3794,12 +3794,12 @@ struct ieee80211_mutable_offsets {
  * Return: The beacon template. %NULL on error.
  */
 struct sk_buff *
-ieee80211_beacon_get_template(struct ieee80211_hw *hw,
+ieee80211_beacon_get_template_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
 			      struct ieee80211_mutable_offsets *offs);
 
 /**
- * ieee80211_beacon_get_tim - beacon generation function
+ * ieee80211_beacon_get_tim_dup - beacon generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @tim_offset: pointer to variable that will receive the TIM IE offset.
@@ -3820,7 +3820,7 @@ ieee80211_beacon_get_template(struct ieee80211_hw *hw,
  *
  * Return: The beacon template. %NULL on error.
  */
-struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_beacon_get_tim_dup(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif,
 					 u16 *tim_offset, u16 *tim_length);
 
@@ -3829,47 +3829,47 @@ struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
- * See ieee80211_beacon_get_tim().
+ * See ieee80211_beacon_get_tim_dup().
  *
- * Return: See ieee80211_beacon_get_tim().
+ * Return: See ieee80211_beacon_get_tim_dup().
  */
 static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
 						   struct ieee80211_vif *vif)
 {
-	return ieee80211_beacon_get_tim(hw, vif, NULL, NULL);
+	return ieee80211_beacon_get_tim_dup(hw, vif, NULL, NULL);
 }
 
 /**
- * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
+ * ieee80211_csa_update_counter_dup - request mac80211 to decrement the csa counter
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * The csa counter should be updated after each beacon transmission.
  * This function is called implicitly when
- * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
+ * ieee80211_beacon_get/ieee80211_beacon_get_tim_dup are called, however if the
  * beacon frames are generated by the device, the driver should call this
  * function after each beacon transmission to sync mac80211's csa counters.
  *
  * Return: new csa counter value
  */
-u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);
+u8 ieee80211_csa_update_counter_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_finish - notify mac80211 about channel switch
+ * ieee80211_csa_finish_dup - notify mac80211 about channel switch
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * After a channel switch announcement was scheduled and the counter in this
  * announcement hits 1, this function must be called by the driver to
  * notify mac80211 that the channel can be changed.
  */
-void ieee80211_csa_finish(struct ieee80211_vif *vif);
+void ieee80211_csa_finish_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_is_complete - find out if counters reached 1
+ * ieee80211_csa_is_complete_dup - find out if counters reached 1
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * This function returns whether the channel switch counters reached zero.
  */
-bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);
+bool ieee80211_csa_is_complete_dup(struct ieee80211_vif *vif);
 
 
 /**
@@ -3888,7 +3888,7 @@ struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif);
 
 /**
- * ieee80211_pspoll_get - retrieve a PS Poll template
+ * ieee80211_pspoll_get_dup - retrieve a PS Poll template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3901,11 +3901,11 @@ struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
  *
  * Return: The PS Poll template. %NULL on error.
  */
-struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_pspoll_get_dup(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif);
 
 /**
- * ieee80211_nullfunc_get - retrieve a nullfunc template
+ * ieee80211_nullfunc_get_dup - retrieve a nullfunc template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3918,11 +3918,11 @@ struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
  *
  * Return: The nullfunc template. %NULL on error.
  */
-struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_nullfunc_get_dup(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif);
 
 /**
- * ieee80211_probereq_get - retrieve a Probe Request template
+ * ieee80211_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @src_addr: source MAC address
  * @ssid: SSID buffer
@@ -3934,13 +3934,13 @@ struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_probereq_get_dup(struct ieee80211_hw *hw,
 				       const u8 *src_addr,
 				       const u8 *ssid, size_t ssid_len,
 				       size_t tailroom);
 
 /**
- * ieee80211_rts_get - RTS frame generation function
+ * ieee80211_rts_get_dup - RTS frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the RTS.
@@ -3953,13 +3953,13 @@ struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
  * the next RTS frame from the 802.11 code. The low-level is responsible
  * for calling this function before and RTS frame is needed.
  */
-void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void ieee80211_rts_get_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		       const void *frame, size_t frame_len,
 		       const struct ieee80211_tx_info *frame_txctl,
 		       struct ieee80211_rts *rts);
 
 /**
- * ieee80211_rts_duration - Get the duration field for an RTS frame
+ * ieee80211_rts_duration_dup - Get the duration field for an RTS frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the RTS.
@@ -3971,12 +3971,12 @@ void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
  *
  * Return: The duration.
  */
-__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_rts_duration_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, size_t frame_len,
 			      const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_ctstoself_get - CTS-to-self frame generation function
+ * ieee80211_ctstoself_get_dup - CTS-to-self frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
@@ -3989,14 +3989,14 @@ __le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
  * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
  * for calling this function before and CTS-to-self frame is needed.
  */
-void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
+void ieee80211_ctstoself_get_dup(struct ieee80211_hw *hw,
 			     struct ieee80211_vif *vif,
 			     const void *frame, size_t frame_len,
 			     const struct ieee80211_tx_info *frame_txctl,
 			     struct ieee80211_cts *cts);
 
 /**
- * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
+ * ieee80211_ctstoself_duration_dup - Get the duration field for a CTS-to-self frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
@@ -4008,13 +4008,13 @@ void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
  *
  * Return: The duration.
  */
-__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_ctstoself_duration_dup(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif,
 				    size_t frame_len,
 				    const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_generic_frame_duration - Calculate the duration field for a frame
+ * ieee80211_generic_frame_duration_dup - Calculate the duration field for a frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @band: the band to calculate the frame duration on
@@ -4026,14 +4026,14 @@ __le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
  *
  * Return: The duration.
  */
-__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_generic_frame_duration_dup(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
 					enum ieee80211_band band,
 					size_t frame_len,
 					struct ieee80211_rate *rate);
 
 /**
- * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
+ * ieee80211_get_buffered_bc_dup - accessing buffered broadcast and multicast frames
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4048,16 +4048,16 @@ __le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
  *
  * Note: buffered frames are returned only after DTIM beacon frame was
  * generated with ieee80211_beacon_get() and the low-level driver must thus
- * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
+ * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc_dup() returns
  * NULL if the previous generated beacon was not DTIM, so the low-level driver
  * does not need to check for DTIM beacons separately and should be able to
  * use common code for all beacons.
  */
 struct sk_buff *
-ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+ieee80211_get_buffered_bc_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 
 /**
- * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
+ * ieee80211_get_tkip_p1k_iv_dup - get a TKIP phase 1 key for IV32
  *
  * This function returns the TKIP phase 1 key for the given IV32.
  *
@@ -4065,7 +4065,7 @@ ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p1k_iv_dup(struct ieee80211_key_conf *keyconf,
 			       u32 iv32, u16 *p1k);
 
 /**
@@ -4083,14 +4083,14 @@ static inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,
 					  struct sk_buff *skb, u16 *p1k)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen_dup(hdr->frame_control);
 	u32 iv32 = get_unaligned_le32(&data[4]);
 
-	ieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
+	ieee80211_get_tkip_p1k_iv_dup(keyconf, iv32, p1k);
 }
 
 /**
- * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
+ * ieee80211_get_tkip_rx_p1k_dup - get a TKIP phase 1 key for RX
  *
  * This function returns the TKIP phase 1 key for the given IV32
  * and transmitter address.
@@ -4100,11 +4100,11 @@ static inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_rx_p1k_dup(struct ieee80211_key_conf *keyconf,
 			       const u8 *ta, u32 iv32, u16 *p1k);
 
 /**
- * ieee80211_get_tkip_p2k - get a TKIP phase 2 key
+ * ieee80211_get_tkip_p2k_dup - get a TKIP phase 2 key
  *
  * This function computes the TKIP RC4 key for the IV values
  * in the packet.
@@ -4114,11 +4114,11 @@ void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
  *	encrypted with this key
  * @p2k: a buffer to which the key will be written, 16 bytes
  */
-void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p2k_dup(struct ieee80211_key_conf *keyconf,
 			    struct sk_buff *skb, u8 *p2k);
 
 /**
- * ieee80211_aes_cmac_calculate_k1_k2 - calculate the AES-CMAC sub keys
+ * ieee80211_aes_cmac_calculate_k1_k2_dup - calculate the AES-CMAC sub keys
  *
  * This function computes the two AES-CMAC sub-keys, based on the
  * previously installed master key.
@@ -4127,7 +4127,7 @@ void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
  * @k1: a buffer to be filled with the 1st sub-key
  * @k2: a buffer to be filled with the 2nd sub-key
  */
-void ieee80211_aes_cmac_calculate_k1_k2(struct ieee80211_key_conf *keyconf,
+void ieee80211_aes_cmac_calculate_k1_k2_dup(struct ieee80211_key_conf *keyconf,
 					u8 *k1, u8 *k2);
 
 /**
@@ -4155,7 +4155,7 @@ struct ieee80211_key_seq {
 };
 
 /**
- * ieee80211_get_key_tx_seq - get key TX sequence counter
+ * ieee80211_get_key_tx_seq_dup - get key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: buffer to receive the sequence data
@@ -4168,11 +4168,11 @@ struct ieee80211_key_seq {
  * can be done concurrently, for example when queues are stopped
  * and the stop has been synchronized.
  */
-void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_get_key_rx_seq - get key RX sequence counter
+ * ieee80211_get_key_rx_seq_dup - get key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4187,11 +4187,11 @@ void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_tx_seq - set key TX sequence counter
+ * ieee80211_set_key_tx_seq_dup - set key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: new sequence data
@@ -4204,11 +4204,11 @@ void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
  * Note that this function may only be called when no TX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_rx_seq - set key RX sequence counter
+ * ieee80211_set_key_rx_seq_dup - set key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4224,11 +4224,11 @@ void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_remove_key - remove the given key
+ * ieee80211_remove_key_dup - remove the given key
  * @keyconf: the parameter passed with the set key
  *
  * Remove the given key. If the key was uploaded to the hardware at the
@@ -4236,12 +4236,12 @@ void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
  * instead assumed to have been removed already.
  *
  * Note that due to locking considerations this function can (currently)
- * only be called during key iteration (ieee80211_iter_keys().)
+ * only be called during key iteration (ieee80211_iter_keys_dup().)
  */
-void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);
+void ieee80211_remove_key_dup(struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
+ * ieee80211_gtk_rekey_add_dup - add a GTK key from rekeying during WoWLAN
  * @vif: the virtual interface to add the key on
  * @keyconf: new key data
  *
@@ -4261,48 +4261,48 @@ void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);
  * the return code 1 to reconfigure the device, this key will be part
  * of the reconfiguration.
  *
- * Note that the driver should also call ieee80211_set_key_rx_seq()
+ * Note that the driver should also call ieee80211_set_key_rx_seq_dup()
  * for the new key for each TID to set up sequence counters properly.
  *
  * IMPORTANT: If this replaces a key that is present in the hardware,
  * then it will attempt to remove it during this call. In many cases
- * this isn't what you want, so call ieee80211_remove_key() first for
+ * this isn't what you want, so call ieee80211_remove_key_dup() first for
  * the key that's being replaced.
  */
 struct ieee80211_key_conf *
-ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+ieee80211_gtk_rekey_add_dup(struct ieee80211_vif *vif,
 			struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
+ * ieee80211_gtk_rekey_notify_dup - notify userspace supplicant of rekeying
  * @vif: virtual interface the rekeying was done on
  * @bssid: The BSSID of the AP, for checking association
  * @replay_ctr: the new replay counter after GTK rekeying
  * @gfp: allocation flags
  */
-void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+void ieee80211_gtk_rekey_notify_dup(struct ieee80211_vif *vif, const u8 *bssid,
 				const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * ieee80211_wake_queue - wake specific queue
+ * ieee80211_wake_queue_dup - wake specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_wake_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queue - stop specific queue
+ * ieee80211_stop_queue_dup - stop specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_stop_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_queue_stopped - test status of the queue
+ * ieee80211_queue_stopped_dup - test status of the queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
@@ -4311,26 +4311,26 @@ void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);
  * Return: %true if the queue is stopped. %false otherwise.
  */
 
-int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);
+int ieee80211_queue_stopped_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queues - stop all queues
+ * ieee80211_stop_queues_dup - stop all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queues(struct ieee80211_hw *hw);
+void ieee80211_stop_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_wake_queues - wake all queues
+ * ieee80211_wake_queues_dup - wake all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queues(struct ieee80211_hw *hw);
+void ieee80211_wake_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_scan_completed - completed hardware scan
+ * ieee80211_scan_completed_dup - completed hardware scan
  *
  * When hardware scan offload is used (i.e. the hw_scan() callback is
  * assigned) this function needs to be called by the driver to notify
@@ -4340,20 +4340,20 @@ void ieee80211_wake_queues(struct ieee80211_hw *hw);
  * @hw: the hardware that finished the scan
  * @aborted: set to true if scan was aborted
  */
-void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted);
+void ieee80211_scan_completed_dup(struct ieee80211_hw *hw, bool aborted);
 
 /**
- * ieee80211_sched_scan_results - got results from scheduled scan
+ * ieee80211_sched_scan_results_dup - got results from scheduled scan
  *
  * When a scheduled scan is running, this function needs to be called by the
  * driver whenever there are new scan results available.
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_results(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_results_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped
+ * ieee80211_sched_scan_stopped_dup - inform that the scheduled scan has stopped
  *
  * When a scheduled scan is running, this function can be called by
  * the driver if it needs to stop the scan to perform another task.
@@ -4362,7 +4362,7 @@ void ieee80211_sched_scan_results(struct ieee80211_hw *hw);
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_stopped_dup(struct ieee80211_hw *hw);
 
 /**
  * enum ieee80211_interface_iteration_flags - interface iteration flags
@@ -4380,12 +4380,12 @@ enum ieee80211_interface_iteration_flags {
 };
 
 /**
- * ieee80211_iterate_active_interfaces - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function allows the iterator function to sleep, when the iterator
- * function is atomic @ieee80211_iterate_active_interfaces_atomic can
+ * function is atomic @ieee80211_iterate_active_interfaces_atomic_dup can
  * be used.
  * Does not iterate over a new interface during add_interface().
  *
@@ -4394,19 +4394,19 @@ enum ieee80211_interface_iteration_flags {
  * @iterator: the iterator function to call
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_dup(struct ieee80211_hw *hw,
 					 u32 iter_flags,
 					 void (*iterator)(void *data, u8 *mac,
 						struct ieee80211_vif *vif),
 					 void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_atomic_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function requires the iterator callback function to be atomic,
- * if that is not desired, use @ieee80211_iterate_active_interfaces instead.
+ * if that is not desired, use @ieee80211_iterate_active_interfaces_dup instead.
  * Does not iterate over a new interface during add_interface().
  *
  * @hw: the hardware struct of which the interfaces should be iterated over
@@ -4414,7 +4414,7 @@ void ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw,
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_atomic_dup(struct ieee80211_hw *hw,
 						u32 iter_flags,
 						void (*iterator)(void *data,
 						    u8 *mac,
@@ -4422,7 +4422,7 @@ void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
 						void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_rtnl_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
@@ -4433,7 +4433,7 @@ void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_rtnl_dup(struct ieee80211_hw *hw,
 					      u32 iter_flags,
 					      void (*iterator)(void *data,
 						u8 *mac,
@@ -4441,7 +4441,7 @@ void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
 					      void *data);
 
 /**
- * ieee80211_iterate_stations_atomic - iterate stations
+ * ieee80211_iterate_stations_atomic_dup - iterate stations
  *
  * This function iterates over all stations associated with a given
  * hardware that are currently uploaded to the driver and calls the callback
@@ -4452,12 +4452,12 @@ void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_stations_atomic_dup(struct ieee80211_hw *hw,
 				       void (*iterator)(void *data,
 						struct ieee80211_sta *sta),
 				       void *data);
 /**
- * ieee80211_queue_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
  * This helper ensures drivers are not queueing work when they should not be.
@@ -4465,10 +4465,10 @@ void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
  * @hw: the hardware struct for the interface we are adding work for
  * @work: the work we want to add onto the mac80211 workqueue
  */
-void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);
+void ieee80211_queue_work_dup(struct ieee80211_hw *hw, struct work_struct *work);
 
 /**
- * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_delayed_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to queue delayed work onto the mac80211
  * workqueue.
@@ -4477,12 +4477,12 @@ void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);
  * @dwork: delayable work to queue onto the mac80211 workqueue
  * @delay: number of jiffies to wait before queueing
  */
-void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
+void ieee80211_queue_delayed_work_dup(struct ieee80211_hw *hw,
 				  struct delayed_work *dwork,
 				  unsigned long delay);
 
 /**
- * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
+ * ieee80211_start_tx_ba_session_dup - Start a tx Block Ack session.
  * @sta: the station for which to start a BA session
  * @tid: the TID to BA on.
  * @timeout: session timeout value (in TUs)
@@ -4493,11 +4493,11 @@ void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
  * the need to start aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
+int ieee80211_start_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid,
 				  u16 timeout);
 
 /**
- * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
+ * ieee80211_start_tx_ba_cb_irqsafe_dup - low level driver ready to aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the TID to BA on.
@@ -4506,11 +4506,11 @@ int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
  * finished with preparations for the BA session. It can be called
  * from any context.
  */
-void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_start_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				      u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_session - Stop a Block Ack session.
+ * ieee80211_stop_tx_ba_session_dup - Stop a Block Ack session.
  * @sta: the station whose BA session to stop
  * @tid: the TID to stop BA.
  *
@@ -4520,10 +4520,10 @@ void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
  * the need to stop aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);
+int ieee80211_stop_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
+ * ieee80211_stop_tx_ba_cb_irqsafe_dup - low level driver ready to stop aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the desired TID to BA on.
@@ -4532,11 +4532,11 @@ int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);
  * finished with preparations for the BA session tear down. It
  * can be called from any context.
  */
-void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_stop_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				     u16 tid);
 
 /**
- * ieee80211_find_sta - find a station
+ * ieee80211_find_sta_dup - find a station
  *
  * @vif: virtual interface to look for station on
  * @addr: station's address
@@ -4546,11 +4546,11 @@ void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
  * Note: This function must be called under RCU lock and the
  * resulting pointer is only valid under RCU lock as well.
  */
-struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
+struct ieee80211_sta *ieee80211_find_sta_dup(struct ieee80211_vif *vif,
 					 const u8 *addr);
 
 /**
- * ieee80211_find_sta_by_ifaddr - find a station on hardware
+ * ieee80211_find_sta_by_ifaddr_dup - find a station on hardware
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @addr: remote station's address
@@ -4571,12 +4571,12 @@ struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
  *
  * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
  */
-struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+struct ieee80211_sta *ieee80211_find_sta_by_ifaddr_dup(struct ieee80211_hw *hw,
 					       const u8 *addr,
 					       const u8 *localaddr);
 
 /**
- * ieee80211_sta_block_awake - block station from waking up
+ * ieee80211_sta_block_awake_dup - block station from waking up
  * @hw: the hardware
  * @pubsta: the station
  * @block: whether to block or unblock
@@ -4604,16 +4604,16 @@ struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
  * it is unblocked, regardless of whether the station actually
  * woke up while blocked or not.
  */
-void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
+void ieee80211_sta_block_awake_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *pubsta, bool block);
 
 /**
- * ieee80211_sta_eosp - notify mac80211 about end of SP
+ * ieee80211_sta_eosp_dup - notify mac80211 about end of SP
  * @pubsta: the station
  *
  * When a device transmits frames in a way that it can't tell
  * mac80211 in the TX status about the EOSP, it must clear the
- * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
+ * %ieee80211_tx_status_EOSP bit and call this function instead.
  * This applies for PS-Poll as well as uAPSD.
  *
  * Note that just like with _tx_status() and _rx() drivers must
@@ -4626,10 +4626,10 @@ void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
  *     you'd need the _irqsafe version, look at the git history
  *     and restore the _irqsafe version!
  */
-void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);
+void ieee80211_sta_eosp_dup(struct ieee80211_sta *pubsta);
 
 /**
- * ieee80211_iter_keys - iterate keys programmed into the device
+ * ieee80211_iter_keys_dup - iterate keys programmed into the device
  * @hw: pointer obtained from ieee80211_alloc_hw()
  * @vif: virtual interface to iterate, may be %NULL for all
  * @iter: iterator function that will be called for each key
@@ -4646,7 +4646,7 @@ void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);
  * in which they were originally installed and handed to the
  * set_key callback.
  */
-void ieee80211_iter_keys(struct ieee80211_hw *hw,
+void ieee80211_iter_keys_dup(struct ieee80211_hw *hw,
 			 struct ieee80211_vif *vif,
 			 void (*iter)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
@@ -4656,7 +4656,7 @@ void ieee80211_iter_keys(struct ieee80211_hw *hw,
 			 void *iter_data);
 
 /**
- * ieee80211_iter_chan_contexts_atomic - iterate channel contexts
+ * ieee80211_iter_chan_contexts_atomic_dup - iterate channel contexts
  * @hw: pointre obtained from ieee80211_alloc_hw().
  * @iter: iterator function
  * @iter_data: data passed to iterator function
@@ -4674,7 +4674,7 @@ void ieee80211_iter_keys(struct ieee80211_hw *hw,
  * found while iterating, whether they've been re-added already
  * or not.
  */
-void ieee80211_iter_chan_contexts_atomic(
+void ieee80211_iter_chan_contexts_atomic_dup(
 	struct ieee80211_hw *hw,
 	void (*iter)(struct ieee80211_hw *hw,
 		     struct ieee80211_chanctx_conf *chanctx_conf,
@@ -4682,7 +4682,7 @@ void ieee80211_iter_chan_contexts_atomic(
 	void *iter_data);
 
 /**
- * ieee80211_ap_probereq_get - retrieve a Probe Request template
+ * ieee80211_ap_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4695,11 +4695,11 @@ void ieee80211_iter_chan_contexts_atomic(
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_ap_probereq_get_dup(struct ieee80211_hw *hw,
 					  struct ieee80211_vif *vif);
 
 /**
- * ieee80211_beacon_loss - inform hardware does not receive beacons
+ * ieee80211_beacon_loss_dup - inform hardware does not receive beacons
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4707,10 +4707,10 @@ struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
  * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
  * hardware is not receiving beacons with this function.
  */
-void ieee80211_beacon_loss(struct ieee80211_vif *vif);
+void ieee80211_beacon_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_connection_loss - inform hardware has lost connection to the AP
+ * ieee80211_connection_loss_dup - inform hardware has lost connection to the AP
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4723,10 +4723,10 @@ void ieee80211_beacon_loss(struct ieee80211_vif *vif);
  * This function will cause immediate change to disassociated state,
  * without connection recovery attempts.
  */
-void ieee80211_connection_loss(struct ieee80211_vif *vif);
+void ieee80211_connection_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_resume_disconnect - disconnect from AP after resume
+ * ieee80211_resume_disconnect_dup - disconnect from AP after resume
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4746,10 +4746,10 @@ void ieee80211_connection_loss(struct ieee80211_vif *vif);
  * calls this function, or at least not any locks it needs in the
  * key configuration paths (if it supports HW crypto).
  */
-void ieee80211_resume_disconnect(struct ieee80211_vif *vif);
+void ieee80211_resume_disconnect_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring
+ * ieee80211_cqm_rssi_notify_dup - inform a configured connection quality monitoring
  *	rssi threshold triggered
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
@@ -4760,37 +4760,37 @@ void ieee80211_resume_disconnect(struct ieee80211_vif *vif);
  * monitoring is configured with an rssi threshold, the driver will inform
  * whenever the rssi level reaches the threshold.
  */
-void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+void ieee80211_cqm_rssi_notify_dup(struct ieee80211_vif *vif,
 			       enum nl80211_cqm_rssi_threshold_event rssi_event,
 			       gfp_t gfp);
 
 /**
- * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
+ * ieee80211_cqm_beacon_loss_notify_dup - inform CQM of beacon loss
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @gfp: context flags
  */
-void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);
+void ieee80211_cqm_beacon_loss_notify_dup(struct ieee80211_vif *vif, gfp_t gfp);
 
 /**
- * ieee80211_radar_detected - inform that a radar was detected
+ * ieee80211_radar_detected_dup - inform that a radar was detected
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_radar_detected(struct ieee80211_hw *hw);
+void ieee80211_radar_detected_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_chswitch_done - Complete channel switch process
+ * ieee80211_chswitch_done_dup - Complete channel switch process
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @success: make the channel switch successful or not
  *
  * Complete the channel switch post-process: set the new operational channel
  * and wake up the suspended queues.
  */
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);
+void ieee80211_chswitch_done_dup(struct ieee80211_vif *vif, bool success);
 
 /**
- * ieee80211_request_smps - request SM PS transition
+ * ieee80211_request_smps_dup - request SM PS transition
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @smps_mode: new SM PS mode
  *
@@ -4798,23 +4798,23 @@ void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);
  * mode. This is useful when the driver has more information than
  * the stack about possible interference, for example by bluetooth.
  */
-void ieee80211_request_smps(struct ieee80211_vif *vif,
+void ieee80211_request_smps_dup(struct ieee80211_vif *vif,
 			    enum ieee80211_smps_mode smps_mode);
 
 /**
- * ieee80211_ready_on_channel - notification of remain-on-channel start
+ * ieee80211_ready_on_channel_dup - notification of remain-on-channel start
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_ready_on_channel(struct ieee80211_hw *hw);
+void ieee80211_ready_on_channel_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_remain_on_channel_expired - remain_on_channel duration expired
+ * ieee80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);
+void ieee80211_remain_on_channel_expired_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions
+ * ieee80211_stop_rx_ba_session_dup - callback to stop existing BA sessions
  *
  * in order not to harm the system performance and user experience, the device
  * may request not to allow any rx ba session and tear down existing rx ba
@@ -4827,11 +4827,11 @@ void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);
  * @ba_rx_bitmap: Bit map of open rx ba per tid
  * @addr: & to bssid mac address
  */
-void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+void ieee80211_stop_rx_ba_session_dup(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
 				  const u8 *addr);
 
 /**
- * ieee80211_send_bar - send a BlockAckReq frame
+ * ieee80211_send_bar_dup - send a BlockAckReq frame
  *
  * can be used to flush pending frames from the peer's aggregation reorder
  * buffer.
@@ -4841,10 +4841,10 @@ void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
  * @tid: the TID of the aggregation session
  * @ssn: the new starting sequence number for the receiver
  */
-void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
+void ieee80211_send_bar_dup(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
 
 /**
- * ieee80211_start_rx_ba_session_offl - start a Rx BA session
+ * ieee80211_start_rx_ba_session_offl_dup - start a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4857,11 +4857,11 @@ void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_start_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 					const u8 *addr, u16 tid);
 
 /**
- * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session
+ * ieee80211_stop_rx_ba_session_offl_dup - stop a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4874,7 +4874,7 @@ void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_stop_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 				       const u8 *addr, u16 tid);
 
 /* Rate control API */
@@ -4955,7 +4955,7 @@ static inline int rate_supported(struct ieee80211_sta *sta,
 }
 
 /**
- * rate_control_send_low - helper for drivers for management/no-ack frames
+ * rate_control_send_low_dup - helper for drivers for management/no-ack frames
  *
  * Rate control algorithms that agree to use the lowest rate to
  * send management frames and NO_ACK data with the respective hw
@@ -4972,7 +4972,7 @@ static inline int rate_supported(struct ieee80211_sta *sta,
  * @priv_sta: private rate control structure. This may be null.
  * @txrc: rate control information we sholud populate for mac80211.
  */
-bool rate_control_send_low(struct ieee80211_sta *sta,
+bool rate_control_send_low_dup(struct ieee80211_sta *sta,
 			   void *priv_sta,
 			   struct ieee80211_tx_rate_control *txrc);
 
@@ -5007,7 +5007,7 @@ bool rate_usable_index_exists(struct ieee80211_supported_band *sband,
 }
 
 /**
- * rate_control_set_rates - pass the sta rate selection to mac80211/driver
+ * rate_control_set_rates_dup - pass the sta rate selection to mac80211/driver
  *
  * When not doing a rate control probe to test rates, rate control should pass
  * its rate selection to mac80211. If the driver supports receiving a station
@@ -5018,12 +5018,12 @@ bool rate_usable_index_exists(struct ieee80211_supported_band *sband,
  * @pubsta: &struct ieee80211_sta pointer to the target destination.
  * @rates: new tx rate set to be used for this station.
  */
-int rate_control_set_rates(struct ieee80211_hw *hw,
+int rate_control_set_rates_dup(struct ieee80211_hw *hw,
 			   struct ieee80211_sta *pubsta,
 			   struct ieee80211_sta_rates *rates);
 
-int ieee80211_rate_control_register(const struct rate_control_ops *ops);
-void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);
+int ieee80211_rate_control_register_dup(const struct rate_control_ops *ops);
+void ieee80211_rate_control_unregister_dup(const struct rate_control_ops *ops);
 
 static inline bool
 conf_is_ht20(struct ieee80211_conf *conf)
@@ -5081,14 +5081,14 @@ ieee80211_vif_type_p2p(struct ieee80211_vif *vif)
 	return ieee80211_iftype_p2p(vif->type, vif->p2p);
 }
 
-void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
+void ieee80211_enable_rssi_reports_dup(struct ieee80211_vif *vif,
 				   int rssi_min_thold,
 				   int rssi_max_thold);
 
-void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);
+void ieee80211_disable_rssi_reports_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_ave_rssi - report the average RSSI for the specified interface
+ * ieee80211_ave_rssi_dup - report the average RSSI for the specified interface
  *
  * @vif: the specified virtual interface
  *
@@ -5097,22 +5097,22 @@ void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);
  * Return: The average RSSI value for the requested interface, or 0 if not
  * applicable.
  */
-int ieee80211_ave_rssi(struct ieee80211_vif *vif);
+int ieee80211_ave_rssi_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup
+ * ieee80211_report_wowlan_wakeup_dup - report WoWLAN wakeup
  * @vif: virtual interface
  * @wakeup: wakeup reason(s)
  * @gfp: allocation flags
  *
- * See cfg80211_report_wowlan_wakeup().
+ * See cfg80211_report_wowlan_wakeup_dup().
  */
-void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
+void ieee80211_report_wowlan_wakeup_dup(struct ieee80211_vif *vif,
 				    struct cfg80211_wowlan_wakeup *wakeup,
 				    gfp_t gfp);
 
 /**
- * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
+ * ieee80211_tx_prepare_skb_dup - prepare an 802.11 skb for transmission
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @vif: virtual interface
  * @skb: frame to be sent from within the driver
@@ -5121,7 +5121,7 @@ void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
  *
  * Note: must be called under RCU lock
  */
-bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
+bool ieee80211_tx_prepare_skb_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, struct sk_buff *skb,
 			      int band, struct ieee80211_sta **sta);
 
@@ -5153,7 +5153,7 @@ struct ieee80211_noa_data {
 };
 
 /**
- * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
+ * ieee80211_parse_p2p_noa_dup - initialize NoA tracking data from P2P IE
  *
  * @attr: P2P NoA IE
  * @data: NoA tracking data
@@ -5161,16 +5161,16 @@ struct ieee80211_noa_data {
  *
  * Return: number of successfully parsed descriptors
  */
-int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
+int ieee80211_parse_p2p_noa_dup(const struct ieee80211_p2p_noa_attr *attr,
 			    struct ieee80211_noa_data *data, u32 tsf);
 
 /**
- * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
+ * ieee80211_update_p2p_noa_dup - get next pending P2P GO absent state change
  *
  * @data: NoA tracking data
  * @tsf: current TSF timestamp
  */
-void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);
+void ieee80211_update_p2p_noa_dup(struct ieee80211_noa_data *data, u32 tsf);
 
 /**
  * ieee80211_tdls_oper - request userspace to perform a TDLS operation
@@ -5180,14 +5180,14 @@ void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);
  * @reason_code: reason code for the operation, valid for TDLS teardown
  * @gfp: allocation flags
  *
- * See cfg80211_tdls_oper_request().
+ * See cfg80211_tdls_oper_request_dup().
  */
-void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
+void ieee80211_tdls_oper_request_dup(struct ieee80211_vif *vif, const u8 *peer,
 				 enum nl80211_tdls_operation oper,
 				 u16 reason_code, gfp_t gfp);
 
 /**
- * ieee80211_reserve_tid - request to reserve a specific TID
+ * ieee80211_reserve_tid_dup - request to reserve a specific TID
  *
  * There is sometimes a need (such as in TDLS) for blocking the driver from
  * using a specific TID so that the FW can use it for certain operations such
@@ -5205,10 +5205,10 @@ void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
  *
  * Returns: 0 on success, else on failure
  */
-int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);
+int ieee80211_reserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_unreserve_tid - request to unreserve a specific TID
+ * ieee80211_unreserve_tid_dup - request to unreserve a specific TID
  *
  * Once there is no longer any need for reserving a certain TID, this function
  * should be called, and no longer will packets have their TID modified for
@@ -5221,10 +5221,10 @@ int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);
  * @sta: the station
  * @tid: the TID to unreserve
  */
-void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);
+void ieee80211_unreserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_ie_split - split an IE buffer according to ordering
+ * ieee80211_ie_split_dup - split an IE buffer according to ordering
  *
  * @ies: the IE buffer
  * @ielen: the length of the IE buffer
@@ -5248,6 +5248,6 @@ void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);
  * buffer starts, which may be @ielen if the entire (remainder)
  * of the buffer should be used.
  */
-size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
+size_t ieee80211_ie_split_dup(const u8 *ies, size_t ielen,
 			  const u8 *ids, int n_ids, size_t offset);
 #endif /* MAC80211_H */
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -94,10 +94,10 @@ struct regulatory_request {
  *	ISO / IEC 3166 alpha2 it belongs to. When this is enabled
  *	we will disregard the first regulatory hint (when the
  *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
- *	wiphy_apply_custom_regulatory() should have this flag set
+ *	wiphy_apply_custom_regulatory_dup() should have this flag set
  *	or the regulatory core will set it for the wiphy.
- *	If you use regulatory_hint() *after* using
- *	wiphy_apply_custom_regulatory() the wireless core will
+ *	If you use regulatory_hint_dup() *after* using
+ *	wiphy_apply_custom_regulatory_dup() the wireless core will
  *	clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
  *	implied that the device somehow gained knowledge of its region.
  * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
@@ -111,8 +111,8 @@ struct regulatory_request {
  *	has these channels enabled would enable them for this wiphy,
  *	the device's original regulatory domain will be trusted as the
  *	base. You can program the superset of regulatory rules for this
- *	wiphy with regulatory_hint() for cards programmed with an
- *	ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ *	wiphy with regulatory_hint_dup() for cards programmed with an
+ *	ISO3166-alpha2 country code. wiphys that use regulatory_hint_dup()
  *	will have their wiphy->regd programmed once the regulatory
  *	domain is set, and all other regulatory hints will be ignored
  *	until their own regulatory domain gets programmed.
--- a/include/net/cfg80211.h	2015-07-21 19:24:11.754130831 +0200
+++ b/include/net/cfg80211.h	2015-07-21 19:24:26.480130471 +0200
@@ -3130,7 +3130,7 @@ struct wiphy {
 
 	u16 max_acl_mac_addrs;
 
-	u32 flags, regulatory_flags, features;
+	u32 flags, features;
 
 	u32 ap_sme_capa;
 
@@ -3156,8 +3156,10 @@ struct wiphy {
 	u32 hw_version;
 
 #ifdef CONFIG_PM
+	union {
+	struct wiphy_wowlan_support wowlan_dummy;
 	const struct wiphy_wowlan_support *wowlan;
-	struct cfg80211_wowlan *wowlan_config;
+	};
 #endif
 
 	u16 max_remain_on_channel_duration;
@@ -3227,6 +3229,11 @@ struct wiphy {
 	u8 max_num_csa_counters;
 	u8 max_adj_channel_rssi_comp;
 
+#ifdef CONFIG_PM
+	struct cfg80211_wowlan *wowlan_config;
+#endif
+	u32 regulatory_flags;
+
 	char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -3437,6 +3444,8 @@ struct wireless_dev {
 
 	struct mutex mtx;
 
+	struct work_struct cleanup_work;
+
 	bool use_4addr, p2p_started;
 
 	u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -3444,6 +3453,12 @@ struct wireless_dev {
 	/* currently used for IBSS and SME - might be rearranged later */
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	u8 ssid_len, mesh_id_len, mesh_id_up_len;
+       enum {
+               CFG80211_SME_IDLE,
+               CFG80211_SME_CONNECTING,
+               CFG80211_SME_CONNECTED,
+       } sme_state;
+
 	struct cfg80211_conn *conn;
 	struct cfg80211_cached_keys *connect_keys;
 
@@ -3452,10 +3467,9 @@ struct wireless_dev {
 
 	struct cfg80211_internal_bss *current_bss; /* associated / joined */
 	struct cfg80211_chan_def preset_chandef;
-	struct cfg80211_chan_def chandef;
+	struct ieee80211_channel *channel;
 
 	bool ibss_fixed;
-	bool ibss_dfs_possible;
 
 	bool ps;
 	int ps_timeout;
@@ -3466,9 +3480,6 @@ struct wireless_dev {
 
 	bool cac_started;
 	unsigned long cac_start_time;
-	unsigned int cac_time_ms;
-
-	u32 owner_nlportid;
 
 #ifdef CONFIG_CFG80211_WEXT
 	/* wext data */
@@ -3484,6 +3495,12 @@ struct wireless_dev {
 		bool prev_bssid_valid;
 	} wext;
 #endif
+
+	bool ibss_dfs_possible;
+	struct cfg80211_chan_def chandef;
+	unsigned int cac_time_ms;
+	u32 owner_nlportid;
+
 };
 
 static inline u8 *wdev_address(struct wireless_dev *wdev)

